<!DOCTYPE html>

<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <link rel="stylesheet" type="text/css" href="../../../../css/read.css" />
    <title>Coder Book menu</title>
    <script type="text/javascript" src="../../../../higtline/scripts/shCore.js"></script>
    <script type="text/javascript" src="../../../../higtline/scripts/shBrushCSharp.js"></script>
    <link type="text/css" rel="stylesheet" href="../../../../higtline/styles/shCoreDefault.css"/>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <script src="../../../../js/Hyphenator.js" type="text/javascript"></script>
</head>

<body id="pageBody" class="hyphenate">

<!-- progress bar -->
<script src="../../../../js/progressBar.js" type="text/javascript"></script>
<div class="Reading-progress" id="progressBarType1"><span id="Progress-bar-top" class="bar-top" style="display: block !important;"></span></div>
<div class="Reading-progress" id="progressBarType2"><span id="Progress-bar-bottom" class="bar-bottom"></span></div>
<div class="Reading-progress" id="progressBarType3"><span id="Progress-bar-left" class="bar-left"></span></div>
<div class="Reading-progress" id="progressBarType4"><span id="Progress-bar-right" class="bar-right"></span></div>
<!-- progress bar -->


    <div id="lesonPage">

        <div id="lessMenu">
           <a id="exitLess" href="list.html" ontouchstart="return true;"><img src="../../../../img/menu/ex.png" /></a>
           <div id="aaLess" ontouchstart="return true;" onclick="OpenSettMenu();"><img src="../../../../img/menu/aa.png" /></div>
           <div id="subMenuInLess" style="display: none;">
                <a href="../../../../menu/setfontsize-ru.html" ontouchstart="return true;" id="pastMenuInLess">Размер текста</a>
                <a href="../../../../menu/setcolor-ru.html" ontouchstart="return true;" id="pastMenuInLess">Цветовая темы</a>
                <a href="../../../../menu/setProgressBar-ru.html" ontouchstart="return true;" id="pastMenuInLess" style="border: none;">Прогресс бар</a>
           </div>
           <div id="aaLess" ontouchstart="return true;">
            <div class="bmEdit" onclick="dellBm();" id="bma411" ontouchstart="return true;" style="display: none;"><img src="../../../../img/menu/bmlessa.png" /></div>
            <div class="bmEdit" onclick="setzBm();" id="bm411" ontouchstart="return true;" style="display: block;"><img src="../../../../img/menu/bmless.png" /></div>
           </div>
        </div>

        <hr />

	<!-- ПОЧАТОК -->

	<h1 id="title">
		Объект
	</h1>

	<p>Объект – это совокупность свойств, методов и событий.</p>
	<p>То есть объект состоит из этих свойств, методов и событий, а они обеспечивают его полноценную работу.</p>
	<p>Представим себе кнопку.</p>
	<p>Она обладает:</p>
	<p><b>Свойствами</b> – цвет, текст на кнопке, шрифт текста и так далее.</p>
	<p><b>Событиями</b> – события пользовательских действий, например, пользователь нажал на кнопку, указатель мыши оказался над кнопкой, и т.п.</p>
	<p><b>Методами</b> – обеспечивающими работу кнопки, например прорисовка кнопки в нажатом и не нажатом виде, прорисовка фокуса (то есть, фокус ввода находится на кнопке).</p>
	<p>Раньше приходилось затрачивать много времени и усилий, чтобы нарисовать такую кнопку на форме, код кнопки мог занимать страницу – полторы.</p>
	<p>Теперь мы имеем автономный объект, который достаточно бросить на форму, и он уже готов к употреблению.</p>
	<p>Нужно две кнопки?</p>
	<p>Три?</p>
	<p>Нет проблем – кидаем на форму столько кнопок, сколько нужно, и не заботимся о том, как программно эти объекты описаны в коде.</p>
	<p>Итак,</p>
	<p><b>Свойства</b> – это переменные, которые влияют на состояние объекта.</p>
	<p>Например, ширина, высота, положение кнопки на форме или надпись на ней.</p>
	<p><b>Методы</b> – это те же процедуры и функции, то есть это то, что объект умеет делать (вычислять).</p>
	<p>Например, объект может иметь процедуру для вывода какого-то текста на экран.</p>
	<p>Кнопка при нажатии меняет форму – это метод кнопки, процедура прорисовки вида нажатой и не нажатой кнопки.</p>
	<p><b>События</b> – это те же процедуры и функции, которые вызываются при наступлении определенного события.</p>
	<p>Например, пользователь нажал на кнопку, вызывается процедура обработки этого нажатия.</p>
	<p>Или мышка оказалась над кнопкой – вызывается процедура обработки этого события, если программист ее создал.</p>
	<p>Как уже упоминалось в первой лекции, программирование с применением объектов для программиста существенно упростилось.</p>
	<p>Вместо того, чтобы вписывать сотни строк кода, описывающего поведение одной единственной кнопки, программист просто объявляет объект типа "Кнопка".</p>
	<p>Далее появились системы визуального программирования, такие как Delphi, которые используют компонентную модель программирования.</p>
	<p>Здесь уже программисту не нужно самостоятельно задавать такие свойства объекта, как его положение на форме, высоту и ширину.</p>
	<p>Вы просто устанавливаете нужный компонент на форму, и мышкой или клавиатурой двигаете, растягиваете или сжимаете его до нужных размеров.</p>
	<p>Серьезное программирование превратилось в детский конструктор, где Вы создаете интерфейс программы даже не задумываясь над тем, сколько кода для этого нужно было бы написать!</p>
	<p>Delphi это делает за Вас.</p>
	<p><b>Компоненты</b> – это более совершенные объекты.</p>
	<p>То есть, это объекты, с которыми можно работать визуально.</p>
	<p>Справедливости ради следует отметить, что существуют и не визуальные компоненты, например, диалоги, с которыми нам скоро предстоит познакомиться.</p>
	<p>Не следует путать понятия "объект" и "компонент".</p>
	<p>Каждый компонент – это объект, но не каждый объект является компонентом.</p>
	<p>Представим себе отвлеченный пример.</p>
	<p>Допустим, у нас на палитре компонентов есть компонент ТЧел, который представляет собой усредненного человека.</p>
	<p>Если мы мышкой щелкнем по этому компоненту, а затем щелкнем по форме, то мы создадим отдельный, автономный объект этого компонента, который уже обладает всеми свойствами, методами и событиями, присущими каждому человеку.</p>
	<p>Как у любого объекта, у него есть свойство Name – имя компонента, то имя, по которому мы будем в дальнейшем обращаться к этому объекту.</p>
	<p>Delphi по умолчанию присвоит ему текст "Чел1".</p>
	<p>Если мы установим на форму еще один такой компонент, то будет создан еще один автономный объект, у которого свойство Name будет содержать строку "Чел2".</p>
	<p>Итак, свойство Name – это переменная строкового типа, принадлежащая любому объекту, и являющаяся идентификатором (опознавателем), по которому к этому объекту нужно обращаться.</p>
	<p>Далее, у нашего воображаемого объекта есть и другие свойства.</p>
	<p>К примеру, свойства Имя, Фамилия, Отчество.</p>
	<p>Это также строковые переменные, принадлежащие этому объекту.</p>
	<p>Мы можем вписать в них нужный текст программно:</p>

	<pre class="brush: csharp;">
	Чел1.Имя := 'Иван';
	Чел1.Отчество := 'Иванович';
	Чел1.Фамилия := 'Иванов';
	</pre>

	<p>Обратите внимание, что свойство Name содержит имя объекта, по которому мы к этому объекту обращаемся.</p>
	<p>Если бы мы изменили в свойстве Name Чел1 на Человек, то код выглядел бы иначе:</p>

	<pre class="brush: csharp;">
	Человек.Имя := 'Иван';
	</pre>

	<p>Точно также, эти свойства мы можем менять в Инспекторе объектов, в момент создания программы.</p>
	<p>Так, мы меняли свойства Caption у кнопок, выводя на них нужный нам текст.</p>
	<p>А перемещая кнопку на нужную позицию, мы тем самым меняли свойства Left и Top.</p>
	<p>Далее, этот объект имеет не только строковые, но и другие типы свойств – переменных.</p>
	<p>Например, возраст (в годах) и рост (в сантиметрах) – это будут переменные целого типа:</p>

	<pre class="brush: csharp;">
	Чел1.Возраст := 30;
	Чел1.Рост := 180;
	</pre>

	<p>Объект может иметь и символьную переменную, например, свойство Пол (м – мужской, ж – женский):</p>

	<pre class="brush: csharp;">
	Чел1.Пол := 'м';
	</pre>

	<p>Также такой объект может иметь и логический тип данных, например, Военнообязанный, то есть, был в армии или нет:</p>

	<pre class="brush: csharp;">
	Чел1.Военнообязанный := True;
	</pre>

	<p>Очень часто бывает, что в различных компонентах мы указываем в инспекторе объектов начальные значения, как бы по умолчанию, а затем во время работы программы меняем их на нужные.</p>
	<p>В программе с убегающей кнопкой, мы задали кнопке начальное положение, а затем, во время работы программы, мы изменяли свойства Left и Top.</p>
	<p>А когда пользователь вводил текст в компонент Edit, программно менялось его свойство Text.</p>
	<p>Итак, мы получили более-менее оформленный объект человека.</p>
	<p>Мы можем накидать целую форму таких объектов, используя компонент ТЧел, и создать целый город Челов.</p>
	<p>И у каждого заполнить приведенные в примерах свойства, так что все объекты будут разными, хотя и произошли от одного общего компонента.</p>
	<p>Вернемся к реальным компонентам. Возьмем компонент TEdit.</p>
	<p>Если мы кинем на форму такой компонент, то Delphi автоматически установит свойство Name равным строке Edit1.</p>
	<p>В дальнейшем мы будем обращаться к этому объекту по этому имени.</p>
	<p>Если же мы в Инспекторе объектов изменим свойство Name с Edit1 на, скажем, MyEdit, то обращаться придется уже не к Edit1, а к MyEdit.</p>
	<p>Предположим, мы изменили это свойство.</p>
	<p>Не забываем, что свойство Name – переменного типа строка.</p>
	<p>Далее, в компоненте TEdit нас интересуют еще несколько свойств.</p>
	<p>Это свойства Left и Top, которые имеют целый тип, и обеспечивают положение компонента на форме.</p>
	<p>Свойство Left указывает в пикселях расстояние от левой границы формы до компонента, а свойство Top – такое же расстояние от верхней границы.</p>
	<p>Еще есть свойства Width (ширина компонента) и Height (высота компонента).</p>
	<p>Это тоже целые типы, они указывают значение в пикселях.</p>
	<p>Также нас интересует свойство Text.</p>
	<p>Это строковая переменная, она указывает, какой текст отображается в этом компоненте.</p>
	<p>Мы можем ввести в него текст в Инспекторе объектов, и тогда при работе программы он сразу же будет отображаться в поле ввода.</p>
	<p>Гораздо чаще его оставляют пустым.</p>
	<p>В Инспекторе объектов просто очищают это свойство, а программно можно присвоить компоненту пустую строку:</p>

	<pre class="brush: csharp;">
	MyEdit.Text := '';
	</pre>

	<p>Затем, во время выполнения программы, пользователь вводит какой-то текст в наш Edit.</p>
	<p>Нам нужно обработать этот текст, и получить к нему доступ мы можем, указав имя нужного объекта и его свойство:</p>

	<pre class="brush: csharp;">
	s := MyEdit.Text;
	</pre>

	<p>В данном примере мы присвоили строковой переменной s тот текст, который в данный момент хранился в поле ввода нашего компонента Edit.</p>
	<p>Напомним, что присвоение происходит слева – направо, то есть вначале указывается переменная, которой мы собираемся присвоить значение, затем идет знак присваивания " := ", после чего идет то значение, которое мы присваиваем этой переменной.</p>
	<p>Мы имеем возможность программно изменить текст в этом объекте, и в данном случае будем указывать переменную – свойство Text:</p>

	<pre class="brush: csharp;">
	MyEdit.Text := 'Новый текст';
	</pre>

	<p>Теперь наш объект будет отображать строку с новым текстом.</p>
	<p>Кроме того, мы программно можем изменять и другие свойства.</p>
	<p>Например, свойство Left – положение от левой границы формы.</p>
	<p>Мы можем указать:</p>

	<pre class="brush: csharp;">
	MyEdit.Left := MyEdit.Left – 5;
	</pre>

	<p>Если мы укажем такой текст, например, в процедуре обработки нажатия кнопки, то каждый раз, когда мы нажимаем на кнопку, объект MyEdit будет сдвигаться влево на 5 пикселей.</p>
	<p>Попробуйте сами!</p>
	<p>Создайте новое приложение, установите на форму компонент TEdit и кнопку.</p>
	<p>Если Вы не изменили свойство Name, то придется обращаться к объекту по имени, которое по умолчанию присвоила ему Delphi:</p>

	<pre class="brush: csharp;">
	Edit1.Left := Edit1.Left - 5;
	</pre>

	<p>Конечно, если Вы пишете не какую-нибудь шуточную программу, то менять положение объектов не стоит, даже если у Вас есть такие возможности.</p>
	<p>Кроме того, Вы имеете возможность программно изменить свойство Name у объекта, но это будет грубейшей ошибкой – как только программа обратится к этому объекту по старому имени, тут же произойдет ошибка выполнения программы – она просто не найдет этот объект.</p>
	<p>Можете попробовать в данном примере, дописав строку:</p>

	<pre class="brush: csharp;">
	Edit1.Name := 'MyEdit';
	</pre>

	<p>Как только Вы нажмете кнопку в первый раз, объект послушно сместится влево, и сразу же за этим поменяет имя.</p>
	<p>Но попробуйте нажать кнопку еще раз, и программа сразу зависнет – она уже не видит объект с новым именем, ведь в коде обработки кнопки мы по прежнему обращаемся к объекту по старому имени, а объекта с таким именем уже не существует!</p>
	<p>Не волнуйтесь, ничего страшного не произошло. Просто выберите в меню команду Run – Program Reset.</p>
	<p>Это заставит программу досрочно прекратить выполнение и закрыться.</p>
	<p>Не забывайте еще вот о чем: не у всех компонентов, которые выводят текст на экран, есть свойство строкового типа Text.</p>
	<p>Например, у компонента TLabel таким свойством является Caption, и если мы хотим в инспекторе объектов вписать в объект какой-то текст, вписывать его нужно именно в свойство Caption.</p>
	<p>Точно также, Если мы желаем программно изменить текст в объекте Label1, то делаем присвоение нового текста его свойству Caption:</p>

	<pre class="brush: csharp;">
	Label1.Caption := 'Новый текст';
	</pre>

	<p>Однако, есть объекты и посложней.</p>
	<p>Возьмем, к примеру, TMemo.</p>
	<p>У него нет свойства Text в инспекторе объектов, однако это свойство доступно программно.</p>
	<p>Переменная – свойство Text объекта Memo1 содержит весь текст, все строки, которые находятся в данный момент в компоненте.</p>
	<p>Однако гораздо чаще применяют свойство Lines.</p>
	<p>Это свойство уже не простая строковая переменная, а целый массив строк, где каждый элемент содержит отдельную строку текста.</p>
	<p>Можно сказать, что Lines – это объект в объекте, который также имеет свои методы, то есть функции и процедуры.</p>
	<p>Чаще всего используют методы SaveToFile() и LoadFromFile(), которые соответственно, сохраняют текст в файл и читают текст из файла.</p>
	<p>Свойство Lines имеет тип TStrings, то есть не просто строку, а набор строк.</p>
	<p>Многие компоненты имеют свойства такого типа.</p>
	<p>Например, компонент TListBox имеет свойство Items, которое принадлежит к тому же типу TStrings, следовательно, имеет такие же методы, как и Lines у компонента TMemo.</p>
	<p>Это значит, что вызвав нужный метод, мы можем, к примеру, считать текст из файла и в Memo, и в ListBox:</p>

	<pre class="brush: csharp;">
	Memo1.Lines.LoadFromFile('myfile.txt');
	ListBox1.Items.LoadFromFile('myfile.txt');
	</pre>

	<p>Вы неоднократно будете встречаться со свойствами типа TStrings в разных компонентах.</p>
	<p>Это очень мощный инструмент, и нужно учиться пользоваться им.</p>

	<script src="../../../../js/progressBarSetIni.js" type="text/javascript"></script>

        <div id="lessMenu" style="margin: 30px 0 0 0;">
            <hr />
            <a href="24.html"><div id="exitLess" ontouchstart="return true;"><img src="../../../../img/menu/pr.png" /></div></a>
            <a href="26.html"><div id="aaLess" ontouchstart="return true;"><img src="../../../../img/menu/ne.png" /></div></a>
        </div>

    </div>

    <script type="text/javascript" src="../../../../cordova.js"></script>
    <script type="text/javascript" src="../../../../js/global.js"></script>
    <script type="text/javascript">
        changeColor();
        if (localStorage.getItem("fSize") < 1) { fSize = 16; localStorage.setItem("fSize", 16); } else { fSize = localStorage.getItem("fSize"); }
        document.getElementById("pageBody").style.fontSize = fSize + "px";

        // goBackMenu
        document.addEventListener("backbutton", goBackMenu, false);
        function goBackMenu()
        {
            window.location.href = 'list.html';
        }

        function changeColor()
        {
            if (localStorage.getItem("colorSheme") <= 1)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#f0f0f0");
            }

            if (localStorage.getItem("colorSheme") == 2)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#212121");
                document.getElementById("pageBody").style.color = localStorage.getItem("#efefef");
            }

            if (localStorage.getItem("colorSheme") == 3)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#efe4d0");
            }
        }

        // bm
        if (localStorage.getItem("arrs") != null)
        {
            var arrs = JSON.parse(localStorage.getItem("arrs"));
        }
        else
        {
            var arrs = [];
        }

        var names = ["../acharter/ru/delphi/book/25.html", "Объект", "bm411"];

        function setzBm() { arrs.push(names); localStorage.setItem("arrs", JSON.stringify(arrs)); localStorage.setItem("bm411", 1); RefBms(); }

        window.onload = function() { RefBms(); }

        function RefBms()
        {
            if (localStorage.getItem("bm411") == 1) { document.getElementById("bma411").style.display = "block"; document.getElementById("bm411").style.display = "none"; } else { document.getElementById("bma411").style.display = "none"; document.getElementById("bm411").style.display = "block"; }
        }

        function dellBm() { for (var i = 0; i < arrs.length; i++) { if (arrs[i].indexOf("Объект") == 1) { arrs.splice(i, 1); localStorage.setItem("bm411", 0); RefBms(); localStorage.setItem("arrs", JSON.stringify(arrs)); } } }

        // sub menu
        var serTimeToClose = 1000;
        
        function OpenSettMenu()
        {
            document.getElementById("subMenuInLess").style.display = "block";
            timeToEvAct();
            serTimeToClose = 1;
        }
        
        function timeToEvAct()
        {
            setTimeout(function() { serTimeToClose = 0 }, 100);
        }
        
        window.addEventListener('click', function(e){
        
            if (serTimeToClose <= 0)
            {
                if (document.getElementById('subMenuInLess').contains(e.target))
                {
                    //
                }
                else
                {
                    document.getElementById("subMenuInLess").style.display = "none";
                }
            }
        });

    </script>

</body>
</html>
