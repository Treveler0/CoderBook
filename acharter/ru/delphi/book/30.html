<!DOCTYPE html>

<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <link rel="stylesheet" type="text/css" href="../../../../css/read.css" />
    <title>Coder Book menu</title>
    <script type="text/javascript" src="../../../../higtline/scripts/shCore.js"></script>
    <script type="text/javascript" src="../../../../higtline/scripts/shBrushCSharp.js"></script>
    <link type="text/css" rel="stylesheet" href="../../../../higtline/styles/shCoreDefault.css"/>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <script src="../../../../js/Hyphenator.js" type="text/javascript"></script>
</head>

<body id="pageBody" class="hyphenate">

<!-- progress bar -->
<script src="../../../../js/progressBar.js" type="text/javascript"></script>
<div class="Reading-progress" id="progressBarType1"><span id="Progress-bar-top" class="bar-top" style="display: block !important;"></span></div>
<div class="Reading-progress" id="progressBarType2"><span id="Progress-bar-bottom" class="bar-bottom"></span></div>
<div class="Reading-progress" id="progressBarType3"><span id="Progress-bar-left" class="bar-left"></span></div>
<div class="Reading-progress" id="progressBarType4"><span id="Progress-bar-right" class="bar-right"></span></div>
<!-- progress bar -->


    <div id="lesonPage">

        <div id="lessMenu">
           <a id="exitLess" href="list.html" ontouchstart="return true;"><img src="../../../../img/menu/ex.png" /></a>
           <div id="aaLess" ontouchstart="return true;" onclick="OpenSettMenu();"><img src="../../../../img/menu/aa.png" /></div>
           <div id="subMenuInLess" style="display: none;">
                <a href="../../../../menu/setfontsize-ru.html" ontouchstart="return true;" id="pastMenuInLess">Размер текста</a>
                <a href="../../../../menu/setcolor-ru.html" ontouchstart="return true;" id="pastMenuInLess">Цветовая темы</a>
                <a href="../../../../menu/setProgressBar-ru.html" ontouchstart="return true;" id="pastMenuInLess" style="border: none;">Прогресс бар</a>
           </div>
           <div id="aaLess" ontouchstart="return true;">
            <div class="bmEdit" onclick="dellBm();" id="bma416" ontouchstart="return true;" style="display: none;"><img src="../../../../img/menu/bmlessa.png" /></div>
            <div class="bmEdit" onclick="setzBm();" id="bm416" ontouchstart="return true;" style="display: block;"><img src="../../../../img/menu/bmless.png" /></div>
           </div>
        </div>

        <hr />

	<!-- ПОЧАТОК -->

	<h1 id="title">
		Свойства Enabled и Visible
	</h1>

	<p>Эти свойства присутствуют практически у всех визуальных компонентов, и позволяют использовать интересные приемы программирования.</p>
	<p>Откройте проект с редактором текста.</p>
	<p>У вас там есть три кнопки – "Сохранить", "Загрузить" и "Очистить".</p>
	<p>Давайте предположим, что пользователь набрал какой-то важный текст и сохранил его.</p>
	<p>На следующий день он снова загрузил ваш редактор, но по ошибке вместо кнопки "Загрузить" он нажал кнопку "Сохранить".</p>
	<p>Что произойдет?</p>
	<p>Никакого текста в данный момент компонент Memo не содержит.</p>
	<p>Если будет выполнена команда:</p>

	<pre class="brush: csharp;">
	Memo1.Lines.SaveToFile('MyFile.txt');
	</pre>

	<p>то наш файл перезапишется – важный текст будет стерт, а взамен ничего не запишется, так как текста нет.</p>
	<p>Пользователь, совершив небольшую ошибку, потеряет свою работу.</p>
	<p>Конечно, виноват пользователь – он нажал не ту кнопку.</p>
	<p>Но в большей степени здесь виноват программист, что не предусмотрел такого развития событий, и не сделал для своей программы элементарной защиты от ошибок пользователя.</p>
	<p>Исправим ошибку.</p>
	<p>Свойство Enabled отвечает за доступность компонентов.</p>
	<p>Это свойство имеет логический тип, и может быть либо True, либо False.</p>
	<p>Выделите кнопку с надписью "Сохранить", найдите ее свойство Enabled и вместо установленного по умолчанию значения True, выберите значение False.</p>
	<p>На форме не произошло видимых изменений, мы не сможем их увидеть в режиме разработки программы.</p>
	<p>Однако сохраните проект, скомпилируйте командой Run и посмотрите на результат – кнопка "Сохранить" видна на форме, но ее надпись выходит серым, неактивным цветом, а на кнопку невозможно нажать.</p>
	<p>Теперь у пользователя нет возможности нажать на эту кнопку, значит, он не совершит такой ошибки.</p>
	<p>Но это только полдела, надо все-таки в процессе работы программы ему эту возможность вернуть, иначе как же он сможет сохранить текст?</p>
	<p>В "ООП" мы обсуждали событие OnChange, которое происходит всякий раз, когда компонент изменяется.</p>
	<p>Этим мы и воспользуемся.</p>
	<p>Выделите компонент Memo, в Инспекторе объектов перейдите на вкладку Events (События) и найдите там событие OnChange.</p>
	<p>Дважды щелкните по нему, чтобы сгенерировать процедуру – обработчик этого события.</p>
	<p>В этой процедуре запишем всего только одну строку:</p>

	<pre class="brush: csharp;">
	Button1.Enabled := True;
	</pre>

	<p>Таким образом, при изменении компонента Memo (пользователь изменил текст), мы делаем доступной кнопку "Сохранить".</p>
	<p>Теперь пользователь может сохранить свои изменения.</p>
	<p>Подумаем теперь вот о чем: когда пользователь сохранил текст, следует ли оставлять кнопку "Сохранить" доступной?</p>
	<p>Очевидно, нет, если у текста не произошли изменения.</p>
	<p>Поэтому щелкайте дважды по кнопке "Сохранить", и после строки, где текст сохраняется, добавьте строку</p>

	<pre class="brush: csharp;">
	Button1.Enabled := False;
	</pre>

	<p>Сразу, как только текст будет сохранен, кнопка "Сохранить" снова станет недоступной, пока пользователь не произведет очередных изменений в тексте.</p>
	<p>Также сделайте недоступной эту кнопку после того, как пользователь нажмет кнопку "Очистка", эта кнопка очищает набранный текст, что само по себе заставляет работать событие OnChange компонента Memo, однако сохранять пустоту смысла нет.</p>
	<p>Свойство Visible компонентов работает практически также, как свойство Enabled, только вместо того, чтобы делать компонент недоступным, оно делает его невидимым.</p>
	<p>Visible также имеет логический тип, и может быть либо True (компонент видим), либо False (невидим).</p>
	<p>Самостоятельно измените все приведенные выше рекомендации, использовав вместо свойства Enabled свойство Visible.</p>
	<p>Посмотрите на результат.</p>
	<p>Скрывать или отключать можно не только кнопки, но и вообще все видимые компоненты – редактор Memo, поле Edit, надпись Label.</p>
	<p>Даже у формы есть эти свойства, поэтому при некоторой фантазии вы можете добиваться вполне профессиональных эффектов.</p>

	<script src="../../../../js/progressBarSetIni.js" type="text/javascript"></script>

        <div id="lessMenu" style="margin: 30px 0 0 0;">
            <hr />
            <a href="29.html"><div id="exitLess" ontouchstart="return true;"><img src="../../../../img/menu/pr.png" /></div></a>
            <a href="31.html"><div id="aaLess" ontouchstart="return true;"><img src="../../../../img/menu/ne.png" /></div></a>
        </div>

    </div>

    <script type="text/javascript" src="../../../../cordova.js"></script>
    <script type="text/javascript" src="../../../../js/global.js"></script>
    <script type="text/javascript">
        changeColor();
        if (localStorage.getItem("fSize") < 1) { fSize = 16; localStorage.setItem("fSize", 16); } else { fSize = localStorage.getItem("fSize"); }
        document.getElementById("pageBody").style.fontSize = fSize + "px";

        // goBackMenu
        document.addEventListener("backbutton", goBackMenu, false);
        function goBackMenu()
        {
            window.location.href = 'list.html';
        }

        function changeColor()
        {
            if (localStorage.getItem("colorSheme") <= 1)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#f0f0f0");
            }

            if (localStorage.getItem("colorSheme") == 2)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#212121");
                document.getElementById("pageBody").style.color = localStorage.getItem("#efefef");
            }

            if (localStorage.getItem("colorSheme") == 3)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#efe4d0");
            }
        }

        // bm
        if (localStorage.getItem("arrs") != null)
        {
            var arrs = JSON.parse(localStorage.getItem("arrs"));
        }
        else
        {
            var arrs = [];
        }

        var names = ["../acharter/ru/delphi/book/30.html", "Enabled и Visible", "bm416"];

        function setzBm() { arrs.push(names); localStorage.setItem("arrs", JSON.stringify(arrs)); localStorage.setItem("bm416", 1); RefBms(); }

        window.onload = function() { RefBms(); }

        function RefBms()
        {
            if (localStorage.getItem("bm416") == 1) { document.getElementById("bma416").style.display = "block"; document.getElementById("bm416").style.display = "none"; } else { document.getElementById("bma416").style.display = "none"; document.getElementById("bm416").style.display = "block"; }
        }

        function dellBm() { for (var i = 0; i < arrs.length; i++) { if (arrs[i].indexOf("Enabled и Visible") == 1) { arrs.splice(i, 1); localStorage.setItem("bm416", 0); RefBms(); localStorage.setItem("arrs", JSON.stringify(arrs)); } } }

        // sub menu
        var serTimeToClose = 1000;
        
        function OpenSettMenu()
        {
            document.getElementById("subMenuInLess").style.display = "block";
            timeToEvAct();
            serTimeToClose = 1;
        }
        
        function timeToEvAct()
        {
            setTimeout(function() { serTimeToClose = 0 }, 100);
        }
        
        window.addEventListener('click', function(e){
        
            if (serTimeToClose <= 0)
            {
                if (document.getElementById('subMenuInLess').contains(e.target))
                {
                    //
                }
                else
                {
                    document.getElementById("subMenuInLess").style.display = "none";
                }
            }
        });

    </script>

</body>
</html>
