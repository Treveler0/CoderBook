
<!DOCTYPE html>

<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <link rel="stylesheet" type="text/css" href="../../../../css/read.css" />
    <title>Coder Book menu</title>
    <script type="text/javascript" src="../../../../higtline/scripts/shCore.js"></script>
    <script type="text/javascript" src="../../../../higtline/scripts/shBrushCSharp.js"></script>
    <link type="text/css" rel="stylesheet" href="../../../../higtline/styles/shCoreDefault.css"/>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <script src="../../../../js/Hyphenator.js" type="text/javascript"></script>
</head>

<body id="pageBody" class="hyphenate">

<!-- progress bar -->
<script src="../../../../js/progressBar.js" type="text/javascript"></script>
<div class="Reading-progress" id="progressBarType1"><span id="Progress-bar-top" class="bar-top" style="display: block !important;"></span></div>
<div class="Reading-progress" id="progressBarType2"><span id="Progress-bar-bottom" class="bar-bottom"></span></div>
<div class="Reading-progress" id="progressBarType3"><span id="Progress-bar-left" class="bar-left"></span></div>
<div class="Reading-progress" id="progressBarType4"><span id="Progress-bar-right" class="bar-right"></span></div>
<!-- progress bar -->


    <div id="lesonPage">

        <div id="lessMenu">
           <a id="exitLess" href="list.html" ontouchstart="return true;"><img src="../../../../img/menu/ex.png" /></a>
           <div id="aaLess" ontouchstart="return true;" onclick="OpenSettMenu();"><img src="../../../../img/menu/aa.png" /></div>
           <div id="subMenuInLess" style="display: none;">
                <a href="../../../../menu/setfontsize-ru.html" ontouchstart="return true;" id="pastMenuInLess">Размер текста</a>
                <a href="../../../../menu/setcolor-ru.html" ontouchstart="return true;" id="pastMenuInLess">Цветовая темы</a>
                <a href="../../../../menu/setProgressBar-ru.html" ontouchstart="return true;" id="pastMenuInLess" style="border: none;">Прогресс бар</a>
           </div>
           <div id="aaLess" ontouchstart="return true;">
            <div class="bmEdit" onclick="dellBm();" id="bma1379" ontouchstart="return true;" style="display: none;"><img src="../../../../img/menu/bmlessa.png" /></div>
            <div class="bmEdit" onclick="setzBm();" id="bm1379" ontouchstart="return true;" style="display: block;"><img src="../../../../img/menu/bmless.png" /></div>
           </div>
        </div>

        <hr />

    <!-- ПОЧАТОК -->
    
    <h1 id="title">
        Eщё немного о методах
    </h1>
    
    <p>Пока что мы видели несколько различных методов: puts и gets и так далее (Быстрый тест: Перечислите все методы, которые мы узнали до сих пор! Их десять; ответ приводится ниже.), но мы совсем не говорили о том, что из себя представляют методы.</p>
    <p>Мы знаем, что они делают, но мы не знаем, "что они такое".</p>
    <p>И вот что они есть на самом деле: нечто, которое выполняет что-либо.</p>
    <p>Если объекты (такие как строки, целые и плавающие числа) являются существительными в языке Ruby, то методы подобны глаголам.</p>
    <p>И совсем также, как в английском языке, вы не используете глагол без существительного, чтобы выполнить действие, обозначаемое глаголом.</p>
    <p>Например, тиканье не совершается само по себе; настенные часы (или наручные или что-нибудь ещё) должны производить его.</p>
    <p>На естественном языке мы бы сказали: "Часы тикают".</p>
    <p>На Ruby мы бы сказали <b>clock.tick</b> (естественно, предполагая, что clock — это объект Ruby).</p>
    <p>Программисты могли бы сказать, что мы  "вызвали метод tick объекта clock" или что мы "вызвали tick у clock".</p>
    <p>Ну что, вы выполнили тест?</p>
    <p>Хорошо.</p>
    <p>Что ж, я уверен, что вы вспомнили методы puts, gets и chomp, так как мы только что разобрали их.</p>
    <p>Вы, возможно, также усвоили наши  методы преобразования: <b>to_i</b>, <b>to_f</b> и <b>to_s</b>.</p>
    <p>Однако, знаете ли вы остальные четыре?</p>
    <p>Ну конечно же, это не что иное, как старые добрые арифметические действия: <b>+</b>, <b>-</b>, <b>*</b> и <b>/</b>!</p>
    <p>Как я уже говорил ранее, также как каждому глаголу нужно существительное, так и каждому методу требуется объект.</p>
    <p>Обычно легко сказать, какой объект выполняет метод: тот, что стоит непосредственно перед точкой, как в примере с <b>clock.tick</b> или в <b>101.to_s</b>.</p>
    <p>Иногда же это не столь очевидно, например, в арифметических методах.</p>
    <p>Выясняется, что 5 + 5 это на самом деле просто сокращённый способ записи 5.+ 5.</p>
    <p>Например:</p>

    <pre class="brush: csharp;">
    puts 'привет '.+ 'мир'
    puts (10.* 9).+ 9
    </pre>

    <p>Результат:</p>

    <pre class="brush: csharp;">
    привет мир
    99
    </pre>

    <p>Выглядит не слишком привлекательно, поэтому мы больше не будем записывать методы в таком виде.</p>
    <p>Но нам ведь важно понимать, что же происходит в действительности.</p>
    <p>На моей машине, эта программа также выдаёт мне такое предупреждение:</p>

    <pre class="brush: csharp;">
    warning: parenthesize argument(s)for future_version
    [предупреждение: заключите аргумент(ы) в скобки для будущих версий]
    </pre>

    <p>Этот код прекрасно выполнился, но мне было сказано, что возникли трудности при выяснении, что я имею в виду, поэтому на будущее рекомендуется использовать дополнительно скобки.</p>
    <p>И это также даёт нам более глубокое понимание, почему мы можем выполнить  'pig'*5, но не можем выполнить 5*'pig': 'pig'*5 указывает 'pig' выполнить умножение, а 5*'pig' предписывает числу 5 выполнить умножение.</p>
    <p>Строка 'pig' знает, как сделать 5 собственных копий и объединить их вместе; однако, числу 5 будет затруднительно сделать 'pig' копий самого себя и сложить их вместе.</p>
    <p>И, конечно, нам всё ещё нужно выяснить про puts и gets.</p>
    <p>Где же их объекты?</p>
    <p>В английском языке, вы можете иногда опустить существительное; например, если злодей завопит "Умри!", неявным существительным будет тот, кому он кричит.</p>
    <p>В Ruby, если я говорю puts 'быть или не быть', на самом деле я говорю: <b>self.puts</b> 'быть или не быть'.</p>
    <p>Но что же такое <b>self</b>?</p>
    <p>Это специальная переменная, которая указывает на тот объект, в котором вы находитесь.</p>
    <p>Мы пока что не знаем, как находиться внутри объекта, но покуда мы это не выяснили, мы всегда будем находиться в большом объекте, которым является... вся наша программа!</p>
    <p>И к счастью для нас, у этой программы есть несколько собственных методов, наподобие <b>puts</b> и <b>gets</b>.</p>
    <p>Посмотрите:</p>

    <pre class="brush: csharp;">
    iCantBelieveIMadeAVariableNameThisLongJustToPointToA3 = 3
    puts iCantBelieveIMadeAVariableNameThisLongJustToPointToA3
    self.puts iCantBelieveIMadeAVariableNameThisLongJustToPointToA3
    </pre>

    <p>Результат:</p>

    <pre class="brush: csharp;">
    3
    3
    </pre>

    <p>Если вы не совсем въехали во всё это, это нормально.</p>
    <p>Самое важное, что нужно из всего этого уяснить, это то, что каждый метод выполняется некоторым объектом, даже если перед ним не стоит точка.</p>
    <p>Если вы понимаете это, то вы вполне готовы двигаться дальше.</p>
    
    <h2 id="title">
        Забавные строковые методы
    </h2>
    
    <p>Давайте изучим несколько забавных строковых методов.</p>
    <p>Вам не нужно их все запоминать; достаточно просто ещё раз взглянуть на эту страницу, если вы их позабудете.</p>
    <p>Я только хочу показать вам небольшую часть того, что могут делать строки.</p>
    <p>На самом деле, я и сам не могу запомнить даже половины строковых методов — но это нормально, потому что в Интернете есть замечательные справочники, где перечислены и объяснены все строковые методы.</p>
    <p>Я покажу вам, где их найти в конце этого учебника.</p>
    <p>Серьёзно, я даже не хочу знать все строковые методы: это всё равно, что знать каждое слово в словаре.</p>
    <p>Я прекрасно могу говорить по-английски, не зная всех слов в словаре...</p>
    <p>и ведь не в этом же заключается сам смысл словаря? Вам ведь не требуется знать всё, что в нём содержится?</p>
    <p>Итак, наш первый строковый метод это reverse, который выдаёт значение строки, перевёрнутое задом наперёд:</p>

    <pre class="brush: csharp;">
    var1 = 'барк'
    var2 = 'телекс'
    var3 = 'Вы можете произнести это предложение наоборот?'

    puts var1.reverse
    puts var2.reverse
    puts var3.reverse
    puts var1
    puts var2
    puts var3
    </pre>

    <p>Результат:</p>

    <pre class="brush: csharp;">
    краб
    скелет
    ?торобоан еинежолдерп отэ итсензиорп етежом ыВ
    барк
    телекс
    </pre>

    <p>Вы можете произнести это предложение наоборот?</p>
    <p>Как видите, reverse не переворачивает значение исходной строки, он просто создаёт её новую перевёрнутую копию.</p>
    <p>Вот почему в var1 по-прежнему содержится 'барк' даже после того, как мы вызвали <b>reverse</b> у var1.</p>
    <p>Другой строковый метод это length, который сообщает нам количество символов (включая пробелы) в строке:</p>

    <pre class="brush: csharp;">
    puts 'Как Ваше полное имя?'
    name = gets.chomp
    puts 'Вы знаете, что Ваше имя состоит из '+name.length+' символов, '+name+'?'
    </pre>

    <p>Результат:</p>

    <pre class="brush: csharp;">
    Как Ваше полное имя?
    Christopher David Pine
    #&lt;TypeError: can&apos;t convert Fixnum into String&gt;
    </pre>

    <p>Ой-ё-ёй!</p>
    <p>Что-то не сработало, и, кажется, это случилось где-то после строки <b>name = gets.chomp</b>...</p>
    <p>Вы понимаете, в чём дело? Поглядим, сможете ли вы разобраться с этим.</p>
    <p>Причина заморочки — в методе length: он выдаёт нам число, а нам нужна строка.</p>
    <p>Исправить это довольно просто: мы только воткнём <b>to_s</b> (и скрестим пальцы на удачу):</p>

    <pre class="brush: csharp;">
    puts 'Как Ваше полное имя?'
    name = gets.chomp
    puts 'Вы знаете, что Ваше имя состоит из '+name.length.to_s+' символов, '+name+'?'
    </pre>

    <p>Результат:</p>

    <pre class="brush: csharp;">
    Как Ваше полное имя?
    Christopher David Pine
    </pre>

    <p>Вы знаете, что Ваше имя состоит из 22 символов, Christopher David Pine?</p>
    <p>Нет, я этого не знал.</p>
    <p><b>Внимание:</b> это количество символов в моём имени, а не количество букв (сосчитайте их).</p>
    <p>Думаю, мы могли бы написать программу, которая спрашивает ваше имя, отчество и фамилию по отдельности, а затем складывает их длины... эй, почему бы вам это не сделать?</p>
    <p>Давайте, я подожду.</p>
    <p>И что, сделали?</p>
    <p>Хорошо!</p>
    <p>Нравится программировать, не так ли?</p>
    <p>А вот после нескольких следующих глав вы сами изумитесь тому, что вы сможете делать.</p>
    <p>Итак, есть ещё несколько строковых методов, которые изменяют регистр букв (заглавных или строчных) в вашей строке.</p>
    <p><b>upcase</b> изменяет каждую строчную букву на заглавную, а <b>downcase</b> изменяет каждую заглавную букву на строчную.</p>
    <p><b>swapcase</b> переключает регистр каждой буквы в строке, и наконец, <b>capitalize</b> работает совсем как <b>downcase</b> за исключением того, что он переводит первую букву в заглавную (если это буква).</p>

    <pre class="brush: csharp;">
    letters = 'aAbBcCdDeE'
    puts letters.upcase
    puts letters.downcase
    puts letters.swapcase
    puts letters.capitalize
    puts ' a'.capitalize
    puts letters
    </pre>

    <p>Результат:</p>

    <pre class="brush: csharp;">
    AABBCCDDEE
    aabbccddee
    AaBbCcDdEe
    Aabbccddee
     a
    aAbBcCdDeE
    </pre>

    <p>Довольно обычные средства. Как видно из строки <b>puts ' a'.capitalize</b>, метод capitalize переводит в заглавную только первый символ, а не первую букву.</p>
    <p>И также, как мы уже видели раньше, при вызове всех этих методов, значение letters остаётся неизменным.</p>
    <p>Мне не хотелось бы слишком вас мучить этим, но это важно понимать.</p>
    <p>Есть ещё несколько методов, которые действительно изменяют ассоциированные с ними объекты, но мы их пока что не видели и не увидим ещё некоторое время.</p>
    <p>Чтобы преобразовывать строки с русскими буквами потребуется установить одну из дополнительных библиотек, например, active_support, и тогда можно будет воспользоваться методами "строка".chars.downcase, "строка".chars.upcase,  "строка".chars.capitalize.</p>
    <p>Остальные из этих забавных строковых методов, рассматриваемых нами, предназначены для визуального форматирования.</p>
    <p>Первый из них, center, добавляет пробелы в начало и в конец строки, чтобы отцентрировать её.</p>
    <p>Однако, также как вам требовалось указать методу puts, что вы хотите напечатать, а методу +, что вы хотите сложить, вам нужно указать методу center, какой ширины должна быть ваша отцентрированная строка.</p>
    <p>Так, если бы мне захотелось расположить по центру строки стихотворения, я бы сделал это примерно так:</p>

    <pre class="brush: csharp;">
    lineWidth = 50
    puts(  'Вот вам юная мисс из России:'.center(lineWidth))
    puts(   'Визг её был ужасен по силе.'.center(lineWidth))
    puts(        'Он разил, как кинжал,-'.center(lineWidth))
    puts(          'Так никто не визжал,'.center(lineWidth))
    puts('Как визжала та Мисс из России.'.center(lineWidth))
    </pre>

    <p>Результат:</p>

    <pre class="brush: csharp;">
               Вот вам юная мисс из России:           
               Визг её был ужасен по силе.            
                  Он разил, как кинжал,-              
                   так никто не визжал,               
              Как визжала та Мисс из России.          
    </pre>

    <p>Хммм... Не думаю, что этот детский стишок звучит именно так, но мне просто лень уточнить по книге.</p>
    <p>Кроме того, я хотел выровнять части строк программы, где встречается .center(lineWidth), поэтому я вставил эти лишние пробелы перед строками.</p>
    <p>Это сделано просто потому, что мне кажется, что так красивее.</p>
    <p>У программистов часто вызывает сильные чувства обсуждение того, что в программе является красивым, и они часто расходятся во мнениях об этом.</p>
    <p>Чем больше вы программируете, тем больше вы следуете своему собственному стилю.</p>
    <p>Что касается разговоров о лени, то лень в программировании — это не всегда плохо. Например, видите, что я сохранил ширину стихотворения в переменной lineWidth?</p>
    <p>Это для того, чтобы, если я захочу позже вернуться к программе и сделать стих шире, мне нужно будет изменить только самую верхнюю строку программы вместо того, чтобы менять каждую из строк, где есть центрирование.</p>
    <p>При достаточно длинном стихотворении это может сэкономить мне немало времени.</p>
    <p>Вот такая разновидность лени — это действительно добродетель в программировании.</p>
    <p>Так вот, о центрировании...</p>
    <p>Как вы могли заметить, оно не столь прекрасно, как его мог бы сделать текстовый процессор.</p>
    <p>Если вы действительно хотите идеальное центрирование (и, возможно, более симпатичный шрифт), тогда вы просто должны использовать текстовый процессор!</p>
    <p><b>Ruby — это удивительный инструмент</b>, но нет ни одного инструмента идеального для любой работы.</p>
    <p>Два других метода форматирования строк — это ljust и rjust, названия которых обозначают left justify (выровнять влево) и right justify (выровнять вправо).</p>
    <p>Они похожи на center за исключением того, что они добавляют к строке пробелы соответственно с левой или с правой стороны.</p>
    <p>Давайте посмотрим все три метода в действии:</p>

    <pre class="brush: csharp;">
    lineWidth = 40
    str = '--> текст <--'
    puts str.ljust  lineWidth
    puts str.center lineWidth
    puts str.rjust  lineWidth
    puts str.ljust (lineWidth/2) + str.rjust (lineWidth/2)
    </pre>

    <p>Результат:</p>

    <pre class="brush: csharp;">
    --> текст <--                           
                  --> текст <--             
                               --> текст <--
    --> текст <--              --> текст <--
    </pre>

    <h2 id="title">
        Попробуйте ещё кое-что
    </h2>
    
    <ul>
        <li>Напишите программу "Злой Начальник". Он должен грубо спрашивать, чего вы хотите. Что бы вы ему ни ответили, Злой Начальник должен орать вам это же самое в ответ, а затем увольнять вас. Например, если вы введёте:</li>
    </ul>

    <pre class="brush: csharp;">
    Я хочу повышения зарплаты.,
    </pre>

    <p>он должен прокричать в ответ:</p>

    <pre class="brush: csharp;">
    ЧТО ЗНАЧИТ: "Я ХОЧУ ПОВЫШЕНИЯ ЗАРПЛАТЫ."?!? ВЫ УВОЛЕНЫ!!
    </pre>

    <ul>
        <li>А вот здесь для вас есть кое-что, чтоб ещё поиграть с center, ljust и rjust: напишите программу, которая будет отображать "Содержание" так, чтобы это выглядело следующим образом:</li>
    </ul>

    <pre class="brush: csharp;">
                         Содержание                   
                                                      
    Глава 1:  Числа                             page 1
    Глава 2:  Буквы                            page 72
    Глава 3:  Переменные                      page 118
    </pre>

    <h2 id="title">
        Высшая математика
    </h2>
    
    <p>Этот раздел — совершенно необязательный.</p>
    <p>Он предполагает некоторый уровень математических знаний.</p>
    <p>Если вам не интересно, вы можете без малейших затруднений перейти прямо к Управлению выполнением.</p>
    <p>Однако, быстрый взгляд на раздел о случайных числах может весьма пригодиться.</p>
    <p>Числовых методов не настолько много, как строковых методов (хотя я всё равно не держу их все в своей голове).</p>
    <p>Здесь мы рассмотрим оставшиеся арифметические методы, генератор случайных чисел и объект Math с его тригонометрическими и трансцендентальными методами.</p>

    <h2 id="title">
        Снова арифметика
    </h2>
    
    <p>Ещё два арифметических метода — это ** (возведение в степень) и % (деление по модулю).</p>
    <p>Так что, если вы хотите сказать на Ruby "пять в квадрате", вы просто запишите это как 5**2.</p>
    <p>Вы также можете использовать в качестве степени числа с плавающей точкой, так что если вам нужен квадратный корень из пяти, вы можете написать 5**0.5.</p>
    <p>Метод % (деление по модулю) выдаёт остаток от деления на число.</p>
    <p>Так, например, если я разделю 7 на 3, то получу 2 и 1 в остатке.</p>
    <p>Давайте посмотрим, как это работает в программе:</p>

    <pre class="brush: csharp;">
    puts 5**2
    puts 5**0.5
    puts 7/3
    puts 7%3
    puts 365%7
    </pre>

    <p>Результат:</p>

    <pre class="brush: csharp;">
    25
    2.23606797749979
    2
    1
    1
    </pre>

    <p>Из последней строки мы узнали, что любой (не високосный) год состоит из некоторого количества недель плюс один день.</p>
    <p>Так что, если ваш день рождения был во вторник в этом году, на следующий год он будет в среду.</p>
    <p>Вы также можете применять в методе деления по модулю числа с плавающей точкой.</p>
    <p>В основном, он выполняет вычисления наиболее возможным осмысленным способом... но я предоставляю вам самим поиграть с этим.</p>
    <p>Остаётся упомянуть ещё один метод прежде, чем мы проверим работу генератора случайных чисел: abs.</p>
    <p>Он просто берёт абсолютное значение указанного числа:</p>

    <pre class="brush: csharp;">
    puts((5-2).abs)
    puts((2-5).abs)
    </pre>

    <p>Результат:</p>

    <pre class="brush: csharp;">
    3
    3
    </pre>

    <h2 id="title">
        Случайные числа
    </h2>
    
    <p>Ruby поставляется с довольно хорошим генератором случайных чисел.</p>
    <p>Метод, возвращающий случайно выбранное число, называется  rand.</p>
    <p>Если вы вызовете rand как есть (без аргументов), вы получите дробное число, большее или равное 0.0 и меньшее 1.0.</p>
    <p>Если вы дадите методу rand целое (например, 5), он вернёт вам целое число, большее или равное 0 и меньшее, чем 5 (то есть одно из пяти возможных чисел, от 0 до 4).</p>
    <p>Давайте посмотрим rand в действии.</p>
    <p>Если вы перезагрузите эту страницу, то эти числа будут каждый раз другими.</p>
    <p>Вы ведь знали, что я на самом деле выполнял все эти программы, не так ли?</p>

    <pre class="brush: csharp;">
    puts rand
    puts rand
    puts rand
    puts(rand(100))
    puts(rand(100))
    puts(rand(100))
    puts(rand(1))
    puts(rand(1))
    puts(rand(1))
    puts(rand(99999999999999999999999999999999999999999999999999999999999))
    puts('Синоптик сказал, что с вероятностью в '+rand(101).to_s+'% пойдёт дождь,')
    puts('но никогда не стоит доверять синоптикам.')
    </pre>

    <p>Результат:</p>

    <pre class="brush: csharp;">
    0.053950924931684
    0.975039266747952
    0.436084118016833
    63
    40
    38
    0
    0
    0
    54350491927962189206794015651522429182285732200948685516886
    Синоптик сказал, что с вероятностью в 22% пойдёт дождь,
    но никогда не стоит доверять синоптикам.
    </pre>

    <p>Обратите внимание, что я использовал rand(101), чтобы получить числа от 0 до 100, и что rand(1) всегда возвращает 0.</p>
    <p>Непонимание того, каков диапазон возможных возвращаемых значений, является, по-моему, самой частой ошибкой, которую делают при работе с rand; даже профессиональные программисты и даже в завершённых программных продуктах, которые вы покупаете в магазине.</p>
    <p>У меня даже однажды был CD-проигрыватель, который в режиме "Случайное воспроизведение" проигрывал все песни, кроме последней...</p>
    <p>Я гадал, что бы могло произойти, если я бы вставил в него CD с одной-единственной песней?</p>
    <p>Иногда вы можете захотеть, чтобы rand возвращал те же самые случайные числа в той же последовательности при двух разных запусках вашей программы.</p>
    <p>Например, я однажды использовал случайно сгенерированные числа для создания случайно сгенерированного мира в компьютерной игре.</p>
    <p>Если я обнаружил мир, который мне по-настоящему понравился, возможно, мне захочется снова сыграть с ним или отправить его другу.</p>
    <p>Чтобы проделать это, вам нужно задать seed, что можно сделать методом srand.</p>
    <p>Вот так:</p>

    <pre class="brush: csharp;">
    srand 1776
    puts(rand(100))
    puts(rand(100))
    puts(rand(100))
    puts(rand(100))
    puts(rand(100))
    puts ''
    srand 1776
    puts(rand(100))
    puts(rand(100))
    puts(rand(100))
    puts(rand(100))
    puts(rand(100))
    </pre>

    <p>Результат:</p>

    <pre class="brush: csharp;">
    24
    35
    36
    58
    70

    24
    35
    36
    58
    70
    </pre>

    <p>Одно и то же будет выдаваться каждый раз, когда вы "посеете" то же самое число в качестве зерна.</p>
    <p>Если вы снова хотите получать различные числа (также, как происходит, если вы не применяли до этого srand), то просто вызовите srand 0.</p>
    <p>Этим вызовом в генератор "засевается" действительно причудливое число с использованием (кроме всего прочего) текущее время в вашем компьютере, с точностью до миллисекунды.</p>

    <h2 id="title">
        Объект Math
    </h2>
    
    <p>Наконец, давайте рассмотрим объект Math. Наверное, нам следует сразу окунуться в примеры:</p>

    <pre class="brush: csharp;">
    puts(Math::PI)
    puts(Math::E)
    puts(Math.cos(Math::PI/3))
    puts(Math.tan(Math::PI/4))
    puts(Math.log(Math::E**2))
    puts((1 + Math.sqrt(5))/2)
    </pre>

    <p>Результат:</p>

    <pre class="brush: csharp;">
    3.14159265358979
    2.71828182845905
    0.5
    1.0
    2.0
    1.61803398874989
    </pre>

    <p>Первое, что вы, возможно, заметили, это символы :: в обозначениях констант.</p>
    <p>Объяснение оператора пределов видимости (а это именно он) на самом деле выходит за, хм... пределы этого учебника.</p>
    <p>Я не хотел каламбурить.</p>
    <p>Честное слово.</p>
    <p>Достаточно сказать, что вы можете просто использовать <b>Math::PI</b> в ожидаемом вами значении.</p>
    <p>Как видите, в Math есть всё, что вы предполагаете иметь в приличном научном калькуляторе.</p>
    <p>И как и прежде, дробные числа действительно близко представляют правильные результаты.</p>
    <p>А теперь перейдём к выполнению!</p>

    <script src="../../../../js/progressBarSetIni.js" type="text/javascript"></script>

        <div id="lessMenu" style="margin: 30px 0 0 0;">
            <hr />
            <a href="6.html"><div id="exitLess" ontouchstart="return true;"><img src="../../../../img/menu/pr.png" /></div></a>
            <a href="8.html"><div id="aaLess" ontouchstart="return true;"><img src="../../../../img/menu/ne.png" /></div></a>
        </div>

    </div>

    <script type="text/javascript" src="../../../../cordova.js"></script>
    <script type="text/javascript" src="../../../../js/global.js"></script>
    <script type="text/javascript">
        changeColor();
        if (localStorage.getItem("fSize") < 1) { fSize = 16; localStorage.setItem("fSize", 16); } else { fSize = localStorage.getItem("fSize"); }
        document.getElementById("pageBody").style.fontSize = fSize + "px";

        // goBackMenu
        document.addEventListener("backbutton", goBackMenu, false);
        function goBackMenu()
        {
            window.location.href = 'list.html';
        }

        function changeColor()
        {
            if (localStorage.getItem("colorSheme") <= 1)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#f0f0f0");
            }

            if (localStorage.getItem("colorSheme") == 2)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#212121");
                document.getElementById("pageBody").style.color = localStorage.getItem("#efefef");
            }

            if (localStorage.getItem("colorSheme") == 3)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#efe4d0");
            }
        }

        // bm
        if (localStorage.getItem("arrs") != null)
        {
            var arrs = JSON.parse(localStorage.getItem("arrs"));
        }
        else
        {
            var arrs = [];
        }

        var names = ["../acharter/ru/ruby/ruby/7.html", "Eщё немного о методах", "bm1379"];

        function setzBm() { arrs.push(names); localStorage.setItem("arrs", JSON.stringify(arrs)); localStorage.setItem("bm1379", 1); RefBms(); }

        window.onload = function() { RefBms(); }

        function RefBms()
        {
            if (localStorage.getItem("bm1379") == 1) { document.getElementById("bma1379").style.display = "block"; document.getElementById("bm1379").style.display = "none"; } else { document.getElementById("bma1379").style.display = "none"; document.getElementById("bm1379").style.display = "block"; }
        }

        function dellBm() { for (var i = 0; i < arrs.length; i++) { if (arrs[i].indexOf("Eщё немного о методах") == 1) { arrs.splice(i, 1); localStorage.setItem("bm1379", 0); RefBms(); localStorage.setItem("arrs", JSON.stringify(arrs)); } } }

        // sub menu
        var serTimeToClose = 1000;
        
        function OpenSettMenu()
        {
            document.getElementById("subMenuInLess").style.display = "block";
            timeToEvAct();
            serTimeToClose = 1;
        }
        
        function timeToEvAct()
        {
            setTimeout(function() { serTimeToClose = 0 }, 100);
        }
        
        window.addEventListener('click', function(e){
        
            if (serTimeToClose <= 0)
            {
                if (document.getElementById('subMenuInLess').contains(e.target))
                {
                    //
                }
                else
                {
                    document.getElementById("subMenuInLess").style.display = "none";
                }
            }
        });

    </script>

</body>
</html>
