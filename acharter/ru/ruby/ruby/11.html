
<!DOCTYPE html>

<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <link rel="stylesheet" type="text/css" href="../../../../css/read.css" />
    <title>Coder Book menu</title>
    <script type="text/javascript" src="../../../../higtline/scripts/shCore.js"></script>
    <script type="text/javascript" src="../../../../higtline/scripts/shBrushCSharp.js"></script>
    <link type="text/css" rel="stylesheet" href="../../../../higtline/styles/shCoreDefault.css"/>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <script src="../../../../js/Hyphenator.js" type="text/javascript"></script>
</head>

<body id="pageBody" class="hyphenate">

<!-- progress bar -->
<script src="../../../../js/progressBar.js" type="text/javascript"></script>
<div class="Reading-progress" id="progressBarType1"><span id="Progress-bar-top" class="bar-top" style="display: block !important;"></span></div>
<div class="Reading-progress" id="progressBarType2"><span id="Progress-bar-bottom" class="bar-bottom"></span></div>
<div class="Reading-progress" id="progressBarType3"><span id="Progress-bar-left" class="bar-left"></span></div>
<div class="Reading-progress" id="progressBarType4"><span id="Progress-bar-right" class="bar-right"></span></div>
<!-- progress bar -->


    <div id="lesonPage">

        <div id="lessMenu">
           <a id="exitLess" href="list.html" ontouchstart="return true;"><img src="../../../../img/menu/ex.png" /></a>
           <div id="aaLess" ontouchstart="return true;" onclick="OpenSettMenu();"><img src="../../../../img/menu/aa.png" /></div>
           <div id="subMenuInLess" style="display: none;">
                <a href="../../../../menu/setfontsize-ru.html" ontouchstart="return true;" id="pastMenuInLess">Размер текста</a>
                <a href="../../../../menu/setcolor-ru.html" ontouchstart="return true;" id="pastMenuInLess">Цветовая темы</a>
                <a href="../../../../menu/setProgressBar-ru.html" ontouchstart="return true;" id="pastMenuInLess" style="border: none;">Прогресс бар</a>
           </div>
           <div id="aaLess" ontouchstart="return true;">
            <div class="bmEdit" onclick="dellBm();" id="bma1383" ontouchstart="return true;" style="display: none;"><img src="../../../../img/menu/bmlessa.png" /></div>
            <div class="bmEdit" onclick="setzBm();" id="bm1383" ontouchstart="return true;" style="display: block;"><img src="../../../../img/menu/bmless.png" /></div>
           </div>
        </div>

        <hr />

    <!-- ПОЧАТОК -->
    
    <h1 id="title">
        Классы в Ruby
    </h1>
    
    <p>До сих пор мы видели несколько различных видов, или классов, объектов: строки, целые числа, дробные числа, массивы, а также несколько особых объектов (true, false и nil), о которых мы поговорим позже.</p>
    <p>В Ruby эти классы всегда записываются с заглавной буквы: String, Integer, Float, Array... и т. д.</p>
    <p>В общем случае, если мы хотим создать новый объект определённого класса, мы используем  new:</p>

    <pre class="brush: csharp;">
    a = Array.new  + [12345]  #  Сложение массивов.
    b = String.new + 'hello'  #  Сложение строк.
    c = Time.new

    puts 'a = '+a.to_s
    puts 'b = '+b.to_s
    puts 'c = '+c.to_s
    </pre>

    <p>Результат:</p>

    <pre class="brush: csharp;">
    a = 12345
    b = hello
    c = Wed Jun 28 02:11:24 GMT 2006
    </pre>

    <p>Так как мы можем создавать массивы и строки с помощью [...] и '...' соответственно, мы редко создаём их с помощью new.</p>
    <p>Хотя это и не совсем очевидно из предыдущего примера, <b>String.new</b> создаёт пустую строку, а <b>Array.new</b> создаёт пустой массив.</p>
    <p>Кроме того, числа являются особыми исключениями: вы не можете создать целое число с помощью <b>Integer.new</b>.</p>
    <p>Вам придётся просто записать число.</p>

    <h2 id="title">
        Класс Time
    </h2>

    <p>И что же особенного в этом классе Time?</p>
    <p>Объекты класса Time представляют моменты времени.</p>
    <p>Вы можете прибавлять числа к (или вычитать из) объектов времени, чтобы получить новые моменты времени: прибавление 1.5 к моменту времени создаст новый момент, который на полторы секунды позже первого:</p>

    <pre class="brush: csharp;">
    time  = Time.new   #  Момент, когда вы получили эту web-страницу.
    time2 = time + 60  #  Одной минутой позже.

    puts time
    puts time2
    </pre>

    <p>Результат:</p>

    <pre class="brush: csharp;">
    Wed Jun 28 02:11:24 GMT 2006
    Wed Jun 28 02:12:24 GMT 2006
    </pre>

    <p>Вы также можете создавать объект времени, соответствующий определённому моменту, используя <b>Time.mktime</b>:</p>

    <pre class="brush: csharp;">
    puts Time.mktime(2000, 1, 1)          #  Двухтысячный год (Y2K).
    puts Time.mktime(1976, 8, 3, 10, 11)  #  Когда я родился.
    </pre>

    <p>Результат:</p>

    <pre class="brush: csharp;">
    Sat Jan 01 00:00:00 GMT 2000
    Tue Aug 03 10:11:00 GMT 1976
    </pre>

    <p><b>Обратите внимание:</b> момент моего рождения задан по Тихоокеанскому летнему времени (Pacific Daylight Savings Time, PDT).</p>
    <p>Хотя, когда наступил 2000-й год, было Тихоокеанское стандартное время (Pacific Standard Time, PST), по крайней мере для нас, жителей Западного берега.</p>
    <p>Скобки здесь нужны, чтобы сгруппировать параметры метода mktime.</p>
    <p>Чем больше параметров вы указываете, тем более точным становится ваше время.</p>
    <p>Вы можете сравнивать время с помощью методов сравнения (более раннее время меньше, чем более позднее время), а если вы вычтете одно время из другого, вы получите разницу между ними в секундах.</p>
    <p>Поиграйте с этим немного!</p>

    <h2 id="title">
        Класс Hash
    </h2>

    <p>Другой полезный класс — это класс Hash.</p>
    <p>Хэши во многом похожи на массивы: в них имеется набор слотов, которые могут указывать на различные объекты.</p>
    <p>Однако в массиве слоты выстроены в ряд, и каждый из них пронумерован (начиная с нуля).</p>
    <p>В хэше слоты не располагаются подряд (они просто как-то беспорядочно свалены вместе), и вы можете использовать для обращения к слоту любой объект, а не только число.</p>
    <p>Использовать хэши хорошо тогда, когда у вас есть набор каких-нибудь вещей, которые вы хотите обрабатывать, но они совсем не укладываются в нумерованный список.</p>
    <p>Например, цвета, которые я использую для различных частей кода, положенного в основу этого учебника:</p>

    <pre class="brush: csharp;">
    colorArray = []  #  то же, что Array.new
    colorHash  = {}  #  то же, что Hash.new

    colorArray[0]       = 'красный'
    colorArray[1]       = 'зелёный'
    colorArray[2]       = 'синий'
    colorHash['строки']         = 'красный'
    colorHash['числа']          = 'зелёный'
    colorHash['ключевые слова'] = 'синий'

    colorArray.each do |color|
      puts color
    end
    colorHash.each do |codeType, color|
      puts codeType + ':  ' + color
    end
    </pre>

    <p>Результат:</p>

    <pre class="brush: csharp;">
    красный
    зелёный
    синий
    строки:  красный
    ключевые слова:  синий
    числа:  зелёный
    </pre>

    <p>Если я использую массив, мне нужно помнить, что слот 0 предназначен для строк, слот 1 — для чисел и т. д.</p>
    <p>Но если я использую хэш, то всё просто!</p>
    <p>Слот 'строки', конечно, содержит цвет строк.</p>
    <p>Ничего не нужно запоминать.</p>
    <p>Вы, должно быть, заметили, что когда мы применяли each, объекты из хэша выдавались не в том порядке, в котором мы их в него помещали.</p>
    <p>По крайней мере, так было, когда я это писал.</p>
    <p>Возможно, сейчас будет по-другому...</p>
    <p>С этими хэшами никогда ничего не знаешь наперёд.</p>
    <p>Для содержания чего-то в определённом порядке предназначены массивы, а не хэши.</p>
    <p>Хотя для именования слотов в хэше обычно используются строки, вы могли бы использовать объект любого типа, даже массивы и другие хэши (хотя не могу представить себе, зачем бы вам захотелось это делать...):</p>

    <pre class="brush: csharp;">
    weirdHash = Hash.new

    weirdHash[12] = 'обезьян'
    weirdHash[[]] = 'пустота'
    weirdHash[Time.new] = 'текущее время и никакое другое'
    </pre>

    <p>Хэши и массивы хороши для разных применений; вам решать, что из них лучше всего подходит для конкретной задачи.</p>
    
    <h2 id="title">
        Расширение классов
    </h2>

    <p>В конце предыдущей главы вы написали метод, выдающий английскую фразу для заданного целого числа.</p>
    <p>Однако, это не был метод целых чисел; это был просто метод "программы вообще".</p>
    <p>Но разве не было бы прекрасно, если вы могли бы написать что-то вроде <b>22.to_eng</b> вместо englishNumber 22?</p>
    <p>Вот как вы бы это сделали:</p>

    <pre class="brush: csharp;">
    class Integer
      
      def to_eng
        if self == 5
          english = 'five'
        else
          english = 'fifty-eight'
        end
        
        english
      end
    
    end
    
    #  Хорошо бы протестировать его на паре чисел...
    puts 5.to_eng
    puts 58.to_eng
    </pre>

    <p>Результат:</p>
    
    <pre class="brush: csharp;">
    five
    fifty-eight
    </pre>

    <p>Ну вот, я его протестировал; кажется, он работает. ;)</p>
    <p>Вот так мы определили метод для целых чисел: "заскочили" в класс Integer, описали там метод и "выскочили" из него обратно.</p>
    <p>Теперь у всех целых чисел есть этот (хотя и немного недоделанный) метод.</p>
    <p>Фактически, если вам не нравится, как работает какой-нибудь встроенный метод, например to_s, вы могли бы просто переопределить его примерно таким же образом... но я не советую это делать!</p>
    <p>Лучше всего оставить старые методы в покое и создавать новые, когда вам хочется сделать что-нибудь новенькое.</p>
    <p>Ну что... всё ещё непонятно?</p>
    <p>Давайте, я ещё раз пройдусь по последней программе.</p>
    <p>До сих пор, когда мы выполняли какой-нибудь код или определяли какие-то методы, мы делали это в объекте по умолчанию под названием "программа".</p>
    <p>В нашей последней программе мы впервые покинули этот объект и проникли в класс Integer.</p>
    <p>Мы определили в нём метод (поэтому он стал методом для целых чисел), и все целые числа могут его использовать.</p>
    <p>Внутри этого метода мы использовали self, чтобы ссылаться на объект (целое число), использующий этот метод.</p>
    
    <h2 id="title">
        Создание классов
    </h2>

    <p>Мы уже видели достаточно много объектов различных классов.</p>
    <p>Однако, легко предоставить себе такие объекты, которых в Ruby нет.</p>
    <p>К счастью, создать новый класс так же просто, как расширить существующий.</p>
    <p>Скажем, мы бы хотели сделать на Ruby игральные кости.</p>
    <p>Вот как мы могли бы создать класс Die:</p>

    <pre class="brush: csharp;">
    class Die  #  игральная кость   
      def roll
        1 + rand(6)
      end
      
    end
    
    #  Давайте создадим пару игральных костей...
    dice = [Die.new, Die.new]
    
    #  ...и бросим их.
    dice.each do |die|
      puts die.roll
    end
    </pre>

    <p>Результат:</p>
    
    <pre class="brush: csharp;">
    5
    6
    </pre>

    <p>Если вы пропустили раздел о случайных числах: rand(6) просто возвращает случайное число между 0 и 5.</p>
    <p>Вот так!</p>
    <p>Наши собственноручно созданные объекты.</p>
    <p>Бросьте кости несколько раз (нажимая на кнопку "Обновить") и понаблюдайте, что при этом появится.</p>
    <p>Мы можем определить для наших объектов самые разные методы... но здесь чего-то явно не хватает.</p>
    <p>Работа с этими объектами сильно напоминает программирование до того, как мы узнали о переменных.</p>
    <p>Взгляните на наши кости, например.</p>
    <p>Мы можем бросать их, и каждый раз при этом они выдают нам другое число.</p>
    <p>Но если мы хотели бы задержаться на этом числе, нам бы пришлось создать переменную, указывающую на это число.</p>
    <p>Кажется, любая порядочная игральная кость должна иметь возможность хранить число, а бросание кости должно изменять это число.</p>
    <p>Если мы уже отслеживаем состояние самой кости, то нам уже не нужно отслеживать где-то ещё число, которое она показывает.</p>
    <p>Однако, если мы попытаемся сохранить полученное число в (локальной) переменной метода roll, оно исчезнет, как только закончится roll.</p>
    <p>Нам нужно хранить число в переменной другого типа.</p>
    
    <h2 id="title">
        Переменные экземпляра
    </h2>

    <p>Обычно, когда мы хотим что-то сказать о строке, мы просто называем её строкой.</p>
    <p>Однако, мы могли также назвать её строковым объектом.</p>
    <p>Некоторые программисты могли бы назвать её экземпляром класса String, но это просто причудливый и длинный (так что можно запыхаться) способ сказать: "строка".</p>
    <p>Экземпляр класса — это просто объект этого класса.</p>
    <p>Так что переменные экземпляра — это просто переменные объекта.</p>
    <p>Локальные переменные метода действуют до завершения метода.</p>
    <p>С другой стороны, переменные экземпляра каждого объекта будут действительны, пока существует объект.</p>
    <p>Чтобы отличить переменные экземпляра от локальных переменных, перед их именами ставится символ @:</p>

    <pre class="brush: csharp;">
    class Die  #  игральная кость
      def roll
        @numberShowing = 1 + rand(6)
      end
      
      def showing
        @numberShowing
      end
      
    end
    
    die = Die.new
    die.roll
    puts die.showing
    puts die.showing
    die.roll
    puts die.showing
    puts die.showing
    </pre>

    <p>Результат:</p>
    
    <pre class="brush: csharp;">
    6
    6
    3
    3
    </pre>

    <p>Очень хорошо!</p>
    <p>Так, метод roll бросает кость, а showing сообщает нам, какое число выпало.</p>
    <p>Однако, что же будет, если мы попытаемся посмотреть, что выпало прежде, чем мы бросили кость (прежде, чем мы задали значение @numberShowing)?</p>

    <pre class="brush: csharp;">
    class Die  #  игральная кость
      def roll
        @numberShowing = 1 + rand(6)
      end
      
      def showing
        @numberShowing
      end
      
    end
    
    #  Поскольку я не собираюсь снова использовать эту кость,
    #  мне не нужно сохранять её в переменной.
    puts Die.new.showing
    </pre>

    <p>Результат:</p>

    <pre class="brush: csharp;">
    nil
    </pre>

    <p>Хммм... ладно, по крайней мере, она не выдала нам ошибку.</p>
    <p>Однако, в самом деле нет никакого смысла в том, что кость "не была брошена", или что бы там ни означало значение nil в этом случае.</p>
    <p>Было бы хорошо, если бы мы могли задать значение для нашего нового объекта "кость" сразу после того, как он был создан.</p>
    <p>Вот зачем нужен метод initialize:</p>
    
    <pre class="brush: csharp;">
    class Die  #  игральная кость  
      def initialize
        #  я просто брошу эту кость, хотя мы
        #  могли бы сделать что-нибудь ещё, если бы хотели,
        #  например, задать, что выпало число 6.
        roll
      end
      
      def roll
        @numberShowing = 1 + rand(6)
      end
      
      def showing
        @numberShowing
      end
      
    end
    
    puts Die.new.showing
    </pre>

    <p>Результат:</p>
    
    <pre class="brush: csharp;">
    2
    </pre>

    <p>Когда объект создаётся, всегда вызывается его метод initialize (если он у него определён).</p>
    <p>Наши игральные кости теперь почти безупречны.</p>
    <p>Может быть, единственное, чего не хватает, так это способа задать, какой стороной выпала кость...</p>
    <p>Почему бы вам не написать метод cheat, который как раз это и делает!</p>
    <p>Вернётесь к чтению, когда закончите его (и, конечно, когда проверите, что он работает).</p>
    <p>Убедитесь, что невозможно задать, чтобы на кости выпало 7!</p>
    <p>Итак, мы только что прошли весьма крутой материал.</p>
    <p>Однако же, он довольно сложный, поэтому позвольте мне дать вам другой, более интересный пример.</p>
    <p>Ну, скажем, мы хотим сделать простое виртуальное домашнее животное — дракончика.</p>
    <p>Как большинство детей, он должен быть способен есть, спать и "гулять", что означает, что нам нужно будет иметь возможность кормить его, укладывать спать и выгуливать.</p>
    <p>Внутри себя нашему дракону понадобится отслеживать, когда он голоден, устал или ему нужно на прогулку; но у нас не будет возможности узнать это, когда мы будем общаться с нашим драконом: точно так же вы не можете спросить человеческого младенца: "Ты хочешь есть?".</p>
    <p>Мы также предусмотрим несколько других забавных способов для общения с нашим дракончиком, а когда он родится, мы дадим ему имя.</p>
    <p>Что бы вы ни передали в метод new, для вашего удобства будет передано в метод initialize.</p>
    <p>Ладно, давайте попробуем:</p>

    <pre class="brush: csharp;">
    class Dragon
      
      def initialize name
        @name = name
        @asleep = false
        @stuffInBelly     = 10  #  Он сыт.
        @stuffInIntestine =  0  #  Ему не надо гулять.
        
        puts @name + ' родился.'
      end
      
      def feed
        puts 'Вы кормите ' + @name + '(а).'
        @stuffInBelly = 10
        passageOfTime
      end
      
      def walk
        puts 'Вы выгуливаете ' + @name + '(а).'
        @stuffInIntestine = 0
        passageOfTime
      end
      
      def putToBed
        puts 'Вы укладываете ' + @name + '(а) спать.'
        @asleep = true
        3.times do
          if @asleep
            passageOfTime
          end
          if @asleep
            puts @name + ' храпит, наполняя комнату дымом.'
          end
        end
        if @asleep
          @asleep = false
          puts @name + ' медленно просыпается.'
        end
      end
      
      def toss
        puts 'Вы подбрасываете ' + @name + '(а) в воздух.'
        puts 'Он хихикает, обжигая при этом вам брови.'
        passageOfTime
      end
      
      def rock
        puts 'Вы нежно укачиваете ' + @name + '(а).'
        @asleep = true
        puts 'Он быстро задрёмывает...'
        passageOfTime
        if @asleep
          @asleep = false
          puts '...но просыпается, как только вы перестали качать.'
        end
      end
      
      private
      
      #  "private" означает, что определённые здесь методы являются
      #  внутренними методами этого объекта.  (Вы можете кормить
      #  вашего дракона, но не можете спросить его, голоден ли он.)
      
      def hungry?  #  голоден?
        #  Имена методов могут заканчиваться знаком "?".
        #  Как правило, мы называем так только, если метод
        #  возвращает true или false, как здесь:
        @stuffInBelly <= 2
      end
      
      def poopy?  #  кишечник полон?
        @stuffInIntestine >= 8
      end
      
      def passageOfTime # проходит некоторое время
        if @stuffInBelly > 0
          #  Переместить пищу из желудка в кишечник.
          @stuffInBelly     = @stuffInBelly     - 1
          @stuffInIntestine = @stuffInIntestine + 1
        else  #  Наш дракон страдает от голода!
          if @asleep
            @asleep = false
            puts 'Он внезапно просыпается!'
          end
          puts @name + ' проголодался! Доведённый до крайности, он съедает ВАС!'
          exit  #  Этим методом выходим из программы.
        end
        
        if @stuffInIntestine >= 10
          @stuffInIntestine = 0
          puts 'Опаньки!  ' + @name + ' сделал нехорошо...'
        end
        
        if hungry?
          if @asleep
            @asleep = false
            puts 'Он внезапно просыпается!'
          end
          puts 'В желудке у ' + @name + '(а) урчит...'
        end
        
        if poopy?
          if @asleep
            @asleep = false
            puts 'Он внезапно просыпается!'
          end
          puts @name + ' подпрыгивает, потому что хочет на горшок...'
        end
      end
      
    end
    
    pet = Dragon.new 'Норберт'
    pet.feed
    pet.toss
    pet.walk
    pet.putToBed
    pet.rock
    pet.putToBed
    pet.putToBed
    pet.putToBed
    pet.putToBed
    </pre>

    <p>Результат:</p>
    
    <pre class="brush: csharp;">
    Норберт родился.
    Вы кормите Норберт(а).
    Вы подбрасываете Норберт(а) в воздух.
    Он хихикает, обжигая при этом вам брови.
    Вы выгуливаете Норберт(а).
    Вы укладываете Норберт(а) спать.
    Норберт храпит, наполняя комнату дымом.
    Норберт храпит, наполняя комнату дымом.
    Норберт храпит, наполняя комнату дымом.
    Норберт медленно просыпается.
    Вы нежно укачиваете Норберт(а).
    Он быстро задрёмывает...
    ...но просыпается, как только вы перестали качать.
    Вы укладываете Норберт(а) спать.
    Он внезапно просыпается!
    В желудке у Норберт(а) урчит...
    Вы укладываете Норберт(а) спать.
    Он внезапно просыпается!
    В желудке у Норберт(а) урчит...
    Вы укладываете Норберт(а) спать.
    Он внезапно просыпается!
    В желудке у Норберт(а) урчит...
    Норберт подпрыгивает, потому что хочет на горшок...
    Вы укладываете Норберт(а) спать.
    Он внезапно просыпается!
    Норберт проголодался! Доведённый до крайности, он съедает ВАС!
    </pre>

    <p>Вот тебе и раз!</p>
    <p>Конечно, было бы лучше, если бы это была интерактивная программа, но эти изменения вы можете сделать попозже.</p>
    <p>Я просто попытался показать те части программы, которые непосредственно относятся к созданию нового класса Dragon.</p>
    <p>В этом примере мы увидели несколько новых конструкций.</p>
    <p>Первая достаточно проста: exit заканчивает программу "здесь и сейчас".</p>
    <p>Вторая — это ключевое слово private, которое мы вставили прямо в середину описания нашего класса.</p>
    <p>Я мог бы обойтись без него, но я хотел подчеркнуть мысль о том, что одни методы — это то, что вы можете делать с драконом, а другие — то, что просто происходит внутри дракона.</p>
    <p>Вы можете считать, что эти методы скрыты "под капотом": если вы не работаете автомехаником, всё, что на самом деле вам нужно знать, это педаль газа, педаль тормоза и рулевое колесо.</p>
    <p>Программист назвал бы их открытым интерфейсом вашей машины.</p>
    <p>Однако то, каким образом ваша аварийная подушка знает, когда наполниться воздухом, является внутренним поведением машины; обычному пользователю (водителю) не нужно знать об этом.</p>
    <p>А сейчас в качестве более конкретного примера, иллюстрирующего эти строки, давайте поговорим о том, как вы могли бы представить автомобиль в видео-игре (чем я как раз, по случайному совпадению, и занимаюсь).</p>
    <p>Во-первых, вы захотели бы решить, каким должен выглядеть ваш внешний интерфейс; другими словами, какие методы смогут вызывать пользователи у ваших объектов-автомобилей?</p>
    <p>Ну, им понадобится нажимать на педаль газа и педаль тормоза, но им также понадобится указывать, с какой силой они нажимают на педаль.</p>
    <p>Есть большая разница между "вдавить в пол" и "дотронуться".</p>
    <p>Им также понадобится управлять, и снова потребуется возможность сказать, насколько сильно они поворачивают руль.</p>
    <p>Я полагаю, вы могли бы продолжить и добавить сцепление, сигналы поворота, реактивную установку, форсаж, конденсатор временного потока и так далее...</p>
    <p>Это зависит от того, какую разновидность игры вы делаете.</p>
    <p>Однако, нужно, чтобы внутри объекта-автомобиля происходило много чего другого; автомобилю нужны будут такие вещи, как скорость, направление и положение (и это только самые основные).</p>
    <p>Эти атрибуты могут изменяться нажатием на педали газа и тормоза и, конечно, поворачиванием руля, но пользователь не должен иметь возможности непосредственно устанавливать положение (что было бы подобно сверхсветовому перемещению).</p>
    <p>Вы, должно быть, также пожелаете отслеживать боковые заносы и повреждения, отрыв всех колёс от земли и так далее.</p>
    <p>Всё это будет внутренностями вашего автомобильного объекта.</p>
    <p>Вот почти что и всё, что можно сказать об этом!</p>
    <p>Нет, подождите секундочку...</p>
    <p>Я же не рассказал вам обо всех этих классах, которые выполняют самые разнообразные вещи: отправляют электронную почту, сохраняют и загружают файлы на ваш компьютер, или же создают окна и кнопки (и даже 3-хмерные миры) и всё прочее!</p>
    <p>Что ж, попросту имеется настолько много классов, которые вы можете использовать, что мне никак невозможно показать вам их все; я даже не знаю, что большинство из них из себя представляют!</p>
    <p>А что я могу сказать вам о них, так это то, где можно разузнать о них поподробнее, чтобы вы смогли изучить те из них, которые вы захотите применить в ваших программах.</p>
    <p>Однако, прежде, чем вы отправитесь на самостоятельное изучение, вам ещё следует узнать о других важных особенностях Ruby, которых нет в большинстве других языков, но без которых я просто не смог бы жить: о блоках и процедурных объектах.</p>

    <script src="../../../../js/progressBarSetIni.js" type="text/javascript"></script>

        <div id="lessMenu" style="margin: 30px 0 0 0;">
            <hr />
            <a href="10.html"><div id="exitLess" ontouchstart="return true;"><img src="../../../../img/menu/pr.png" /></div></a>
            <a href="12.html"><div id="aaLess" ontouchstart="return true;"><img src="../../../../img/menu/ne.png" /></div></a>
        </div>

    </div>

    <script type="text/javascript" src="../../../../cordova.js"></script>
    <script type="text/javascript" src="../../../../js/global.js"></script>
    <script type="text/javascript">
        changeColor();
        if (localStorage.getItem("fSize") < 1) { fSize = 16; localStorage.setItem("fSize", 16); } else { fSize = localStorage.getItem("fSize"); }
        document.getElementById("pageBody").style.fontSize = fSize + "px";

        // goBackMenu
        document.addEventListener("backbutton", goBackMenu, false);
        function goBackMenu()
        {
            window.location.href = 'list.html';
        }

        function changeColor()
        {
            if (localStorage.getItem("colorSheme") <= 1)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#f0f0f0");
            }

            if (localStorage.getItem("colorSheme") == 2)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#212121");
                document.getElementById("pageBody").style.color = localStorage.getItem("#efefef");
            }

            if (localStorage.getItem("colorSheme") == 3)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#efe4d0");
            }
        }

        // bm
        if (localStorage.getItem("arrs") != null)
        {
            var arrs = JSON.parse(localStorage.getItem("arrs"));
        }
        else
        {
            var arrs = [];
        }

        var names = ["../acharter/ru/ruby/ruby/11.html", "Классы в Ruby", "bm1383"];

        function setzBm() { arrs.push(names); localStorage.setItem("arrs", JSON.stringify(arrs)); localStorage.setItem("bm1383", 1); RefBms(); }

        window.onload = function() { RefBms(); }

        function RefBms()
        {
            if (localStorage.getItem("bm1383") == 1) { document.getElementById("bma1383").style.display = "block"; document.getElementById("bm1383").style.display = "none"; } else { document.getElementById("bma1383").style.display = "none"; document.getElementById("bm1383").style.display = "block"; }
        }

        function dellBm() { for (var i = 0; i < arrs.length; i++) { if (arrs[i].indexOf("Классы в Ruby") == 1) { arrs.splice(i, 1); localStorage.setItem("bm1383", 0); RefBms(); localStorage.setItem("arrs", JSON.stringify(arrs)); } } }

        // sub menu
        var serTimeToClose = 1000;
        
        function OpenSettMenu()
        {
            document.getElementById("subMenuInLess").style.display = "block";
            timeToEvAct();
            serTimeToClose = 1;
        }
        
        function timeToEvAct()
        {
            setTimeout(function() { serTimeToClose = 0 }, 100);
        }
        
        window.addEventListener('click', function(e){
        
            if (serTimeToClose <= 0)
            {
                if (document.getElementById('subMenuInLess').contains(e.target))
                {
                    //
                }
                else
                {
                    document.getElementById("subMenuInLess").style.display = "none";
                }
            }
        });

    </script>

</body>
</html>
