
<!DOCTYPE html>

<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <link rel="stylesheet" type="text/css" href="../../../../css/read.css" />
    <title>Coder Book menu</title>
    <script type="text/javascript" src="../../../../higtline/scripts/shCore.js"></script>
    <script type="text/javascript" src="../../../../higtline/scripts/shBrushCSharp.js"></script>
    <link type="text/css" rel="stylesheet" href="../../../../higtline/styles/shCoreDefault.css"/>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <script src="../../../../js/Hyphenator.js" type="text/javascript"></script>
</head>

<body id="pageBody" class="hyphenate">

<!-- progress bar -->
<script src="../../../../js/progressBar.js" type="text/javascript"></script>
<div class="Reading-progress" id="progressBarType1"><span id="Progress-bar-top" class="bar-top" style="display: block !important;"></span></div>
<div class="Reading-progress" id="progressBarType2"><span id="Progress-bar-bottom" class="bar-bottom"></span></div>
<div class="Reading-progress" id="progressBarType3"><span id="Progress-bar-left" class="bar-left"></span></div>
<div class="Reading-progress" id="progressBarType4"><span id="Progress-bar-right" class="bar-right"></span></div>
<!-- progress bar -->


    <div id="lesonPage">

        <div id="lessMenu">
           <a id="exitLess" href="list.html" ontouchstart="return true;"><img src="../../../../img/menu/ex.png" /></a>
           <div id="aaLess" ontouchstart="return true;" onclick="OpenSettMenu();"><img src="../../../../img/menu/aa.png" /></div>
           <div id="subMenuInLess" style="display: none;">
                <a href="../../../../menu/setfontsize-ru.html" ontouchstart="return true;" id="pastMenuInLess">Размер текста</a>
                <a href="../../../../menu/setcolor-ru.html" ontouchstart="return true;" id="pastMenuInLess">Цветовая темы</a>
                <a href="../../../../menu/setProgressBar-ru.html" ontouchstart="return true;" id="pastMenuInLess" style="border: none;">Прогресс бар</a>
           </div>
           <div id="aaLess" ontouchstart="return true;">
            <div class="bmEdit" onclick="dellBm();" id="bma1384" ontouchstart="return true;" style="display: none;"><img src="../../../../img/menu/bmlessa.png" /></div>
            <div class="bmEdit" onclick="setzBm();" id="bm1384" ontouchstart="return true;" style="display: block;"><img src="../../../../img/menu/bmless.png" /></div>
           </div>
        </div>

        <hr />

    <!-- ПОЧАТОК -->
    
    <h1 id="title">
        Блоки и процедурные объекты
    </h1>
    
    <p>Это определённо одна из самых крутых возможностей Ruby.</p>
    <p>В некоторых других языках тоже есть такие возможности, хотя они могут называться как-нибудь по-другому (например, замыкания), но в большинстве даже более популярных языков, к их стыду, они отсутствуют.</p>
    <p>Так что же это за новая крутая возможность?</p>
    <p>Это способность принимать блок кода (то есть код между do и end), обёртывать его в объект (называемый процедурным объектом или proc по-английски), сохранять его в переменной или передавать его в метод, а затем исполнять код этого блока, когда бы вы ни пожелали (более одного раза, если хотите).</p>
    <p>Таким образом, блок напоминает настоящий метод за исключением того, что он не привязан ни к какому объекту (он сам является объектом), и вы можете сохранять его или передавать его как параметр подобно тому, как вы это делаете с любым другим объектом.</p>
    <p>Думаю, настало время привести пример:</p>

    <pre class="brush: csharp;">
    toast = Proc.new do
      puts 'Ваше здоровье!'
    end
    
    toast.call
    toast.call
    toast.call
    </pre>

    <p>Результат:</p>
    
    <pre class="brush: csharp;">
    Ваше здоровье!
    Ваше здоровье!
    Ваше здоровье!
    </pre>

    <p>Итак, я создал объект proc (это название, полагаю, означает сокращение от "procedure", т. е. "процедура", но гораздо более важно, что оно рифмуется с "block"), который содержит блок кода, затем я с помощью call вызвал proc-объект три раза.</p>
    <p>Как видите, это очень напоминает метод.</p>
    <p>На самом деле, это даже более походит на метод, чем в показанном мной примере, так как блоки могут принимать параметры:</p>

    <pre class="brush: csharp;">
    doYouLike = Proc.new do |aGoodThing|
      puts 'Я *действительно* люблю '+aGoodThing+'!'
    end
    
    doYouLike.call 'шоколад'
    doYouLike.call 'рубин'
    </pre>

    <p>Результат:</p>
    
    <pre class="brush: csharp;">
    Я *действительно* люблю шоколад!
    Я *действительно* люблю рубин!
    </pre>

    <p>Хорошо, вот мы узнали, что из себя представляют блоки и proc-и, и как их можно использовать, но в чём же здесь дело?</p>
    <p>Почему бы просто не использовать методы?</p>
    <p>Ну потому, что некоторые вещи вы просто не сможете сделать с помощью методов.</p>
    <p>В частности, вы не можете передавать методы в другие методы (но вы можете передавать в методы процедурные объекты), и методы не могут возвращать другие методы (но они могут возвращать proc-объекты).</p>
    <p>Это возможно просто потому, что proc-и являются объектами, а методы — нет.</p>
    <p>Между прочим, вам это не кажется знакомым?</p>
    <p>Вот-вот, вы уже видели блоки раньше... когда вы изучали итераторы.</p>
    <p>Но давайте поговорим об этом ещё чуточку попозже.</p>

    <h2 id="title">
        Методы, принимающие процедурные объекты
    </h2>
    
    <p>Когда мы передаём процедурный объект в метод, мы можем управлять тем, как, в каком случае или сколько раз мы вызываем proc-объект.</p>
    <p>Например, имеется, скажем, нечто, что мы хотим сделать перед и после выполнения некоторого кода:</p>

    <pre class="brush: csharp;">
    def doSelfImportantly someProc
      puts 'Всем немедленно ЗАМЕРЕТЬ!  Мне нужно кое-что сделать...'
      someProc.call
      puts 'Внимание всем, я закончил.  Продолжайте выполнять свои дела.'
    end
    
    sayHello = Proc.new do
      puts 'привет'
    end
    
    sayGoodbye = Proc.new do
      puts 'пока'
    end
    
    doSelfImportantly sayHello
    doSelfImportantly sayGoodbye
    </pre>

    <p>Результат:</p>
    
    <pre class="brush: csharp;">
    Всем немедленно ЗАМЕРЕТЬ!  Мне нужно кое-что сделать...
    привет
    Внимание всем, я закончил.  Продолжайте выполнять свои дела.
    Всем немедленно ЗАМЕРЕТЬ!  Мне нужно кое-что сделать...
    пока
    Внимание всем, я закончил.  Продолжайте выполнять свои дела.
    </pre>

    <p>Возможно, это не выглядит так уж особенно потрясающим... но это так и есть. :-)</p>
    <p>В программировании слишком часто имеются строгие требования к тому, что должно быть сделано и когда.</p>
    <p>Если вы хотите, например, сохранить файл, вам нужно открыть файл, записать туда информацию, которую вы хотите в нём хранить, а затем закрыть файл.</p>
    <p>Если вы позабудете закрыть файл, могут случиться "Плохие Вещи"TM.</p>
    <p>Но каждый раз, когда вы хотите сохранить или загрузить файл, вам требуется делать одно и то же: открывать файл, выполнять то, что вы действительно желаете сделать, затем закрывать файл.</p>
    <p>Это утомительно и легко забывается.</p>
    <p>В Ruby сохранение (или загрузка) файлов работает подобно приведённому выше коду, поэтому вам не нужно беспокоиться ни о чём, кроме того, что вы действительно хотите сохранить (или загрузить).</p>
    <p>В следующей главе я покажу вам, где разузнать, как делать такие вещи, как сохранение и загрузка файлов.</p>
    <p>Вы также можете написать методы, которые будут определять, сколько раз (или даже при каком условии) вызывать процедурный объект.</p>
    <p>Вот метод, который будет вызывать переданный ему proc-объект примерно в половине случаев, и ещё один метод, который будет вызывать его дважды:</p>

    <pre class="brush: csharp;">
    def maybeDo someProc  # Условный вызов
      if rand(2) == 0
        someProc.call
      end
    end
    
    def twiceDo someProc  # Двойной вызов
      someProc.call
      someProc.call
    end
    
    wink = Proc.new do
      puts '<подмигнуть>'
    end
    
    glance = Proc.new do
      puts '<взглянуть>'
    end
    
    maybeDo wink
    maybeDo glance
    twiceDo wink
    twiceDo glance
    </pre>

    <p>Результат:</p>
    
    <pre class="brush: csharp;">
    <подмигнуть>
    <подмигнуть>
    <взглянуть>
    <взглянуть>
    </pre>

    <p>Если вы перезагрузите эту страницу несколько раз, то вы увидите другие результаты.</p>
    <p>Это самые распространённые применения процедурных объектов, которые дают нам возможность делать такие вещи, которые мы просто не могли бы сделать, используя только методы.</p>
    <p>Конечно, вы могли бы написать метод, чтобы подмигнуть два раза, но вы не смогли бы написать метод, чтобы просто делать дважды что-нибудь!</p>
    <p>Прежде, чем мы продолжим, давайте посмотрим на последний пример.</p>
    <p>До сих пор все передаваемые  процедурные объекты были довольно похожи друг на друга.</p>
    <p>В этот раз они будут совсем другими, и вы увидите, насколько сильно подобный метод зависит от тех процедурных объектов, что были ему переданы.</p>
    <p>Наш метод примет обычный объект и процедурный объект, и вызовет процедурный объект с обычным объектом в качестве параметра.</p>
    <p>Если процедурный объект вернёт false, мы закончим выполнение, иначе мы вызовем процедурный объект с возвращённым объектом.</p>
    <p>Мы будем продолжать так делать, пока процедурный объект не вернёт false (что ему лучше сделать в конце концов, иначе программа "загнётся").</p>
    <p>Этот метод вернёт последнее значение, возвращённое процедурным объектом, не равное false.</p>

    <pre class="brush: csharp;">
    def doUntilFalse firstInput, someProc
      input  = firstInput
      output = firstInput
      
      while output
        input  = output
        output = someProc.call input
      end
      
      input
    end
    
    buildArrayOfSquares = Proc.new do |array| # Создание массива квадратов чисел 
      lastNumber = array.last 
      if lastNumber <= 0
        false
      else
        array.pop                        # Уберём последнее число...
        array.push lastNumber*lastNumber # ...и заменим его на его квадрат...
        array.push lastNumber-1          # ...за которым идет предыдущее число.
      end
    end
    
    alwaysFalse = Proc.new do |justIgnoreMe|
      false
    end
    
    puts doUntilFalse([5], buildArrayOfSquares).inspect
    puts doUntilFalse('Я пишу это в 3 часа утра; кто-то меня вырубил!', alwaysFalse)
    </pre>

    <p>Результат:</p>
    
    <pre class="brush: csharp;">
    [25, 16, 9, 4, 1, 0]
    </pre>

    <p>Я пишу это в 3 часа утра; кто-то меня вырубил!</p>
    <p>Хорошо, признаю, что это был довольно странный пример.</p>
    <p>Но он показывает, насколько по-разному ведёт себя наш метод, когда ему передают совсем разные процедурные объекты.</p>
    <p>Метод inspect во многом похож на to_s за исключением того, что возвращаемая им строка — это попытка показать код на Ruby для создания объекта, который вы ему передали.</p>
    <p>Здесь он показывает нам весь массив, возвращённый при нашем первом вызове метода <b>doUntilFalse</b>.</p>
    <p>Вы, должно быть, также заметили, что мы сами никогда не возводили в квадрат этот 0 в конце массива, но поскольку 0 в квадрате всегда равен 0, нам это и не нужно было делать.</p>
    <p>А так как alwaysFalse, как вы знаете, возвращает всегда false, метод doUntilFalse ничего не делал, когда мы вызвали его во второй раз; он просто вернул то, что ему было передано.</p>

    <h2 id="title">
        Методы, возвращающие процедурные объекты
    </h2>
    
    <p>Ещё одна из крутых возможностей, которые можно делать с процедурными объектами, это то, что их можно создавать в методах, а затем возвращать их.</p>
    <p>Это делает возможным разнообразные сумасшедшие, но мощные программистские штучки (с впечатляющими названиями наподобие ленивое вычисление, бесконечные структуры данных и карринг).</p>
    <p>Но дело в том, что я почти никогда не использовал это на практике, а также не припомню, чтобы видел, как кто-либо применял это в своём коде.</p>
    <p>Думаю, это не такого рода вещи, которые обычно нужно делать на Ruby, а, может быть, Ruby просто подталкивает вас находить другие решения — не знаю.</p>
    <p>В любом случае, я только кратко коснусь этого.</p>
    <p>В этом примере метод compose принимает два процедурных объекта и возвращает новый процедурный объект, который, будучи вызван, вызывает первый процедурный объект и передаёт его результат во второй.</p>

    <pre class="brush: csharp;">
    def compose proc1, proc2
      Proc.new do |x|
        proc2.call(proc1.call(x))
      end
    end
    
    squareIt = Proc.new do |x|
      x * x
    end
    
    doubleIt = Proc.new do |x|
      x + x
    end
    
    doubleThenSquare = compose doubleIt, squareIt
    squareThenDouble = compose squareIt, doubleIt
    
    puts doubleThenSquare.call(5)
    puts squareThenDouble.call(5)
    </pre>

    <p>Результат:</p>
    
    <pre class="brush: csharp;">
    100
    50
    </pre>

    <p>Обратите внимание, что вызов proc1 должен быть внутри скобок при вызове proc2, чтобы он был выполнен первым.</p>

    <h2 id="title">
        Передача блоков (не proc-объектов) в методы
    </h2>
    
    <p>Ну, хорошо, этот подход представляет чисто академический интерес, к тому же применять его несколько затруднительно.</p>
    <p>В основном трудность состоит в том, что здесь вам приходится выполнить три шага (определить метод, создать процедурный объект и вызвать метод с процедурным объектом); тогда как есть ощущение, что должно быть только два (определить метод и передать блок непосредственно в этот метод, совсем не используя процедурный объект), поскольку в большинстве случаев вы не хотите использовать процедурный объект / блок после того, как вы передали его в метод.</p>
    <p>Что ж, да будет вам известно, что в Ruby всё это уже сделано за нас!</p>
    <p>Фактически, вы уже делали это каждый раз, когда использовали итераторы.</p>
    <p>Сначала я быстро покажу вам пример, а затем мы обсудим его.</p>

    <pre class="brush: csharp;">
    class Array
      
      def eachEven(&wasABlock_nowAProc)
        isEven = true # Мы начинаем с "true", т.к. массив начинается с 0, а он чётный.
        
        self.each do |object|
          if isEven
            wasABlock_nowAProc.call object
          end
          
          isEven = (not isEven)  #  Переключиться с чётного на нечётное или наоборот.
        end
      end
    
    end
    
    ['яблоками', 'гнилыми яблоками', 'вишней', 'дурианом'].eachEven do |fruit|
      puts 'Мммм!  Я так люблю пирожки с '+fruit+', а вы?'
    end
    
    #  Помните, что мы берём элементы массива с чётными номерами,
    #  все из которых оказываются нечётными числами; это
    #  просто потому, что мне захотелось создать подобные трудности.
    [1, 2, 3, 4, 5].eachEven do |oddBall|
      puts oddBall.to_s+' - НЕ чётное число!'
    end
    </pre>

    <p>Результат:</p>
    
    <pre class="brush: csharp;">
    Мммм!  Я так люблю пирожи с яблоками, а вы?
    Мммм!  Я так люблю пирожи с вишней, а вы?
    1 - НЕ чётное число!
    3 - НЕ чётное число!
    5 - НЕ чётное число!
    </pre>

    <p>Итак, всё, что мы должны сделать, чтобы передать блок в метод eachEven, это "прилепить" блок после метода.</p>
    <p>Подобным же образом вы можете передать блок в любой метод, хотя многие методы просто проигнорируют блок.</p>
    <p>Чтобы заставить ваш метод не игнорировать блок, а взять его и превратить его в процедурный объект, нужно поместить имя процедурного объекта в конце списка параметров вашего метода и поставить перед ним амперсанд (&).</p>
    <p>Конечно, это немного мудрёно, но не слишком, и вам придётся сделать это только один раз (когда вы описываете метод).</p>
    <p>А затем вы  можете использовать этот метод снова и снова точно так же, как и встроенные методы, принимающие блоки такие, как each и times. (Помните, 5.times do...?)</p>
    <p>Если для вас это слишком запутанно, просто помните, что должен сделать eachEven: вызвать переданный ему блок для каждого чётного элемента в массиве.</p>
    <p>После того, как однажды вы написали метод и убедились, что он работает, вам уже не нужно думать о том, что в действительности делается "под капотом" ("какой блок и когда вызывается??").</p>
    <p>На самом деле, именно поэтому мы пишем подобные методы: чтобы нам никогда не приходилось снова думать о том, как они работают.</p>
    <p>Мы просто используем их.</p>
    <p>Помню, один раз я захотел сделать, чтобы можно было измерять, сколько времени выполняются различные секции программы.</p>
    <p>Это также известно как профилирование программного кода.</p>
    <p>И я написал метод, который засекает время перед исполнением кода, затем выполняет его, в конце снова засекает время и вычисляет разницу.</p>
    <p>Сейчас я не могу найти этот метод, но мне он и не нужен; он, возможно, выглядел примерно так:</p>

    <pre class="brush: csharp;">
    def profile descriptionOfBlock, &block  #  Описание блока и сам блок 
      startTime = Time.now
      
      block.call
      
      duration = Time.now - startTime
      
      puts descriptionOfBlock+':  '+duration.to_s+' сек.'
    end
    
    profile '25000 удваиваний' do
      number = 1
      
      25000.times do
        number = number + number
      end
      
      puts number.to_s.length.to_s+' цифр' # Да, это число цифр в таком ГИГАНТСКОМ числе.
    end
    
    profile 'сосчитать до миллиона' do
      number = 0
      
      1000000.times do
        number = number + 1
      end
    end
    </pre>

    <p>Результат:</p>
    
    <pre class="brush: csharp;">
    7526 цифр
    25000 удваиваний:  0.304966 сек.
    сосчитать до миллиона:  0.615216 сек.
    </pre>

    <p>Как просто!</p>
    <p>Как элегантно!</p>
    <p>Теперь с помощью этого крошечного метода я легко могу измерить время работы любой секции в любой программе, в какой только захочу: я просто закину код в блок и отправлю его методу profile.</p>
    <p>Что может быть проще?</p>
    <p>В большинстве языков мне понадобилось бы явно добавлять код для измерения времени (тот, что написан в profile) до и после каждой секции, которую я хотел бы захронометрировать.</p>
    <p>В то время как в Ruby я всё держу в одном-единственном месте и (что более важно) отдельно от всего остального!</p>

    <h2 id="title">
        Попробуйте ещё кое-что
    </h2>

    <ul>
        <li><i>Дедушкины часы.</i> Напишите метод, который принимает блок и вызывает его один раз для каждого часа, который прошёл сегодня. Таким образом, если я бы передал ему блок do puts 'БОМ!' end, он бы отбивал время (почти) как дедушкины часы. Проверьте ваш метод с несколькими различными блоками (включая тот, что я вам дал). Подсказка: Вы можете использовать Time.now.hour, чтобы получить текущий час. Однако, он возвращает число между 0 и 23, поэтому вам придётся изменить эти числа, чтобы получить обычные числа, как на циферблате (от 1 до 12).</li>
        <li><i>Протоколирование программ.</i> Напишите метод под названием log, который принимает строку описания блока и, конечно, сам блок. Подобно методу doSelfImportantly, он должен выводить с помощью puts строку, сообщающую, что он начал выполнение блока, и ещё одну строку в конце, сообщающую, что он закончил выполнение блока, а также сообщающую вам, что вернул блок. Проверьте ваш метод, отправив ему блок кода. Внутри этого блока поместите другой вызов метода log, передав ему другой блок. (Это называется вложенностью.) Другими словами, ваш вывод должен выглядеть примерно так:</li>
    </ul>

    <pre class="brush: csharp;">
    Начинаю "внешний блок"...
    Начинаю "другой небольшой блок"...
    ..."другой небольшой блок" закончен, вернул:  5
    Начинаю "ещё один блок"...
    ..."ещё один блок" закончен, вернул:  Мне нравится тайская еда!
    ..."внешний блок" закончен, вернул:  false
    </pre>

    <ul>
        <li><i>Улучшенное протоколирование.</i> Вывод из предыдущего метода log было трудновато читать, и было бы тем хуже, чем больше была бы вложенность. Было бы гораздо легче читать, если бы он делал отступы в строках для внутренних блоков. Чтобы это сделать, вам понадобится проверять, насколько глубоко вложен вызов метода перед тем, как log хочет что-нибудь напечатать. Чтобы сделать это, примените глобальную переменную, т. е. переменную, которую вы можете видеть из любого места вашего кода. Чтобы сделать переменную глобальной, просто поставьте перед именем вашей переменной символ $, вот так: $global, $nestingDepth и $bigTopPeeWee. В конце концов, ваша программа протоколирования должна выводить примерно вот что:</li>
    </ul>

    <pre class="brush: csharp;">
    Начинаю "внешний блок"...
      Начинаю "другой небольшой блок"...
        Начинаю "маленький-премаленький блок"...
        ..."маленький-премаленький блок" закончен, вернул:  море любви
      ..."другой небольшой блок" закончен, вернул:  42
      Начинаю "ещё один блок"...
      ..."ещё один блок" закончен, вернул:  Я люблю индийскую еду!
    ..."внешний блок" закончен, вернул:  true
    </pre>

    <p>Ну вот почти и всё, что вы намеревались узнать из этого учебника.</p>
    <p>Мои поздравления!</p>
    <p>Вы изучили очень много!</p>
    <p>Возможно, вам не кажется, что вы помните всё, или же вы пропустили некоторые части...</p>
    <p>Ну и ладно, это нормально.</p>
    <p>Программирование — это не то, что вы знаете; это то, что вы можете вычислить.</p>
    <p>Покуда вы знаете, где найти то, что вы позабыли, у вас будет всё в  порядке.</p>
    <p>Надеюсь, вы не думаете, что я написал всё это, не заглядывая куда-нибудь время от времени?</p>
    <p>Я именно так и делал.</p>
    <p>Мне также много помогали с кодом, выполняющим все примеры в этом учебнике.</p>
    <p>Но куда же я заглядывал и кого я просил о помощи?</p>
    <p>Давайте, я покажу вам...</p>

    <script src="../../../../js/progressBarSetIni.js" type="text/javascript"></script>

        <div id="lessMenu" style="margin: 30px 0 0 0;">
            <hr />
            <a href="11.html"><div id="exitLess" ontouchstart="return true;"><img src="../../../../img/menu/pr.png" /></div></a>
            <a href="13.html"><div id="aaLess" ontouchstart="return true;"><img src="../../../../img/menu/ne.png" /></div></a>
        </div>

    </div>

    <script type="text/javascript" src="../../../../cordova.js"></script>
    <script type="text/javascript" src="../../../../js/global.js"></script>
    <script type="text/javascript">
        changeColor();
        if (localStorage.getItem("fSize") < 1) { fSize = 16; localStorage.setItem("fSize", 16); } else { fSize = localStorage.getItem("fSize"); }
        document.getElementById("pageBody").style.fontSize = fSize + "px";

        // goBackMenu
        document.addEventListener("backbutton", goBackMenu, false);
        function goBackMenu()
        {
            window.location.href = 'list.html';
        }

        function changeColor()
        {
            if (localStorage.getItem("colorSheme") <= 1)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#f0f0f0");
            }

            if (localStorage.getItem("colorSheme") == 2)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#212121");
                document.getElementById("pageBody").style.color = localStorage.getItem("#efefef");
            }

            if (localStorage.getItem("colorSheme") == 3)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#efe4d0");
            }
        }

        // bm
        if (localStorage.getItem("arrs") != null)
        {
            var arrs = JSON.parse(localStorage.getItem("arrs"));
        }
        else
        {
            var arrs = [];
        }

        var names = ["../acharter/ru/ruby/ruby/12.html", "Блоки и процедурные объекты", "bm1384"];

        function setzBm() { arrs.push(names); localStorage.setItem("arrs", JSON.stringify(arrs)); localStorage.setItem("bm1384", 1); RefBms(); }

        window.onload = function() { RefBms(); }

        function RefBms()
        {
            if (localStorage.getItem("bm1384") == 1) { document.getElementById("bma1384").style.display = "block"; document.getElementById("bm1384").style.display = "none"; } else { document.getElementById("bma1384").style.display = "none"; document.getElementById("bm1384").style.display = "block"; }
        }

        function dellBm() { for (var i = 0; i < arrs.length; i++) { if (arrs[i].indexOf("Блоки и процедурные объекты") == 1) { arrs.splice(i, 1); localStorage.setItem("bm1384", 0); RefBms(); localStorage.setItem("arrs", JSON.stringify(arrs)); } } }

        // sub menu
        var serTimeToClose = 1000;
        
        function OpenSettMenu()
        {
            document.getElementById("subMenuInLess").style.display = "block";
            timeToEvAct();
            serTimeToClose = 1;
        }
        
        function timeToEvAct()
        {
            setTimeout(function() { serTimeToClose = 0 }, 100);
        }
        
        window.addEventListener('click', function(e){
        
            if (serTimeToClose <= 0)
            {
                if (document.getElementById('subMenuInLess').contains(e.target))
                {
                    //
                }
                else
                {
                    document.getElementById("subMenuInLess").style.display = "none";
                }
            }
        });

    </script>

</body>
</html>
