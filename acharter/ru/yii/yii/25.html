
<!DOCTYPE html>

<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <link rel="stylesheet" type="text/css" href="../../../../css/read.css" />
    <title>Coder Book menu</title>
    <script type="text/javascript" src="../../../../higtline/scripts/shCore.js"></script>
    <script type="text/javascript" src="../../../../higtline/scripts/shBrushCSharp.js"></script>
    <link type="text/css" rel="stylesheet" href="../../../../higtline/styles/shCoreDefault.css"/>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <script src="../../../../js/Hyphenator.js" type="text/javascript"></script>
</head>

<body id="pageBody" class="hyphenate">

<!-- progress bar -->
<script src="../../../../js/progressBar.js" type="text/javascript"></script>
<div class="Reading-progress" id="progressBarType1"><span id="Progress-bar-top" class="bar-top" style="display: block !important;"></span></div>
<div class="Reading-progress" id="progressBarType2"><span id="Progress-bar-bottom" class="bar-bottom"></span></div>
<div class="Reading-progress" id="progressBarType3"><span id="Progress-bar-left" class="bar-left"></span></div>
<div class="Reading-progress" id="progressBarType4"><span id="Progress-bar-right" class="bar-right"></span></div>
<!-- progress bar -->


    <div id="lesonPage">

        <div id="lessMenu">
           <a id="exitLess" href="list.html" ontouchstart="return true;"><img src="../../../../img/menu/ex.png" /></a>
           <div id="aaLess" ontouchstart="return true;" onclick="OpenSettMenu();"><img src="../../../../img/menu/aa.png" /></div>
           <div id="subMenuInLess" style="display: none;">
                <a href="../../../../menu/setfontsize-ru.html" ontouchstart="return true;" id="pastMenuInLess">Размер текста</a>
                <a href="../../../../menu/setcolor-ru.html" ontouchstart="return true;" id="pastMenuInLess">Цветовая темы</a>
                <a href="../../../../menu/setProgressBar-ru.html" ontouchstart="return true;" id="pastMenuInLess" style="border: none;">Прогресс бар</a>
           </div>
           <div id="aaLess" ontouchstart="return true;">
            <div class="bmEdit" onclick="dellBm();" id="bma1176" ontouchstart="return true;" style="display: none;"><img src="../../../../img/menu/bmlessa.png" /></div>
            <div class="bmEdit" onclick="setzBm();" id="bm1176" ontouchstart="return true;" style="display: block;"><img src="../../../../img/menu/bmless.png" /></div>
           </div>
        </div>

        <hr />

	<!-- ПОЧАТОК -->
	
	<h1 id="title">
		Конструктор запросов Yii
	</h1>

    <p>Конструктор запросов Yii предоставляет объектно-ориентированный способ написания SQL-запросов.</p>
    <p>Он позволяет разработчику использовать методы и свойства класса для того, чтобы указать отдельные части SQL-запроса.</p>
    <p>Затем конструктор собирает отдельные части в единый SQL-запрос, который может быть выполнен вызовом методов DAO, как описано в «Объекты доступа к данным (DAO)».</p>
    <p>Следующий код показывает типичное использование конструктора запросов для создания SQL-запроса SELECT:</p>

    <pre class="brush: csharp;">
    $user = Yii::app()->db->createCommand()
        ->select('id, username, profile')
        ->from('tbl_user u')
        ->join('tbl_profile p', 'u.id=p.user_id')
        ->where('id=:id', array(':id'=>$id))
        ->queryRow();
    </pre>

    <p>Конструктор запросов лучше всего использовать в том случае, когда необходимо собрать SQL-запрос, следуя некоторой условной логике приложения.</p>
    <p>Основными достоинствами конструктора запросов являются:</p>

    <ul>
        <li>Возможность собрать сложный SQL-запрос программно.</li>
        <li>Автоматическое экранирование имён таблиц и полей для избежания конфликтов с ключевыми словами SQL и специальными символами.</li>
        <li>Экранирование значений параметров и, где это возможно, использование привязки параметров, помогающей избежать SQL-инъекций.</li>
        <li>Слой абстракции, упрощающий переход на другие СУБД.</li>
    </ul>

    <p>Использовать конструктор запросов не обязательно. Если ваши запросы простые, легче и быстрее использовать именно SQL.</p>
    <p><b>Примечание:</b> Конструктор запросов не может быть использован для изменения существующего запроса, заданного при помощи SQL. К примеру, не будет работать следующий код:</p>

    <pre class="brush: csharp;">
    $command = Yii::app()->db->createCommand('SELECT * FROM tbl_user');
    
    // следующая строка НЕ добавит WHERE к SQL
    $command->where('id=:id', array(':id'=>$id));
    </pre>

    <p>Не стоит использовать для одного запроса и SQL, и конструктор запросов.</p>

    <h2 id="title">
        Подготовка конструктора запросов
    </h2>

    <p>Конструктор запросов реализован в классе CDbCommand — главном классе для работы с базой данных, описанном в разделе «Объекты доступа к данным (DAO)».</p>
    <p>Для того чтобы начать его использовать, необходимо создать новый экземпляр CDbCommand:</p>

    <pre class="brush: csharp;">
    $command = Yii::app()->db->createCommand();
    </pre>

    <p>Здесь мы используем Yii::app()->db для получения соединения с базой данных и затем вызываем CDbConnection::createCommand() для создания экземпляра команды.</p>
    <p>Следует отметить, что теперь мы не передаём методу createCommand() готовое SQL-выражение, как это делалось в случае с DAO.</p>
    <p>Вместо этого мы соберём отдельные части запроса при помощи методов конструктора, которые описаны далее.</p>

    <h2 id="title">
        Запросы на получение данных
    </h2>

    <p>Запросы на получение данных соответствуют SQL-запросам SELECT.</p>
    <p>В конструкторе есть ряд методов для сборки отдельных частей SELECT запроса.</p>
    <p>Так как все эти методы возвращают экземпляр CDbCommand, мы можем использовать их цепочкой, как показано в примере в начале этого раздела.</p>

    <ul>
        <li>select(): часть запроса после SELECT.</li>
        <li>selectDistinct(): часть запроса после SELECT. Добавляет DISTINCT.</li>
        <li>from(): часть запроса после FROM.</li>
        <li>where(): часть запроса после WHERE.</li>
        <li>join(): добавляет к запросу INNER JOIN.</li>
        <li>leftJoin(): добавляет к запросу LEFT OUTER JOIN.</li>
        <li>rightJoin(): добавляет к запросу RIGHT OUTER JOIN.</li>
        <li>crossJoin(): добавляет к запросу CROSS JOIN.</li>
        <li>naturalJoin(): добавляет к запросу NATURAL JOIN.</li>
        <li>group(): часть запроса после GROUP BY.</li>
        <li>having(): часть запроса после HAVING.</li>
        <li>order(): часть запроса после ORDER BY.</li>
        <li>limit(): часть запроса после LIMIT.</li>
        <li>offset(): часть запроса после OFFSET.</li>
        <li>union(): часть запроса после UNION.</li>
    </ul>

    <p>Рассмотрим использование перечисленных методов.</p>
    <p>Для простоты предположим, что запросы делаются к MySQL.</p>
    <p>Для других СУБД способ экранирования названий таблиц, полей и значений, используемый в примерах, может отличаться.</p>

    <h3 id="title">
        select()
    </h3>

    <pre class="brush: csharp;">
    function select($columns='*')
    </pre>

    <p>Метод select() задаёт часть запроса после SELECT.</p>
    <p>Параметр $columns определяет выбираемые поля и может быть либо списком имён выбираемых полей, разделённых запятой, либо массивом имён полей.</p>
    <p>Имена могут содержать префиксы таблиц и псевдонимы полей.</p>
    <p>Метод автоматически экранирует имена, если в них нет скобок (что означает использование выражения).</p>
    <p>Несколько примеров:</p>

    <pre class="brush: csharp;">
    // SELECT *
    select()
    
    // SELECT `id`, `username`
    select('id, username')
    
    // SELECT `tbl_user`.`id`, `username` AS `name`
    select('tbl_user.id, username as name')
    
    // SELECT `id`, `username`
    select(array('id', 'username'))
    
    // SELECT `id`, count(*) as num
    select(array('id', 'count(*) as num'))
    </pre>

    <h3 id="title">
        selectDistinct()
    </h3>

    <pre class="brush: csharp;">
    function selectDistinct($columns)
    </pre>

    <p>Метод selectDistinct() делает то же, что и метод select(), но добавляет к выражению DISTINCT.</p>
    <p>К примеру, selectDistinct('id, username') сгенерирует следующий SQL:</p>
    
    <pre class="brush: csharp;">
    SELECT DISTINCT `id`, `username`
    </pre>

    <h3 id="title">
        from()
    </h3>

    <pre class="brush: csharp;">
    function from($tables)
    </pre>

    <p>Метод from() задаёт часть запроса после FROM.</p>
    <p>Параметр $tables определяет, из каких таблиц производится выборка, и может быть либо списком имён таблиц, разделённых запятыми, либо массивом имён таблиц.</p>
    <p>Имена могут содержать префиксы схемы (такие, как public.tbl_user) и псевдонимы таблиц (такие, как tbl_user u).</p>
    <p>Метод автоматически экранирует имена, если в них нет скобок (что означает использование подзапроса или выражения).</p>
    <p>Примеры:</p>

    <pre class="brush: csharp;">
    // FROM `tbl_user`
    from('tbl_user')
    
    // FROM `tbl_user` `u`, `public`.`tbl_profile` `p`
    from('tbl_user u, public.tbl_profile p')
    
    // FROM `tbl_user`, `tbl_profile`
    from(array('tbl_user', 'tbl_profile'))
    
    // FROM `tbl_user`, (select * from tbl_profile) p
    from(array('tbl_user', '(select * from tbl_profile) p'))
    </pre>

    <h3 id="title">
        where()
    </h3>

    <pre class="brush: csharp;">
    function where($conditions, $params=array())
    </pre>

    <p>Метод where() задаёт часть запроса после WHERE.</p>
    <p>Параметр $conditions определяет условия запроса, а $params — параметры, которые подставляются в запрос.</p>
    <p>Значение параметра $conditions может быть как строкой (например, id=1), так и массивом следующего вида:</p>

    <pre class="brush: csharp;">
    array(operator, operand1, operand2, ...)
    </pre>

    <p>где operator может быть одним из следующих:</p>

    <ul>
        <li>and: операнды соединяются при помощи AND. К примеру, array('and', 'id=1', 'id=2') сгенерирует id=1 AND id=2. Если операнд является массивом, то он будет преобразован в строку с использованием описанных здесь правил. К примеру, array('and', 'type=1', array('or', 'id=1', 'id=2')) сгенерирует type=1 AND (id=1 OR id=2). Данный метод ничего НЕ экранирует.</li>
        <li>or: то же, что и and, но для OR.</li>
        <li>in: первый операнд должнен быть столбцом или выражением, второй — массивом, содержащим список значений, в которые должно входить значение поля или выражения. К примеру, array('in', 'id', array(1,2,3)) сгенерирует id IN (1,2,3). Метод экранирует имя столбца и значения в списке.</li>
        <li>not in: то же, что и in, но вместо IN используется NOT IN.</li>
        <li>like: первый операнд должен быть именем поля или выражением, второй — строкой или массивом, содержащим список значений, на которые должно быть похоже значение поля или выражения. К примеру, array('like', 'name', '%tester%') сгенерирует name LIKE '%tester%'. Когда список значений является массивом, генерируется несколько LIKE, соединённых при помощи AND. Например, array('like', 'name', array('%test%', '%sample%')) сгенерирует name LIKE '%test%' AND name LIKE '%sample%'. Метод экранирует имена полей и значения в списке.</li>
        <li>not like: то же, что и like, но вместо LIKE генерируется NOT LIKE.</li>
        <li>or like: то же, что и like но для соединения LIKE используется OR.</li>
        <li>or not like: то же, что и not like но для соединения NOT LIKE используется OR.</li>
    </ul>

    <p>Несколько примеров использования where:</p>

    <pre class="brush: csharp;">
    // WHERE id=1 or id=2
    where('id=1 or id=2')
    
    // WHERE id=:id1 or id=:id2
    where('id=:id1 or id=:id2', array(':id1'=>1, ':id2'=>2))
    
    // WHERE id=1 OR id=2
    where(array('or', 'id=1', 'id=2'))
    
    // WHERE id=1 AND (type=2 OR type=3)
    where(array('and', 'id=1', array('or', 'type=2', 'type=3')))
    
    // WHERE `id` IN (1, 2)
    where(array('in', 'id', array(1, 2))
    
    // WHERE `id` NOT IN (1, 2)
    where(array('not in', 'id', array(1,2)))
    
    // WHERE `name` LIKE '%Qiang%'
    where(array('like', 'name', '%Qiang%'))
    
    // WHERE `name` LIKE '%Qiang' AND `name` LIKE '%Xue'
    where(array('like', 'name', array('%Qiang', '%Xue')))
    
    // WHERE `name` LIKE '%Qiang' OR `name` LIKE '%Xue'
    where(array('or like', 'name', array('%Qiang', '%Xue')))
    
    // WHERE `name` NOT LIKE '%Qiang%'
    where(array('not like', 'name', '%Qiang%'))
    
    // WHERE `name` NOT LIKE '%Qiang%' OR `name` NOT LIKE '%Xue%'
    where(array('or not like', 'name', array('%Qiang%', '%Xue%')))
    </pre>

    <p>Стоит отметить, что в случае, когда оператор содержит like, необходимо явно задавать спецсимволы (вроде % и _).</p>
    <p>Если паттерн вводится пользователем, то необходимо использовать приведённый ниже код для экранирования спецсимволов и предотвращения интерпретации их как спецсимволов:</p>

    <pre class="brush: csharp;">
    $keyword=$_GET['q'];
    
    // экранирует символы % и _
    $keyword=strtr($keyword, array('%'=>'\%', '_'=>'\_'));
    $command->where(array('like', 'title', '%'.$keyword.'%'));
    </pre>

    <h3 id="title">
        order()
    </h3>

    <pre class="brush: csharp;">
    function order($columns)
    </pre>

    <p>Метод order() задаёт часть запроса после ORDER BY.</p>
    <p>Параметр $columns определяет, по каким полям будет производиться сортировка.</p>
    <p>Поля могут быть указаны как в виде строки, содержащей список полей и направлений (ASC или DESC), разделённых запятыми, так и массив полей и направлений.</p>
    <p>Имена полей могут содержать префиксы таблиц.</p>
    <p>Метод автоматически экранирует имена полей, если они не содержат скобок (что означает использование выражения).</p>
    <p>Несколько примеров:</p>

    <pre class="brush: csharp;">
    // ORDER BY `name`, `id` DESC
    order('name, id desc')
    
    // ORDER BY `tbl_profile`.`name`, `id` DESC
    order(array('tbl_profile.name', 'id desc'))
    </pre>

    <h3 id="title">
        limit() и offset()
    </h3>
    
    <pre class="brush: csharp;">
    function limit($limit, $offset=null)
    function offset($offset)
    </pre>

    <p>Методы limit() и offset() задают части запроса, следующие после LIMIT и OFFSET.</p>
    <p>Стоит отметить, что не все СУБД поддерживают именно синтаксис LIMIT и OFFSET.</p>
    <p>Если он не поддерживается, то конструктор запросов переписывает весь SQL-запрос для достижения схожего эффекта.</p>
    <p>Несколько примеров:</p>

    <pre class="brush: csharp;">
    // LIMIT 10
    limit(10)
    
    // LIMIT 10 OFFSET 20
    limit(10, 20)
    
    // OFFSET 20
    offset(20)
    </pre>

    <h3 id="title">
        join() и его варианты
    </h3>

    <pre class="brush: csharp;">
    function join($table, $conditions, $params=array())
    function leftJoin($table, $conditions, $params=array())
    function rightJoin($table, $conditions, $params=array())
    function crossJoin($table)
    function naturalJoin($table)
    </pre>

    <p>Метод join() и его варианты задают порядок и параметры соединения таблиц с использованием INNER JOIN, LEFT OUTER JOIN, RIGHT OUTER JOIN, CROSS JOIN и NATURAL JOIN.</p>
    <p>Параметр $table определяет таблицу, с которой производится соединение.</p>
    <p>Имя таблицы может содержать префикс схемы или псевдоним.</p>
    <p>Метод экранирует имя таблицы, если оно не содержит скобок, что означает использование подзапроса или выражения.</p>
    <p>Параметр $conditions задаёт условие соединения.</p>
    <p>Синтаксис такой же, как и у where().</p>
    <p>Через $params указываются параметры, подставляемые в запрос.</p>
    <p>Стоит отметить, что этот метод отличается от остальных тем, что каждый следующий его вызов добавляет часть запроса к предыдущим.</p>
    <p>Несколько примеров:</p>

    <pre class="brush: csharp;">
    // JOIN `tbl_profile` ON user_id=id
    join('tbl_profile', 'user_id=id')
    
    // LEFT JOIN `pub`.`tbl_profile` `p` ON p.user_id=id AND type=1
    leftJoin('pub.tbl_profile p', 'p.user_id=id AND type=:type', array(':type'=>1))
    </pre>

    <h3 id="title">
        group()
    </h3>
    
    <pre class="brush: csharp;">
    function group($columns)
    </pre>

    <p>Метод group() задаёт часть запроса после GROUP BY.</p>
    <p>Параметр $columns определяет поля, по которым будет осуществляться группировка, и может быть либо строкой разделённых запятыми полей, либо массивом полей.</p>
    <p>Имена полей могут содержать префиксы. Метод автоматически экранирует имена полей, если они не содержат скобок (что означает использование выражений).</p>
    <p>Несколько примеров:</p>

    <pre class="brush: csharp;">
    // GROUP BY `name`, `id`
    group('name, id')
    
    // GROUP BY `tbl_profile`.`name`, `id`
    group(array('tbl_profile.name', 'id'))
    </pre>
    
    <h3 id="title">
        having()
    </h3>

    <pre class="brush: csharp;">
    function having($conditions, $params=array())
    </pre>

    <p>Метод having() задаёт часть запроса после HAVING. Используется точно так же, как и where().</p>
    <p>Несколько примеров:</p>

    <pre class="brush: csharp;">
    // HAVING id=1 or id=2
    having('id=1 or id=2')
    
    // HAVING id=1 OR id=2
    having(array('or', 'id=1', 'id=2'))
    </pre>

    <h3 id="title">
        union()
    </h3>

    <pre class="brush: csharp;">
    function union($sql)
    </pre>

    <p>Метод union() задаёт часть запроса после UNION.</p>
    <p>Он добавляет $sql к сгенерированному запросу, используя UNION.</p>
    <p>Несколько вызовов union() добавят несколько частей запроса.</p>
    <p>Несколько примеров:</p>

    <pre class="brush: csharp;">
    // UNION (select * from tbl_profile)
    union('select * from tbl_profile')
    </pre>

    <h3 id="title">
        Выполнение запросов
    </h3>


    <p>После вызова приведённых выше методов для построения запроса, выполнить его можно, используя методы DAO, как описано в разделе «Объекты доступа к данным (DAO)».</p>
    <p>Например, мы можем использовать метод CDbCommand::queryRow() для получения строки или CDbCommand::queryAll() для получения набора строк.1</p>
    <p>Пример:</p>

    <pre class="brush: csharp;">
    $users = Yii::app()->db->createCommand()
        ->select('*')
        ->from('tbl_user')
        ->queryAll();
    </pre>

    <h3 id="title">
        Получение SQL
    </h3>

    <p>Кроме выполнения запросов, которые мы создали при помощи конструктора, можно также получить их SQL.</p>
    <p>Сделать это можно при помощи CDbCommand::getText().</p>

    <pre class="brush: csharp;">
    $sql = Yii::app()->db->createCommand()
        ->select('*')
        ->from('tbl_user')
        ->text;
    </pre>

    <p>Если у запроса есть параметры, получить их можно при помощи свойства CDbCommand::params.</p>

    <h3 id="title">
        Альтернативный синтаксис построения запросов
    </h3>

    <p>Иногда использование цепочек вызовов может быть неоптимальным решением.</p>
    <p>Конструктор запросов Yii позволяет создать запрос путём задания полей объекта.</p>
    <p>Для каждого метода конструктора запросов есть соответствующее поле с таким же именем.</p>
    <p>Присвоение значения полю эквивалентно вызову соответствующего метода.</p>
    <p>К примеру, приведённые ниже строки эквивалентны, если $command — объект CDbCommand:</p>

    <pre class="brush: csharp;">
    $command->select(array('id', 'username'));
    $command->select = array('id', 'username');
    </pre>

    <p>Более того, метод CDbConnection::createCommand() может принимать массив в качестве аргумента.</p>
    <p>Пары имя-значение из массива будут использованы для инициализации полей созданного экземпляра CDbCommand.</p>
    <p>Таким образом, для построения запроса можно использовать следующий код:</p>

    <pre class="brush: csharp;">
    $row = Yii::app()->db->createCommand(array(
        'select' => array('id', 'username'),
        'from' => 'tbl_user',
        'where' => 'id=:id',
        'params' => array(':id'=>1),
    ))->queryRow();
    </pre>

    <h3 id="title">
        Построение нескольких запросов
    </h3>

    <p>Для построения нескольких запросов экземпляр CDbCommand может быть использован несколько раз.</p>
    <p>Перед тем как построить новый запрос, необходимо вызвать метод CDbCommand::reset() для очистки предыдушего запроса.</p>
    <p>Пример:</p>

    <pre class="brush: csharp;">
    $command = Yii::app()->db->createCommand();
    $users = $command->select('*')->from('tbl_users')->queryAll();
    $command->reset();  // очищаем предыдущий запрос
    $posts = $command->select('*')->from('tbl_posts')->queryAll();
    </pre>

    <h2 id="title">
        Построение запросов для изменения данных
    </h2>

    <p>К запросам для изменения данных относятся SQL-запросы для вставки, обновления и удаления данных из базы.</p>
    <p>В конструкторе запросов есть соответствующие методы insert, update и delete.</p>
    <p>В отличие от запросов получения данных, описанных выше, данные методы строят полный SQL-запрос и тут же выполняют его.</p>

    <ul>
        <li>insert(): вставляет строку в таблицу;</li>
        <li>update(): обновляет данные в таблице;</li>
        <li>delete(): удаляет данные из таблицы.</li>
    </ul>

    <h3 id="title">
        insert()
    </h3>

    <pre class="brush: csharp;">
    function insert($table, $columns)
    </pre>

    <p>Метод insert() строит и выполняет SQL-запрос INSERT.</p>
    <p>Параметр $table указывает, в какую таблицу производится вставка, а $columns является массивом пар имя-значение полей для вставки.</p>
    <p>Метод экранирует имя таблицы и использует параметры для вставляемых значений.</p>
    <p>Пример:</p>

    <pre class="brush: csharp;">
    // строим и выполняем следующий SQL:
    // INSERT INTO `tbl_user` (`name`, `email`) VALUES (:name, :email)
    $command->insert('tbl_user', array(
        'name'=>'Tester',
        'email'=>'tester@example.com',
    ));
    </pre>

    <h3 id="title">
        update()
    </h3>

    <pre class="brush: csharp;">
    function update($table, $columns, $conditions='', $params=array())
    </pre>

    <p>Метод update() строит и выполняет SQL-запрос UPDATE.</p>
    <p>Параметр $table указывает обновляемую таблицу; $columns является массивом пар имя-значение, задающим значения обновляемых полей; $conditions и $params эквивалентны аналогичным параметрам в where() и определяют часть запроса UPDATE после WHERE.</p>
    <p>Метод экранирует имя таблицы и использует параметры для обновляемых значений.</p>
    <p>Пример:</p>

    <pre class="brush: csharp;">
    // строим и выполняем следующий SQL:
    // UPDATE `tbl_user` SET `name`=:name WHERE id=:id
    $command->update('tbl_user', array(
        'name'=>'Tester',
    ), 'id=:id', array(':id'=>1));
    </pre>

    <h3 id="title">
        delete
    </h3>

    <pre class="brush: csharp;">
    function delete($table, $conditions='', $params=array())
    </pre>

    <p>Метод delete() строит и выполняет SQL-запрос DELETE.</p>
    <p>Параметр $table указывает таблицу, из которой удаляются записи; $conditions и $params эквивалентны аналогичным параметрам в where(), которые определяют часть запроса DELETE после WHERE.</p>
    <p>Метод экранирует имя таблицы.</p>
    <p>Пример:</p>

    <pre class="brush: csharp;">
    // строим и выполняем следующий SQL:
    // DELETE FROM `tbl_user` WHERE id=:id
    $command->delete('tbl_user', 'id=:id', array(':id'=>1));
    </pre>

    <h2 id="title">
        Построение запросов изменения схемы
    </h2>

    <p>Кроме обычных запросов для получения данных и работы с ними, конструктор может собирать и выполнять SQL-запросы для изменения схемы базы данных.</p>
    <p>Поддерживаются следующие запросы:</p>

    <ul>
        <li>createTable(): создание таблицы;</li>
        <li>renameTable(): переименование таблицы;</li>
        <li>dropTable(): удаление таблицы;</li>
        <li>truncateTable(): очистка таблицы;</li>
        <li>addColumn(): добавление нового поля в таблицу;</li>
        <li>renameColumn(): переименование поля таблицы;</li>
        <li>alterColumn(): изменение поля таблицы;</li>
        <li>addForeignKey(): добавление внешнего ключа (доступно с версии 1.1.6)</li>
        <li>dropForeignKey(): удаление внешнего ключа (доступно с версии 1.1.6)</li>
        <li>dropColumn(): удаление поля таблицы;</li>
        <li>createIndex(): создание индекса;</li>
        <li>dropIndex(): удаление индекса.</li>
    </ul>

    <p><b>Информация:</b> Несмотря на то что в разных СУБД запросы для измения схемы различаются, конструктор запросов предоставляет единый интерфейс для их создания. Это упрощает задачу мигрирования с одной СУБД на другую.</p>

    <h3 id="title">
        Абстрактные типы данных
    </h3>

    <p>Конструктор запросов вводит ряд абстрактных типов данных, которые можно использовать для описания полей таблицы.</p>
    <p>В отличие от реальных типов данных, которые отличаются в разных СУБД, абстрактные типы не зависят от СУБД.</p>
    <p>При использовании их для описания типов полей конструктор запросов конвертирует абстрактные типы в соответствующие им реальные.</p>
    <p>Конструктор запросов поддерживает следующие абстрактные типы:</p>

    <ul>
        <li>pk: обычный первичный ключ. Для MySQL конвертируется в int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY;</li>
        <li>string: строка. Для MySQL конвертируется в varchar(255);</li>
        <li>text: текстовый тип (длинная строка). Для MySQL конвертируется в text;</li>
        <li>integer: целое. Для MySQL конвертируется в int(11);</li>
        <li>float: число с плавающей точкой. Для MySQL конвертируется в float;</li>
        <li>decimal: десятичное число. Для MySQL конвертируется в decimal;</li>
        <li>datetime: дата и время. Для MySQL конвертируется в datetime;</li>
        <li>timestamp: метка времени. Для MySQL конвертируется в timestamp;</li>
        <li>time: время. Для MySQL конвертируется в time;</li>
        <li>date: дата. Для MySQL конвертируется в date;</li>
        <li>binary: бинарный. Для MySQL конвертируется в blob;</li>
        <li>boolean: булевый. Для MySQL конвертируется в tinyint(1);</li>
        <li>money: деньги/валюта. Для MySQL конвертируется в decimal(19,4). Доступен с версии 1.1.8.</li>
    </ul>

    <h3 id="title">
        createTable()
    </h3>

    <pre class="brush: csharp;">
    function createTable($table, $columns, $options=null)
    </pre>

    <p>Метод createTable() строит и выполняет SQL-запрос для создания таблицы.</p>
    <p>Параметр $table задаёт имя создаваемой таблицы.</p>
    <p>Параметр $columns определяет поля новой таблицы.</p>
    <p>Они должны быть указаны в виде пар имя-определение (т.е. 'username'=>'string').</p>
    <p>Параметр $options задаёт дополнительный фрагмент SQL, который будет добавлен к генерируемому SQL.</p>
    <p>Конструктор запроса экранирует имя таблицы и имена полей.</p>
    <p>Для указания определения поля можно использовать один из абстрактных типов данных, описанных выше.</p>
    <p>Конструктор конвертирует абстрактный тип данных в соответствующий реальный тип данных в соответствии с используемой СУБД.</p>
    <p>Например, string в случае MySQL преобразуется в varchar(255).</p>
    <p>Определение поля также может содержать неабстрактный тип данных и спецификаций.</p>
    <p>Они будут подставлены в результирующий SQL-запрос без каких-либо изменений.</p>
    <p>К примеру, point не является абстрактным типом данных, и при использовании в определении поля он будет включён в итоговый SQL без изменений.</p>
    <p>string NOT NULL будет конвертирован в varchar(255) NOT NULL (т.е. конвертируются только абстрактный тип string).</p>
    <p>Пример создания таблицы:</p>

    <pre class="brush: csharp;">
    // CREATE TABLE `tbl_user` (
    //     `id` int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY,
    //     `username` varchar(255) NOT NULL,
    //     `location` point
    // ) ENGINE=InnoDB
    createTable('tbl_user', array(
        'id' => 'pk',
        'username' => 'string NOT NULL',
        'location' => 'point',
    ), 'ENGINE=InnoDB')
    </pre>

    <h3 id="title">
        renameTable()
    </h3>

    <pre class="brush: csharp;">
    function renameTable($table, $newName)
    </pre>

    <p>Метод renameTable() строит и выполняет SQL-запрос для переименования таблицы.</p>
    <p>Параметр $table задаёт имя изменяемой таблицы.</p>
    <p>Параметр $newName определяет новое имя таблицы.</p>
    <p>Конструктор запроса экранирует имена таблицы.</p>
    <p>Пример переименования таблицы:</p>

    <pre class="brush: csharp;">
    // RENAME TABLE `tbl_users` TO `tbl_user`
    renameTable('tbl_users', 'tbl_user')
    </pre>

    <h3 id="title">
        dropTable()
    </h3>

    <pre class="brush: csharp;">
    function dropTable($table)
    </pre>

    <p>Метод dropTable() строит и выполняет SQL-запрос для удаления таблицы.</p>
    <p>Параметр $table определяет имя удаляемой таблицы.</p>
    <p>Конструктор запроса экранирует имя таблицы.</p>
    <p>Пример удаления таблицы:</p>

    <pre class="brush: csharp;">
    // DROP TABLE `tbl_user`
    dropTable('tbl_user')
    </pre>

    <h3 id="title">
        truncateTable()
    </h3>

    <pre class="brush: csharp;">
    function truncateTable($table)
    </pre>

    <p>Метод truncateTable() строит и выполняет SQL-запрос для очистки всех данных таблицы.</p>
    <p>Параметр $table определяет имя очищаемой таблицы.</p>
    <p>Конструктор запроса экранирует имя таблицы.</p>
    <p>Пример очистки таблицы:</p>

    <pre class="brush: csharp;">
    // TRUNCATE TABLE `tbl_user`
    truncateTable('tbl_user')
    </pre>

    <h3 id="title">
        addColumn()
    </h3>

    <pre class="brush: csharp;">
    function addColumn($table, $column, $type)
    </pre>

    <p>Метод addColumn() строит и выполняет SQL-запрос для добавления нового поля таблицы.</p>
    <p>Параметр $table задаёт имя таблицы, к которой будет добавлено новое поле.</p>
    <p>Параметр $column — имя нового поля.</p>
    <p>$type задаёт тип поля.</p>
    <p>Определение поля может содержать абстрактный тип данных, как уже было описано в подразделе «createTable».</p>
    <p>Конструктор запроса экранирует имя таблицы и имя поля.</p>
    <p>Пример добавления поля:</p>

    <pre class="brush: csharp;">
    // ALTER TABLE `tbl_user` ADD `email` varchar(255) NOT NULL
    addColumn('tbl_user', 'email', 'string NOT NULL')
    </pre>

    <h3 id="title">
        dropColumn()
    </h3>

    <pre class="brush: csharp;">
    function dropColumn($table, $column)
    </pre>

    <p>Метод dropColumn() строит и выполняет SQL-запрос для удаления поля таблицы.</p>
    <p>Параметр $table задаёт имя таблицы, из которой удаляется поле.</p>
    <p>Параметр $column определяет имя удаляемого поля.</p>
    <p>Конструктор запроса экранирует имя таблицы и имя поля.</p>
    <p>Пример удаления поля таблицы:</p>

    <pre class="brush: csharp;">
    // ALTER TABLE `tbl_user` DROP COLUMN `location`
    dropColumn('tbl_user', 'location')
    </pre>

    <h3 id="title">
        renameColumn()
    </h3>

    <pre class="brush: csharp;">
    function renameColumn($table, $name, $newName)
    </pre>

    <p>Метод renameColumn() строит и выполняет SQL-запрос для переименования поля таблицы.</p>
    <p>Параметр $table задаёт имя таблицы, поле которой будет переименовано.</p>
    <p>Параметр $name определяет имя изменяемого поля.</p>
    <p>$newName задаёт новое имя поля.</p>
    <p>Конструктор запроса экранирует имя таблицы и имена полей.</p>
    <p>Пример переименования поля таблицы:</p>

    <pre class="brush: csharp;">
    // ALTER TABLE `tbl_users` CHANGE `name` `username` varchar(255) NOT NULL
    renameColumn('tbl_user', 'name', 'username')
    </pre>

    <h3 id="title">
        alterColumn()
    </h3>

    <pre class="brush: csharp;">
    function alterColumn($table, $column, $type)
    </pre>

    <p>Метод alterColumn() строит и выполняет SQL-запрос для изменения поля таблицы.</p>
    <p>Параметр $table задаёт имя таблицы, поле которой будет изменено.</p>
    <p>Параметр $column определяет имя изменяемого поля.</p>
    <p>$type задаёт новое определение поля, которое может содержать абстрактный тип данных, как было описано в подразделе «createTable».</p>
    <p>Конструктор запросов экранирует имя таблицы и имя поля.</p>
    <p>Пример изменения поля таблицы:</p>

    <pre class="brush: csharp;">
    // ALTER TABLE `tbl_user` CHANGE `username` `username` varchar(255) NOT NULL
    alterColumn('tbl_user', 'username', 'string NOT NULL')
    </pre>

    <h3 id="title">
        addForeignKey()
    </h3>

    <pre class="brush: csharp;">
    function addForeignKey($name, $table, $columns,
        $refTable, $refColumns, $delete=null, $update=null)
    </pre>

    <p>Метод addForeignKey() строит и выполняет SQL-запрос для добавления внешнего ключа в таблицу.</p>
    <p>Параметр $name задаёт имя внешнего ключа.</p>
    <p>Параметры $table и $columns определяют имя таблицы и имя поля внешнего ключа.</p>
    <p>Если указаны несколько полей, то они должны быть разделены запятыми.</p>
    <p>Параметры $refTable и $refColumns определяют имя таблицы и имя поля, на которое ссылается внешний ключ.</p>
    <p>Параметры $delete и $update задают SQL-опции ON DELETE и ON UPDATE соответственно.</p>
    <p>Большинство СУБД поддерживают следующие опции: RESTRICT, CASCADE, NO ACTION, SET DEFAULT и SET NULL.</p>
    <p>Конструктор запросов экранирует имя таблицы, имя индекса и имена полей.</p>
    <p>Пример добавления внешнего ключа:</p>

    <pre class="brush: csharp;">
    // ALTER TABLE `tbl_profile` ADD CONSTRAINT `fk_profile_user_id`
    // FOREIGN KEY (`user_id`) REFERENCES `tbl_user` (`id`)
    // ON DELETE CASCADE ON UPDATE CASCADE
    addForeignKey('fk_profile_user_id', 'tbl_profile', 'user_id',
        'tbl_user', 'id', 'CASCADE', 'CASCADE')
    </pre>

    <h3 id="title">
        dropForeignKey()
    </h3>

    <pre class="brush: csharp;">
    function dropForeignKey($name, $table)
    </pre>

    <p>Метод dropForeignKey() строит и выполняет SQL-запрос для удаления внешнего ключа.</p>
    <p>Параметр $name задаёт имя внешнего ключа, который требуется удалить.</p>
    <p>Параметр $table — имя таблицы, из которой удаляется ключ.</p>
    <p>Конструктор запроса экранирует имя таблицы и имя ключа.</p>
    <p>Пример удаления внешнего ключа:</p>

    <pre class="brush: csharp;">
    // ALTER TABLE `tbl_profile` DROP FOREIGN KEY `fk_profile_user_id`
    dropForeignKey('fk_profile_user_id', 'tbl_profile')
    </pre>

    <h3 id="title">
        createIndex()
    </h3>

    <pre class="brush: csharp;">
    function createIndex($name, $table, $column, $unique=false)
    </pre>

    <p>Метод createIndex() строит и выполняет SQL-запрос для создания индекса.</p>
    <p>Параметр $name задаёт имя индекса, который будет создан.</p>
    <p>Параметр $table — имя таблицы, в которой создаётся индекс. Параметр $column — имя индексируемого поля.</p>
    <p>Параметр $unique определяет, будет ли индекс уникальным.</p>
    <p>Если индекс состоит из нескольких полей, то они разделяются запятыми.</p>
    <p>Конструктор запросов экранирует имя таблицы, имя индекса и имена полей.</p>
    <p>Пример создания индекса:</p>

    <pre class="brush: csharp;">
    // CREATE INDEX `idx_username` ON `tbl_user` (`username`)
    createIndex('idx_username', 'tbl_user', 'username')
    </pre>

    <h3 id="title">
        dropIndex()
    </h3>

    <pre class="brush: csharp;">
    function dropIndex($name, $table)
    </pre>

    <p>Метод dropIndex() строит и выполняет SQL-запрос для удаления индекса.</p>
    <p>Параметр $name задаёт имя удаляемого индекса.</p>
    <p>Параметр $table — имя таблицы, из которой удаляется индекс.</p>
    <p>Конструктор запроса экранирует имя таблицы и имя индекса.</p>
    <p>Пример удаления индекса:</p>

    <pre class="brush: csharp;">
    // DROP INDEX `idx_username` ON `tbl_user`
    dropIndex('idx_username', 'tbl_user')
    </pre>

	<script src="../../../../js/progressBarSetIni.js" type="text/javascript"></script>

        <div id="lessMenu" style="margin: 30px 0 0 0;">
            <hr />
            <a href="24.html"><div id="exitLess" ontouchstart="return true;"><img src="../../../../img/menu/pr.png" /></div></a>
            <a href="26.html"><div id="aaLess" ontouchstart="return true;"><img src="../../../../img/menu/ne.png" /></div></a>
        </div>

    </div>

    <script type="text/javascript" src="../../../../cordova.js"></script>
    <script type="text/javascript" src="../../../../js/global.js"></script>
    <script type="text/javascript">
        changeColor();
        if (localStorage.getItem("fSize") < 1) { fSize = 16; localStorage.setItem("fSize", 16); } else { fSize = localStorage.getItem("fSize"); }
        document.getElementById("pageBody").style.fontSize = fSize + "px";

        // goBackMenu
        document.addEventListener("backbutton", goBackMenu, false);
        function goBackMenu()
        {
            window.location.href = 'list.html';
        }

        function changeColor()
        {
            if (localStorage.getItem("colorSheme") <= 1)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#f0f0f0");
            }

            if (localStorage.getItem("colorSheme") == 2)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#212121");
                document.getElementById("pageBody").style.color = localStorage.getItem("#efefef");
            }

            if (localStorage.getItem("colorSheme") == 3)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#efe4d0");
            }
        }

        // bm
        if (localStorage.getItem("arrs") != null)
        {
            var arrs = JSON.parse(localStorage.getItem("arrs"));
        }
        else
        {
            var arrs = [];
        }

        var names = ["../acharter/ru/yii/yii/25.html", "Конструктор запросов Yii", "bm1176"];

        function setzBm() { arrs.push(names); localStorage.setItem("arrs", JSON.stringify(arrs)); localStorage.setItem("bm1176", 1); RefBms(); }

        window.onload = function() { RefBms(); }

        function RefBms()
        {
            if (localStorage.getItem("bm1176") == 1) { document.getElementById("bma1176").style.display = "block"; document.getElementById("bm1176").style.display = "none"; } else { document.getElementById("bma1176").style.display = "none"; document.getElementById("bm1176").style.display = "block"; }
        }

        function dellBm() { for (var i = 0; i < arrs.length; i++) { if (arrs[i].indexOf("Конструктор запросов Yii") == 1) { arrs.splice(i, 1); localStorage.setItem("bm1176", 0); RefBms(); localStorage.setItem("arrs", JSON.stringify(arrs)); } } }

        // sub menu
        var serTimeToClose = 1000;
        
        function OpenSettMenu()
        {
            document.getElementById("subMenuInLess").style.display = "block";
            timeToEvAct();
            serTimeToClose = 1;
        }
        
        function timeToEvAct()
        {
            setTimeout(function() { serTimeToClose = 0 }, 100);
        }
        
        window.addEventListener('click', function(e){
        
            if (serTimeToClose <= 0)
            {
                if (document.getElementById('subMenuInLess').contains(e.target))
                {
                    //
                }
                else
                {
                    document.getElementById("subMenuInLess").style.display = "none";
                }
            }
        });

    </script>

</body>
</html>
