
<!DOCTYPE html>

<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <link rel="stylesheet" type="text/css" href="../../../../css/read.css" />
    <title>Coder Book menu</title>
    <script type="text/javascript" src="../../../../higtline/scripts/shCore.js"></script>
    <script type="text/javascript" src="../../../../higtline/scripts/shBrushCSharp.js"></script>
    <link type="text/css" rel="stylesheet" href="../../../../higtline/styles/shCoreDefault.css"/>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <script src="../../../../js/Hyphenator.js" type="text/javascript"></script>
</head>

<body id="pageBody" class="hyphenate">

<!-- progress bar -->
<script src="../../../../js/progressBar.js" type="text/javascript"></script>
<div class="Reading-progress" id="progressBarType1"><span id="Progress-bar-top" class="bar-top" style="display: block !important;"></span></div>
<div class="Reading-progress" id="progressBarType2"><span id="Progress-bar-bottom" class="bar-bottom"></span></div>
<div class="Reading-progress" id="progressBarType3"><span id="Progress-bar-left" class="bar-left"></span></div>
<div class="Reading-progress" id="progressBarType4"><span id="Progress-bar-right" class="bar-right"></span></div>
<!-- progress bar -->


    <div id="lesonPage">

        <div id="lessMenu">
           <a id="exitLess" href="list.html" ontouchstart="return true;"><img src="../../../../img/menu/ex.png" /></a>
           <div id="aaLess" ontouchstart="return true;" onclick="OpenSettMenu();"><img src="../../../../img/menu/aa.png" /></div>
           <div id="subMenuInLess" style="display: none;">
                <a href="../../../../menu/setfontsize-ru.html" ontouchstart="return true;" id="pastMenuInLess">Размер текста</a>
                <a href="../../../../menu/setcolor-ru.html" ontouchstart="return true;" id="pastMenuInLess">Цветовая темы</a>
                <a href="../../../../menu/setProgressBar-ru.html" ontouchstart="return true;" id="pastMenuInLess" style="border: none;">Прогресс бар</a>
           </div>
           <div id="aaLess" ontouchstart="return true;">
            <div class="bmEdit" onclick="dellBm();" id="bma1094" ontouchstart="return true;" style="display: none;"><img src="../../../../img/menu/bmlessa.png" /></div>
            <div class="bmEdit" onclick="setzBm();" id="bm1094" ontouchstart="return true;" style="display: block;"><img src="../../../../img/menu/bmless.png" /></div>
           </div>
        </div>

        <hr />

	<!-- ПОЧАТОК -->

	<h1 id="title">
		Что такое ограничения
	</h1>

	<p>Было разработано много версий языка SQL, прежде чем он стал столь полноценным и мощным.</p>
	<p>Многие из наиболее эффективных инструментов манипуляции с данными основаны на таких методах, которые обеспечиваются с помощью ограничений.</p>
	<p>И реляционные таблицы, и целостность на уровне ссылок несколько раз упоминались в предыдущих уроках.</p>
	<p>В них, в частности, говорилось, что реляционные базы данных хранят данные во многих таблицах, каждая из которых содержит данные, связанные с данными из других таблиц.</p>
	<p>Для создания ссылок из одной таблицы на другие используются ключи (отсюда термин целостность на уровне ссылок).</p>
	<p>Чтобы реляционная база данных работала должным образом, необходимо удостовериться в том, что данные в ее таблицы введены правильно.</p>
	<p>Например, если в таблице Orders хранится информация о заказе, а в Order Items — его детальное описание, вы должны быть уверены, что все идентификаторы заказов, упомянутые в таблице OrderItems, существуют и в таблице Orders.</p>
	<p>Аналогично, каждый клиент, упомянутый в таблице Orders, не должен быть забыт и в таблице Customers.</p>
	<p>Хотя вы можете проводить соответствующие проверки, прежде чем вводить новые строки (выполняя оператор SELECT для другой таблицы, дабы удостовериться в том, что нужные значения правильны), лучше избегать такой практики по следующим причинам.</p>
	<p>Если правила, обеспечивающие целостность базы данных, принудительно осуществляются на клиентском уровне, их придется выполнять каждому клиенту (некоторые из клиентов наверняка не захотят этого делать).</p>
	<p>Вам придется принудительно ввести правила для выполнения операций UPDATE и DELETE.</p>
	<p>Выполнение проверок на клиентской стороне — процесс, отнимающий много времени.</p>
	<p>Заставить СУБД выполнять эти проверки — метод намного более эффективный.</p>
	<p><b>Ограничения</b></p>
	<p>Правила, регламентирующие ввод данных в базу данных и манипуляцию ими.</p>
	<p>СУБД принудительно обеспечивают целостность на уровне ссылок за счет ограничений, налагаемых на таблицы базы данных.</p>
	<p>Большинство ограничений вводится в определениях таблиц (с помощью операторов CREATE TABLE или ALTER TABLE, об этом рассказывалось в уроке "Создание таблиц и работа с ними").</p>
	<p><b>Предупреждение</b></p>
	<p>Существует несколько типов ограничений, и каждая СУБД обеспечивает свой собственный уровень их поддержки.</p>
	<p>Следовательно, примеры, приведенные ниже, могут работать не так, как вы предполагаете.</p>
	<p>Обратитесь к документации своей СУБД, прежде чем выполнять их.</p>

	<h1 id="title">
		Первичные ключи
	</h1>

	<p>О первичных ключах мы рассказывали в уроке "Что такое SQL".</p>
	<p>Первичный ключ — это особое ограничение, применяемое для того, чтобы значения в столбце (или наборе столбцов) были уникальными и никогда не изменялись.</p>
	<p>Другими словами, это столбец (или столбцы) таблицы, значения которого однозначно идентифицируют каждую строку таблицы.</p>
	<p>Это облегчает непосредственное манипулирование отдельными строками и взаимодействие с ними.</p>
	<p>Без первичных ключей было бы очень трудно обновлять или удалять определенные строки, не задевая при этом другие.</p>
	<p>Любой столбец таблицы может быть назначен на роль первичного ключа, но только если он удовлетворяет следующим условиям.</p>
	<p>- Никакие две строки не могут иметь одно и то же значение первичного ключа.</p>
	<p>- Каждая строка должна иметь какое-то значение первичного ключа. (В таких столбцах не должно быть разрешено использование значений NULL.)</p>
	<p>- Столбец, содержащий значения первичного ключа, не может быть модифицирован или обновлен.</p>
	<p>- Значения первичного ключа ни при каких обстоятельствах не могут быть использованы повторно.</p>
	<p>Если какая-то строка удалена из таблицы, ее первичный ключ не может быть назначен какой-то другой строке.</p>
	<p>Одним из способов определения первичных ключей является их создание:</p>
	<p><b>ВВОД</b></p>

	<pre class="brush: csharp;">
	CREATE TABLE Vendors
	(
		vend_id CHAR(10) NOT NULL PRIMARY КЕУ,
		vend_name CHAR(50) NOT NULL,
		vend_address CHAR(50) NULL,
		vend_city CHAR(50) NULL,
		vend_state CHAR(5) NULL,
		vend_ZIP CHAR(IO) NULL
		vend_country CHAR(50) NULL
	);
	</pre>

	<p><b>Анализ</b></p>
	<p>В этом примере в определение таблицы добавлено ключевое слово PRIMARY KEY, так что столбец vend_id становится первичным ключом.</p>
	<p><b>ВВОД</b></p>

	<pre class="brush: csharp;">
	ALTER TABLE Vendors
	ADD CONSTRAINT PRIMARY KEY (vend_id);
	</pre>

	<p><b>Анализ</b></p>
	<p>Здесь в качестве первичного ключа определен тот же самый столбец, но использован синтаксис CONSTRAINT.</p>
	<p>Этот синтаксис может быть использован в операторах CREATE TABLE и ALTER TABLE.</p>

	<h1 id="title">
		Внешние ключи
	</h1>

	<p>Внешний ключ — это столбец одной таблицы, значения которого совпадают со значениями столбца, являющегося первичным ключом другой таблицы.</p>
	<p>Внешние ключи — очень важная часть механизма обеспечения ссылочной целостности данных.</p>
	<p>Чтобы разобраться в том, что собой представляют внешние ключи, рассмотрим следующий пример.</p>
	<p>Таблица Orders содержит единственную строку для каждого заказа, зафиксированного в базе данных.</p>
	<p>Информация о клиенте хранится в таблице Customers.</p>
	<p>Заказы в таблице Orders связаны с определенными строками в таблице Customers за счет идентификатора клиента.</p>
	<p>Идентификатор клиента является первичным ключом в таблице Customers; каждый клиент имеет уникальный идентификатор.</p>
	<p>Номер заказа является первичным ключом в таблице Orders; каждый заказ имеет свой уникальный номер.</p>
	<p>Значения в столбце таблицы Orders, содержащем идентификаторы клиентов, не обязательно уникальные.</p>
	<p>Если клиент сделал несколько заказов, может быть несколько строк с тем же самым идентификатором клиента (хотя каждая из них будет иметь свой номер заказа).</p>
	<p>В то же время единственные значения, которые могут появиться в столбце идентификаторов клиента таблицы Orders, — это идентификаторы клиентов из таблицы Customers.</p>
	<p>Именно так и образуются внешние ключи.</p>
	<p>В нашем примере внешний ключ определен как столбец идентификаторов клиента, содержащихся в первичном ключе таблицы Customers, так что этот столбец может принимать только значения, имеющиеся в первичном ключе таблицы Customers.</p>
	<p>Вот один из способов определения внешнего ключа:</p>
	<p><b>ВВОД</b></p>

	<pre class="brush: csharp;">
	CREATE TABLE Orders
	(
		order_num INTEGER NOT NULL PRIMARY KEY,
		order_date DATETIME NOT NOLL,
		cust_id CHAR (10) NOT NULL REFERENCES
		Customers(cust_id)
	);
	</pre>

	<p><b>Анализ</b></p>
	<p>Это определение таблицы, использующее ключевое слово REFERENCES для утверждения того факта, что любое значение в столбце cust_id должно быть также и в столбце cust_id таблицы Customers.</p>
	<p>Того же результата можно было бы добиться с использованием синтаксиса CONSTRAINT в операторе ALTER TABLE:</p>
	<p><b>ВВОД</b></p>

	<pre class="brush: csharp;">
	ALTER TABLE Customers
	ADD CONSTRAINT
	FOREIGN KEY (cust id) REFERENCES Customers (cust id)
	</pre>

	<p><b>Внешние ключи могут воспрепятствовать случайному удалению данных</b></p>
	<p>В дополнение к тому, что внешние ключи помогают принудительно сохранять целостность ссылочных данных, они могут выполнять много других важных функций.</p>
	<p>После того как внешний ключ определен, ваша СУБД не позволит удалять строки, связанные со строками в других таблицах.</p>
	<p>Например, вы не сможете удалить информацию о клиенте, у которого есть заказы.</p>
	<p>Единственный способ удалить информацию о таком клиенте состоит в предварительном удалении связанных с ним заказов (для чего, в свою очередь, нужно удалить информацию о предметах этих заказов).</p>
	<p>Поскольку требуется столь методичное и целенаправленное удаление, внешние ключи могут оказать помощь в предотвращении случайного удаления данных.</p>
	<p>Однако в некоторых СУБД поддерживается возможность, получившая название каскадное удаление.</p>
	<p>Если такая функция реализована, можно удалять все связанные с этой строкой данные при удалении ее из таблицы.</p>
	<p>Например, если возможно каскадное удаление и имя клиента удаляется из таблицы Customers, все связанные с его заказом строки удаляются автоматически.</p>

	<h1 id="title">
		Ограничения уникальности
	</h1>

	<p>Ограничения уникальности обеспечивают уникальность всех данных в столбце (или в наборе столбцов).</p>
	<p>Такие столбцы похожи на первичные ключи, но имеются и важные отличия.</p>
	<p>- Таблица может содержать множество ограничений уникальности, но у нее должен быть только один первичный ключ.</p>
	<p>- Столбцы с ограничением уникальности могут содержать значения NULL.</p>
	<p>- Столбцы с ограничением уникальности можно модифицировать и обновлять.</p>
	<p>- Значения столбцов с ограничением уникальности можно использовать повторно.</p>
	<p>- В отличие от первичных ключей, ограничения уникальности не могут быть использованы для определения внешних ключей.</p>
	<p>Примером использования ограничения может служить таблица с данными о служащих.</p>
	<p>Каждый из них имеет свой уникальный номер карточки социального страхования, но вы вряд ли будете использовать его в качестве первичного ключа, поскольку он слишком длинный (и, кроме того, вы вряд ли захотите сделать эту информацию легко доступной).</p>
	<p>Поэтому каждому служащему присваивается уникальный идентификатор (первичный ключ) в дополнение к его номеру карточки социального страхования.</p>
	<p>Поскольку идентификатор служащего является первичным ключом, вы можете быть уверены в том, что он уникален.</p>
	<p>К примеру, для того чтобы СУБД проверила уникальность каждого номера карточки социального страхования (дабы вы могли убедиться в том, что не произошла ошибка при вводе и для одного служащего не указали номер карточки другого), нужно определить ограничение UNIQUE для столбца, в котором содержатся номера карточек социального страхования.</p>
	<p>Синтаксис ограничения на уникальность похож на синтаксис других ограничений: при определении таблицы указывается ключевое слово UNIQUE или отдельно используется ограничение CONSTRAINT.</p>

	<h1 id="title">
		Ограничения на значения столбца
	</h1>

	<p>Ограничения на значения столбца используют для того, чтобы данные в столбце (или наборе столбцов) соответствовали ряду определенных вами критериев.</p>
	<p>Наиболее часто используемыми из них являются следующие: </p>
	<p>- Ограничение максимального и минимального значений — например, для предотвращения появления заказов на 0 (нуль) предметов (хотя 0 и является допустимым числом).</p>
	<p>- Указание диапазонов — например, ограничение на то, чтобы дата отгрузки наступала позже или соответствовала текущей дате и не отстояла от нее больше, чем на год. </p>
	<p>- Разрешение только определенных значений — например, разрешение вводить в поле "пол" только буквы М или F.</p>
	<p>Типы данных (см. урок 1) ограничивают типы данных, которые могут храниться в столбце.</p>
	<p>Ограничения на значения столбца предъявляют дополнительные требования уже к данным определенного типа.</p>
	<p>В следующем примере накладывается ограничение на значения столбцов таблицы OrderItems с тем, чтобы для всех предметов указывалось количество, большее 0:</p>
	<p><b>ВВОД</b></p>

	<pre class="brush: csharp;">
	CREATE TABLE OrderItems
	(
		order_num INTEGER NOT NULL,
		order item INTEGER NOT NULL,
		prod_id CHAR(10) NOT NULL,
		quantity INTEGER NOT NULL CHECK
		(quantity > 0),
		item_price MONEY NOT NULL
	);
	</pre>

	<p><b>Анализ</b></p>
	<p>После применения этого ограничения каждая добавляемая (или обновляемая) строка будет проверяться на предмет того, что количество предметов больше нуля.</p>
	<p>Чтобы проконтролировать тот факт, что в столбце с наименованием пола может содержаться только буква М или F, можно сделать следующее в операторе ALTER TABLE:</p>
	<p><b>ВВОД</b></p>

	<pre class="brush: csharp;">
	ADD CONSTRAINT CHECK (gender LIKE ' [MF] ')
	</pre>

	<p><b>Пользовательские типы данных</b></p>
	<p>Пользователи некоторых СУБД могут определять собственные типы данных.</p>
	<p>Обычно это весьма простые типы данных, определенные с контрольными (или другими) ограничениями.</p>
	<p>Например, вы можете определить свой тип данных, назвав его gender (пол); он будет представлять собой тип данных, состоящих из одной буквы с ограничением на значения столбца, допускающим для этих данных только два значения, M или F (и, возможно, NULL, если пол служащего неизвестен).</p>
	<p>Вы могли бы использовать этот тип данных в определениях таблиц.</p>
	<p>Преимущество пользовательских типов данных состоит в том, что такие ограничения могут быть определены только один раз (в определении типа данных), а потом они будут автоматически применяться каждый раз, когда будет использован пользовательский тип данных.</p>
	<p>Посмотрите в документации своей СУБД, поддерживает ли она пользовательские типы данных.</p>

	<script src="../../../../js/progressBarSetIni.js" type="text/javascript"></script>

        <div id="lessMenu" style="margin: 30px 0 0 0;">
            <hr />
            <a href="79.html"><div id="exitLess" ontouchstart="return true;"><img src="../../../../img/menu/pr.png" /></div></a>
            <a href="81.html"><div id="aaLess" ontouchstart="return true;"><img src="../../../../img/menu/ne.png" /></div></a>
        </div>

    </div>

    <script type="text/javascript" src="../../../../cordova.js"></script>
    <script type="text/javascript" src="../../../../js/global.js"></script>
    <script type="text/javascript">
        changeColor();
        if (localStorage.getItem("fSize") < 1) { fSize = 16; localStorage.setItem("fSize", 16); } else { fSize = localStorage.getItem("fSize"); }
        document.getElementById("pageBody").style.fontSize = fSize + "px";

        // goBackMenu
        document.addEventListener("backbutton", goBackMenu, false);
        function goBackMenu()
        {
            window.location.href = 'list.html';
        }

        function changeColor()
        {
            if (localStorage.getItem("colorSheme") <= 1)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#f0f0f0");
            }

            if (localStorage.getItem("colorSheme") == 2)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#212121");
                document.getElementById("pageBody").style.color = localStorage.getItem("#efefef");
            }

            if (localStorage.getItem("colorSheme") == 3)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#efe4d0");
            }
        }

        // bm
        if (localStorage.getItem("arrs") != null)
        {
            var arrs = JSON.parse(localStorage.getItem("arrs"));
        }
        else
        {
            var arrs = [];
        }

        var names = ["../acharter/ru/sql/book/80.html", "Что такое ограничения", "bm1094"];

        function setzBm() { arrs.push(names); localStorage.setItem("arrs", JSON.stringify(arrs)); localStorage.setItem("bm1094", 1); RefBms(); }

        window.onload = function() { RefBms(); }

        function RefBms()
        {
            if (localStorage.getItem("bm1094") == 1) { document.getElementById("bma1094").style.display = "block"; document.getElementById("bm1094").style.display = "none"; } else { document.getElementById("bma1094").style.display = "none"; document.getElementById("bm1094").style.display = "block"; }
        }

        function dellBm() { for (var i = 0; i < arrs.length; i++) { if (arrs[i].indexOf("Что такое ограничения") == 1) { arrs.splice(i, 1); localStorage.setItem("bm1094", 0); RefBms(); localStorage.setItem("arrs", JSON.stringify(arrs)); } } }

        // sub menu
        var serTimeToClose = 1000;
        
        function OpenSettMenu()
        {
            document.getElementById("subMenuInLess").style.display = "block";
            timeToEvAct();
            serTimeToClose = 1;
        }
        
        function timeToEvAct()
        {
            setTimeout(function() { serTimeToClose = 0 }, 100);
        }
        
        window.addEventListener('click', function(e){
        
            if (serTimeToClose <= 0)
            {
                if (document.getElementById('subMenuInLess').contains(e.target))
                {
                    //
                }
                else
                {
                    document.getElementById("subMenuInLess").style.display = "none";
                }
            }
        });

    </script>

</body>
</html>
