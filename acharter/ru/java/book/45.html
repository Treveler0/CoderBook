

<!DOCTYPE html>

<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <link rel="stylesheet" type="text/css" href="../../../../css/read.css" />
    <title>Coder Book menu</title>
    <script type="text/javascript" src="../../../../higtline/scripts/shCore.js"></script>
    <script type="text/javascript" src="../../../../higtline/scripts/shBrushCSharp.js"></script>
    <link type="text/css" rel="stylesheet" href="../../../../higtline/styles/shCoreDefault.css"/>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <script src="../../../../js/Hyphenator.js" type="text/javascript"></script>
</head>

<body id="pageBody" class="hyphenate">

<!-- progress bar -->
<script src="../../../../js/progressBar.js" type="text/javascript"></script>
<div class="Reading-progress" id="progressBarType1"><span id="Progress-bar-top" class="bar-top" style="display: block !important;"></span></div>
<div class="Reading-progress" id="progressBarType2"><span id="Progress-bar-bottom" class="bar-bottom"></span></div>
<div class="Reading-progress" id="progressBarType3"><span id="Progress-bar-left" class="bar-left"></span></div>
<div class="Reading-progress" id="progressBarType4"><span id="Progress-bar-right" class="bar-right"></span></div>
<!-- progress bar -->


    <div id="lesonPage">

        <div id="lessMenu">
           <a id="exitLess" href="list.html" ontouchstart="return true;"><img src="../../../../img/menu/ex.png" /></a>
           <div id="aaLess" ontouchstart="return true;" onclick="OpenSettMenu();"><img src="../../../../img/menu/aa.png" /></div>
           <div id="subMenuInLess" style="display: none;">
                <a href="../../../../menu/setfontsize-ru.html" ontouchstart="return true;" id="pastMenuInLess">Размер текста</a>
                <a href="../../../../menu/setcolor-ru.html" ontouchstart="return true;" id="pastMenuInLess">Цветовая темы</a>
                <a href="../../../../menu/setProgressBar-ru.html" ontouchstart="return true;" id="pastMenuInLess" style="border: none;">Прогресс бар</a>
           </div>
           <div id="aaLess" ontouchstart="return true;">
            <div class="bmEdit" onclick="dellBm();" id="bma646" ontouchstart="return true;" style="display: none;"><img src="../../../../img/menu/bmlessa.png" /></div>
            <div class="bmEdit" onclick="setzBm();" id="bm646" ontouchstart="return true;" style="display: block;"><img src="../../../../img/menu/bmless.png" /></div>
           </div>
        </div>

        <hr />

	<!-- ПОЧАТОК -->

	<h1 id="title">
		Массивы как тип данных в Java
	</h1>

	<p>В отличие от обычных переменных, которые хранят только одно значение, массивы (arrays) используются для хранения целого набора значений.</p>
	<p>Количество значений в массиве называется его длиной, сами значения – элементами массива.</p>
	<p>Значений может не быть вовсе, в этом случае массив считается пустым, а его длина равной нулю.</p>
	<p>Элементы не имеют имен, доступ к ним осуществляется по номеру индекса.</p>
	<p>Если массив имеет длину n, отличную от нуля, то корректными значениями индекса являются числа от 0 до n-1.</p>
	<p>Все значения имеют одинаковый тип и говорится, что массив основан на этом базовом типе.</p>
	<p>Массивы могут быть основаны как на примитивных типах (например, для хранения числовых значений 100 измерений), так и на ссылочных (например, если нужно хранить описание 100 автомобилей в гараже в виде экземпляров класса Car ).</p>
	<p>Сразу оговоримся, что в Java массив символов char[] и класс String являются различными типами.</p>
	<p>Их значения могут легко конвертироваться друг в друга с помощью специальных методов, но все же они не относятся к идентичным типам.</p>
	<p>Как уже говорилось, массивы в Java являются объектами (примитивных типов в Java всего восемь и их количество не меняется), их тип напрямую наследуется от класса Object, поэтому все элементы данного класса доступны у объектов-массивов.</p>
	<p>Базовый тип также может быть массивом.</p>
	<p>Таким образом конструируется массив массивов, или многомерный массив.</p>
	<p>Работа с любым массивом включает обычные операции, уже описанные для других типов, - объявление, инициализация и т.д.</p>
	<p>Начнем последовательно изучать их в приложении к массивам.</p>

	<h1 id="title">
		Объявление массивов
	</h1>

	<p>В качестве примера рассмотрим объявление переменной типа "массив, основанный на примитивном типе int":</p>

	<pre class="brush: csharp;">
	int a[];
	</pre>

	<p>Как мы видим, сначала указывается базовый тип.</p>
	<p>Затем идет имя переменной, а пара квадратных скобок указывает на то, что используемый тип является именно массивом.</p>
	<p>Также допустима запись:</p>

	<pre class="brush: csharp;">
	int[] a;
	</pre>

	<p>Количество пар квадратных скобок указывает на размерность массива.</p>
	<p>Для многомерных массивов допускается смешанная запись:</p>

	<pre class="brush: csharp;">
	int[] a[];
	</pre>

	<p>Переменная a имеет тип "двумерный массив, основанный на int".</p>
	<p>Аналогично объявляются массивы с базовым объектным типом:</p>

	<pre class="brush: csharp;">
	Point p, p1[], p2[][];
	</pre>

	<p>Создание переменной типа массив еще не создает экземпляры этого массива.</p>
	<p>Такие переменные имеют объектный тип и хранят ссылки на объекты, однако изначально имеют значение null (если они являются полями класса; напомним, что локальные переменные необходимо явно инициализировать).</p>
	<p>Чтобы создать экземпляр массива, нужно воспользоваться ключевым словом new, после чего указывается тип массива и в квадратных скобках – длина массива.</p>

	<pre class="brush: csharp;">
	int a[]=new int[5];
	Point[] p = new Point[10];
	</pre>

	<p>Переменная инициализируется ссылкой, указывающей на только что созданный массив.</p>
	<p>После его создания можно обращаться к элементам, используя ссылку на массив, далее в квадратных скобках указывается индекс элемента.</p>
	<p>Индекс меняется от нуля, пробегая всю длину массива, до максимально допустимого значения, на единицу меньшего длины массива.</p>

	<pre class="brush: csharp;">
	int array[]=new int[5];
	
	for (int i=0; i&lt;5; i++)
	{
		array[i]=i*i;
	}
	for (int j=0; j&lt;5; j++)
	{
		System.out.println(j+"*"+j+"="+array[j]);
	}
	</pre>

	<p>Результатом выполнения программы будет:</p>

	<pre class="brush: csharp;">
	0*0=0
	1*1=1
	2*2=4
	3*3=9
	4*4=16
	</pre>

	<p>Если бы индекс превысил максимально возможное для такого массива значение, то появилась бы ошибка времени исполнения.</p>
	<p>Проверка, не выходит ли индекс за допустимые пределы, происходит только во время исполнения программы, т.е. компилятор не пытается выявить эту ошибку даже в таких явных случаях, как:</p>

	<pre class="brush: csharp;">
	int i[]=new int[5];
	// ошибка! индекс не может быть отрицательным
	i[-2]=0;
	</pre>

	<p>Ошибка возникнет только на этапе выполнения программы.</p>
	<p>Хотя при создании массива необходимо указывать его длину, это значение не входит в определение типа массива, важна лишь размерность.</p>
	<p>Таким образом, одна переменная может ссылаться на массивы разной длины:</p>

	<pre class="brush: csharp;">
	int i[]=new int[5];
	...
	// переменная та же, длина массива другая
	i=new int[7];
	</pre>

	<p>Однако для объекта массива длина обязательно должна указываться при создании и уже никак не может быть изменена.</p>
	<p>В последнем примере для присвоения переменной ссылки на массив большей длины потребовалось создать новый экземпляр.</p>
	<p>Поскольку для экземпляра массива длина является постоянной характеристикой, для всех массивов существует специальное поле length, позволяющее узнать ее значение.</p>
	<p>Например:</p>

	<pre class="brush: csharp;">
	Point p[]=new Point[5];
	
	for (int i=0; i&lt;p.length; i++)
	{
		p[i]=new Point(i, i);
	}
	</pre>

	<p>Значение индекса массива всегда имеет тип int.</p>
	<p>При обращении к элементу можно также использовать byte, short или char, поскольку эти типы автоматически расширяются до int.</p>
	<p>Попытка задействовать long приведет к ошибке компиляции.</p>
	<p>Соответственно, и поле length имеет тип int, а теоретическая максимально возможная длина массива равняется 231-1, то есть немногим больше 2 млрд.</p>
	<p>Продолжая рассматривать тип массива, подчеркнем, что в качестве базового типа может использоваться любой тип Java, в том числе:</p>
	<p><b>* интерфейсы.</b> В таком случае элементы массива могут иметь значение null или ссылаться на объекты любого класса, реализующего этот интерфейс;</p>
	<p><b>* абстрактные классы.</b> В этом случае элементы массива могут иметь значение null или ссылаться на объекты любого неабстрактного класса-наследника.</p>
	<p>Поскольку массив является объектным типом данных, его значения могут быть приведены к типу Object или, что то же самое, присвоены переменной типа Object.</p>
	<p>Например,</p>

	<pre class="brush: csharp;">
	Object o = new int[4];
	</pre>

	<p>Это дает интересную возможность для массивов, основанных на типе Object, хранить в качестве элемента ссылку на самого себя:</p>

	<pre class="brush: csharp;">
	Object arr[] = new Object[3];
	arr[0]=new Object();
	arr[1]=null;
	// Элемент ссылается на весь массив!
	arr[2]=arr;
	</pre>

	<h1 id="title">
		Инициализация массивов
	</h1>

	<p>Теперь, когда мы выяснили, как создавать экземпляры массива, рассмотрим, какие значения принимают его элементы.</p>
	<p>Если создать массив на основе примитивного числового типа, то изначально после создания все элементы массива имеют значение по умолчанию, то есть 0.</p>
	<p>Если массив объявлен на основе примитивного типа boolean, то и в этом случае все элементы будут иметь значение по умолчанию false.</p>
	<p>Выше рассматривался пример инициализации элементов с помощью цикла for.</p>
	<p>Рассмотрим создание массива на основе ссылочного типа.</p>
	<p>Предположим, это будет класс Point.</p>
	<p>При создании экземпляра массива с применением ключевого слова new не создается ни один объект класса Point, создается лишь один объект массива.</p>
	<p>Каждый элемент массива будет иметь пустое значение null.</p>
	<p>В этом можно убедиться на простом примере:</p>

	<pre class="brush: csharp;">
	Point p[]=new Point[5];

	for (int i=0; i&lt;p.length; i++)
	{
		System.out.println(p[i]);
	}
	</pre>

	<p>Результатом будут лишь слова null.</p>
	<p>Далее нужно инициализировать элементы массива по отдельности, например, в цикле.</p>
	<p>Вообще, создание массива длиной n можно рассматривать как заведение n переменных и работать с элементами массива (в последнем примере p[i] ) по правилам обычных переменных.</p>
	<p>Кроме того, существует и другой способ создания массивов – инициализаторы.</p>
	<p>В этом случае ключевое слово new не используется, а ставятся фигурные скобки, и в них через запятую перечисляются значения всех элементов массива.</p>
	<p>Например, для числового массива явная инициализация записывается следующим образом:</p>

	<pre class="brush: csharp;">
	int i[]={1, 3, 5};
	// эквивалентно new int[0]
	int j[]={};
	</pre>

	<p>Длина массива вычисляется автоматически, исходя из количества введенных значений.</p>
	<p>Далее создается массив такой длины и каждому его элементу присваивается указанное значение.</p>
	<p>Аналогично можно порождать массивы на основе объектных типов, например:</p>

	<pre class="brush: csharp;">
	Point p=new Point(1,3);
	Point arr[]={p, new Point(2,2), null, p};
	// или
	String sarr[]={"aaa", "bbb", "cde"+"xyz"};
	</pre>

	<p>Однако инициализатор нельзя использовать для анонимного создания экземпляров массива, то есть не для инициализации переменной, а, например, для передачи параметров метода или конструктора.</p>
	<p>Например:</p>

	<pre class="brush: csharp;">
	public class Parent
	{
		private String[] values;
		
		protected Parent(String[] s)
		{
			values=s;
		}
	}
	
	public class Child extends Parent
	{
		public Child(String firstName,
		
		String lastName)
		{
			super(???);
			// требуется анонимное создание массива
		}
	}
	</pre>

	<p>В конструкторе класса Child необходимо осуществить обращение к конструктору родителя и передать в качестве параметра ссылку на массив.</p>
	<p>Теоретически можно передать null, но это приведет в большинстве случаев к некорректной работе классов.</p>
	<p>Можно вставить выражение new String[2], но тогда вместо значений firstName и lastName будут переданы пустые строки.</p>
	<p>Попытка записать {firstName, lastName} приведет к ошибке компиляции, так можно только инициализировать переменные.</p>
	<p>Корректное выражение выглядит так:</p>

	<pre class="brush: csharp;">
	new String[]{firstName, lastName}
	</pre>

	<p>Что является некоторой смесью выражения, создающего массивы с помощью new, и инициализатора.</p>
	<p>Длина массива определяется количеством указанных значений.</p>

	<h1 id="title">
		Многомерные массивы
	</h1>

	<p>Теперь перейдем к рассмотрению многомерных массивов.</p>
	<p>Так, в следующем примере</p>

	<pre class="brush: csharp;">
	int i[][]=new int[3][5];
	</pre>

	<p>переменная i ссылается на двумерный массив, который можно представить себе в виде таблицы 3х5.</p>
	<p>Суммарно в таком массиве содержится 15 элементов, к которым можно обращаться через комбинацию индексов от (0, 0) до (2, 4).</p>
	<p>Пример заполнения двумерного массива через цикл:</p>

	<pre class="brush: csharp;">
	int pithagor_table[][]=new int[5][5];
	
	for (int i=0; i&lt;5; i++)
	{
		for (int j=0; j&lt;5; j++)
		{
			pithagor_table[i][j]=i*j;
			System.out.print(pithagor_table[i][j] + "\t");
		}
		
		System.out.println();
	}
	</pre>

	<p>Результатом выполнения программы будет:</p>

	<pre class="brush: csharp;">
	0 0 0 0  0
	0 1 2 3  4
	0 2 4 6  8
	0 3 6 9  12
	0 4 8 12 16
	</pre>

	<p>Однако такой взгляд на двумерные и многомерные массивы является неполным.</p>
	<p>Более точный подход заключается в том, что в Java нет двумерных, и вообще многомерных массивов, а есть массивы, базовыми типами которых являются также массивы.</p>
	<p>Например, тип int[] означает "массив чисел", а int[][] означает "массив массивов чисел".</p>
	<p>Поясним такую точку зрения.</p>
	<p>Если создать двумерный массив и определить переменную x, которая на него ссылается, то, используя x и два числа в паре квадратных скобок каждое (например, x[0][0] ), можно обратиться к любому элементу двумерного массива.</p>
	<p>Но в то же время, используя x и одно число в паре квадратных скобок, можно обратиться к одномерному массиву, который является элементом двумерного массива.</p>
	<p>Его можно проинициализировать новым массивом с некоторой другой длиной и таблица перестанет быть прямоугольной – она примет произвольную форму. В частности, можно одному из одномерных массивов присвоить даже значение null.</p>

	<pre class="brush: csharp;">
	int x[][]=new int[3][5];
	// прямоугольная таблица
	x[0]=new int[7];
	x[1]=new int[0];
	x[2]=null;
	</pre>

	<p>После таких операций массив, на который ссылается переменная x, назвать прямоугольным никак нельзя.</p>
	<p>Зато хорошо видно, что это просто набор одномерных массивов или значений null.</p>
	<p>Полезно подсчитать, сколько объектов порождается выражением new int[3][5].</p>
	<p>Правильный подсчет таков: создается один массив массивов (один объект) и три массива чисел, каждый длиной 5 (три объекта).</p>
	<p>Итого, четыре объекта.</p>
	<p>В рассмотренном примере три из них (массивы чисел) были тут же переопределены новыми значениями.</p>
	<p>Для таких случаев полезно использовать упрощенную форму выражения создания массивов:</p>

	<pre class="brush: csharp;">
	int x[][]=new int[3][];
	</pre>

	<p>Такая запись порождает один объект – массив массивов – и заполняет его значениями null.</p>
	<p>Теперь понятно, что и в этом, и в предыдущем варианте выражение x.length возвращает значение 3 – длину массива массивов.</p>
	<p>Далее можно с помощью выражений x[i].length узнать длину каждого вложенного массива чисел, при условии, что i неотрицательно и меньше x.length, а также x[i] не равно null.</p>
	<p>Иначе будут возникать ошибки во время выполнения программы.</p>
	<p>Вообще, при создании многомерных массивов с помощью new необходимо указывать все пары квадратных скобок, соответственно количеству измерений.</p>
	<p>Но заполненной обязательно должна быть лишь крайняя левая пара, это значение задаст длину верхнего массива массивов.</p>
	<p>Если заполнить следующую пару, то этот массив заполнится не значениями по умолчанию null, а новыми созданными массивами с меньшей на единицу размерностью.</p>
	<p>Если заполнена вторая пара скобок, то можно заполнить третью, и так далее.</p>
	<p>Аналогично, для создания многомерных массивов можно использовать инициализаторы.</p>
	<p>В этом случае применяется столько вложенных фигурных скобок, сколько требуется:</p>

	<pre class="brush: csharp;">
	int i[][] = {{1,2}, null, {3}, {}};
	</pre>

	<p>В этом примере порождается четыре объекта.</p>
	<p>Это, во-первых, массив массивов длиной 4, а во-вторых, три массива чисел с длинами 2, 1, 0, соответственно.</p>
	<p>Все рассмотренные примеры и утверждения одинаково верны для многомерных массивов, основанных как на примитивных, так и на ссылочных типах.</p>

	<h1 id="title">
		Класс массива
	</h1>

	<p>Поскольку массив является объектным типом данных, можно попытаться представить себе, как выглядело бы объявление класса такого типа.</p>
	<p>На самом деле эти объявления не хранятся в файлах, или еще каком-нибудь формате.</p>
	<p>Учитывая, что массив может быть объявлен на основе любого типа и иметь произвольную размерность, это физически невыполнимо, да и не требуется.</p>
	<p>Вместо этого во время выполнения приложения виртуальная машина генерирует эти объявления динамически на основе базового типа и размерности, а затем они хранятся в памяти в виде таких же экземпляров класса Class, как и для любых других типов.</p>
	<p>Рассмотрим гипотетическое объявление класса для массива, основанного на неком объектном типе Element.</p>
	<p>Объявление класса начинается с перечисления модификаторов, среди которых особую роль играют модификаторы доступа.</p>
	<p>Класс массива будет иметь такой же уровень доступа, как и базовый тип.</p>
	<p>То есть если Element объявлен как public -класс, то и массив будет иметь уровень доступа public.</p>
	<p>Для любого примитивного типа класс массива будет public. Можно также указать модификатор final, поскольку никакой класс не может наследоваться от класса массива.</p>
	<p>Затем следует имя класса, на котором можно подробно не останавливаться, т.к. к типу массива обращение идет не по его имени, а по имени базового типа и набору квадратных скобок.</p>
	<p>Затем нужно указать родительский класс. Все массивы наследуются напрямую от класса Object.</p>
	<p>Далее перечисляются интерфейсы, которые реализует класс.</p>
	<p>Для массива это будут интерфейсы Cloneable и Serializable.</p>
	<p>Первый из них подробно рассматривается в конце этой лекции, а второй будет описан в следующих лекциях.</p>
	<p>Тело класса содержит объявление одного public final поля length типа int. Кроме того, переопределен метод clone() для поддержки интерфейса Cloneable.</p>
	<p>Сведем все вышесказанное в формальную запись класса:</p>

	<pre class="brush: csharp;">
	[public] class A implements Cloneable,
	java.io.Serializable
	{
		public final int length;
		
		// инициализируется при создании
		public Object clone()
		{
			try { return super.clone();}
			catch (CloneNotSupportedException e)
			{
				throw new InternalError(e.getMessage());
			}
		}
	}
	</pre>

	<p>Таким образом, экземпляр типа массив является полноценным объектом, который, в частности, наследует все методы, определенные в классе Object, например, toString(), hashCode() и остальные.</p>
	<p>Например:</p>

	<pre class="brush: csharp;">
	// результат работы метода toString()
	System.out.println(new int[3]);
	System.out.println(new int[3][5]);
	System.out.println(new String[2]);

	// результат работы метода hashCode()
	System.out.println(new float[2].hashCode());
	</pre>

	<p>Результатом выполнения программы будет:</p>

	<pre class="brush: csharp;">
	[I@26b249
	[[I@82f0db
	[Ljava.lang.String;@92d342
	7051261
	</pre>

	<script src="../../../../js/progressBarSetIni.js" type="text/javascript"></script>

        <div id="lessMenu" style="margin: 30px 0 0 0;">
            <hr />
            <a href="44.html"><div id="exitLess" ontouchstart="return true;"><img src="../../../../img/menu/pr.png" /></div></a>
            <a href="46.html"><div id="aaLess" ontouchstart="return true;"><img src="../../../../img/menu/ne.png" /></div></a>
        </div>

    </div>

    <script type="text/javascript" src="../../../../cordova.js"></script>
    <script type="text/javascript" src="../../../../js/global.js"></script>
    <script type="text/javascript">
        changeColor();
        if (localStorage.getItem("fSize") < 1) { fSize = 16; localStorage.setItem("fSize", 16); } else { fSize = localStorage.getItem("fSize"); }
        document.getElementById("pageBody").style.fontSize = fSize + "px";

        // goBackMenu
        document.addEventListener("backbutton", goBackMenu, false);
        function goBackMenu()
        {
            window.location.href = 'list.html';
        }

        function changeColor()
        {
            if (localStorage.getItem("colorSheme") <= 1)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#f0f0f0");
            }

            if (localStorage.getItem("colorSheme") == 2)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#212121");
                document.getElementById("pageBody").style.color = localStorage.getItem("#efefef");
            }

            if (localStorage.getItem("colorSheme") == 3)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#efe4d0");
            }
        }

        // bm
        if (localStorage.getItem("arrs") != null)
        {
            var arrs = JSON.parse(localStorage.getItem("arrs"));
        }
        else
        {
            var arrs = [];
        }

        var names = ["../acharter/ru/java/book/45.html", "Массивы как тип данных в Java", "bm646"];

        function setzBm() { arrs.push(names); localStorage.setItem("arrs", JSON.stringify(arrs)); localStorage.setItem("bm646", 1); RefBms(); }

        window.onload = function() { RefBms(); }

        function RefBms()
        {
            if (localStorage.getItem("bm646") == 1) { document.getElementById("bma646").style.display = "block"; document.getElementById("bm646").style.display = "none"; } else { document.getElementById("bma646").style.display = "none"; document.getElementById("bm646").style.display = "block"; }
        }

        function dellBm() { for (var i = 0; i < arrs.length; i++) { if (arrs[i].indexOf("Массивы как тип данных в Java") == 1) { arrs.splice(i, 1); localStorage.setItem("bm646", 0); RefBms(); localStorage.setItem("arrs", JSON.stringify(arrs)); } } }

        // sub menu
        var serTimeToClose = 1000;
        
        function OpenSettMenu()
        {
            document.getElementById("subMenuInLess").style.display = "block";
            timeToEvAct();
            serTimeToClose = 1;
        }
        
        function timeToEvAct()
        {
            setTimeout(function() { serTimeToClose = 0 }, 100);
        }
        
        window.addEventListener('click', function(e){
        
            if (serTimeToClose <= 0)
            {
                if (document.getElementById('subMenuInLess').contains(e.target))
                {
                    //
                }
                else
                {
                    document.getElementById("subMenuInLess").style.display = "none";
                }
            }
        });

    </script>

</body>
</html>
