

<!DOCTYPE html>

<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <link rel="stylesheet" type="text/css" href="../../../../css/read.css" />
    <title>Coder Book menu</title>
    <script type="text/javascript" src="../../../../higtline/scripts/shCore.js"></script>
    <script type="text/javascript" src="../../../../higtline/scripts/shBrushCSharp.js"></script>
    <link type="text/css" rel="stylesheet" href="../../../../higtline/styles/shCoreDefault.css"/>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <script src="../../../../js/Hyphenator.js" type="text/javascript"></script>
</head>

<body id="pageBody" class="hyphenate">

<!-- progress bar -->
<script src="../../../../js/progressBar.js" type="text/javascript"></script>
<div class="Reading-progress" id="progressBarType1"><span id="Progress-bar-top" class="bar-top" style="display: block !important;"></span></div>
<div class="Reading-progress" id="progressBarType2"><span id="Progress-bar-bottom" class="bar-bottom"></span></div>
<div class="Reading-progress" id="progressBarType3"><span id="Progress-bar-left" class="bar-left"></span></div>
<div class="Reading-progress" id="progressBarType4"><span id="Progress-bar-right" class="bar-right"></span></div>
<!-- progress bar -->


    <div id="lesonPage">

        <div id="lessMenu">
           <a id="exitLess" href="list.html" ontouchstart="return true;"><img src="../../../../img/menu/ex.png" /></a>
           <div id="aaLess" ontouchstart="return true;" onclick="OpenSettMenu();"><img src="../../../../img/menu/aa.png" /></div>
           <div id="subMenuInLess" style="display: none;">
                <a href="../../../../menu/setfontsize-ru.html" ontouchstart="return true;" id="pastMenuInLess">Размер текста</a>
                <a href="../../../../menu/setcolor-ru.html" ontouchstart="return true;" id="pastMenuInLess">Цветовая темы</a>
                <a href="../../../../menu/setProgressBar-ru.html" ontouchstart="return true;" id="pastMenuInLess" style="border: none;">Прогресс бар</a>
           </div>
           <div id="aaLess" ontouchstart="return true;">
            <div class="bmEdit" onclick="dellBm();" id="bma627" ontouchstart="return true;" style="display: none;"><img src="../../../../img/menu/bmlessa.png" /></div>
            <div class="bmEdit" onclick="setzBm();" id="bm627" ontouchstart="return true;" style="display: block;"><img src="../../../../img/menu/bmless.png" /></div>
           </div>
        </div>

        <hr />

	<!-- ПОЧАТОК -->

	<h1 id="title">
		Примитивные и ссылочные типы данных
	</h1>

	<p>Теперь на примере переменных можно проиллюстрировать различие между примитивными и ссылочными типами данных.</p>
	<p>Рассмотрим пример, когда объявляются две переменные одного типа, приравниваются друг другу, а затем значение одной из них изменяется.</p>
	<p>Что произойдет со второй переменной?</p>
	<p>Возьмем простой тип int:</p>

	<pre class="brush: csharp;">
	// объявляем первую переменную и инициализируем ее
	int a=5;

	// объявляем вторую переменную и приравниваем ее к первой
	int b=a;

	// меняем значение первой
	a=3;

	// проверяем значение второй
	print(b);
	</pre>

	<p>Здесь и далее мы считаем, что функция print(...) позволяет нам некоторым (неважно, каким именно) способом узнать значение ее аргумента (как правило, для этого используют функцию из стандартной библиотеки System.out.println(...), которая выводит значение на системную консоль).</p>
	<p>В результате мы увидим, что значение переменной b не изменилось, оно осталось равным 5.</p>
	<p>Это означает, что переменные простого типа хранят непосредственно свои значения и при приравнивании двух переменных происходит копирование данного значения.</p>
	<p>Чтобы еще раз подчеркнуть эту особенность, приведем еще один пример:</p>

	<pre class="brush: csharp;">
	byte b=3;
	int a=b;
	</pre>

	<p>В данном примере происходит преобразование типов (оно подробно рассматривается в соответствующей лекции).</p>
	<p>Для нас сейчас важно констатировать, что переменная b хранит значение 3 типа byte, а переменная a – значение 3 типа int.</p>
	<p>Это два разных значения, и во второй строке при присваивании произошло копирование.</p>
	<p>Теперь рассмотрим ссылочный тип данных.</p>
	<p>Переменные таких типов всегда хранят ссылки на некоторые объекты.</p>
	<p>Рассмотрим для примера класс, описывающий точку на координатной плоскости с целочисленными координатами.</p>
	<p>Описание класса – это отдельная тема, но в нашем простейшем случае оно тривиально:</p>

	<pre class="brush: csharp;">
	class Point
	{
		int x, y;
	}
	</pre>

	<p>Теперь составим пример, аналогичный приведенному выше для int -переменных, считая, что выражение new Point(3,5) создает новый объект-точку с координатами (3,5).</p>

	<pre class="brush: csharp;">
	Point p1 = new Point(3,5);
	Point p2=p1;
	p1.x=7;
	print(p2.x);
	</pre>

	<p>В третьей строке мы изменили горизонтальную координату точки, на которую ссылалась переменная p1, и теперь нас интересует, как это сказалось на точке, на которую ссылается переменная p2.</p>
	<p>Проведя такой эксперимент, можно убедиться, что в этот раз мы увидим обновленное значение.</p>
	<p>То есть объектные переменные после приравнивания остаются "связанными" друг с другом, изменения одной сказываются на другой.</p>
	<p>Таким образом, примитивные переменные являются действительными хранилищами данных.</p>
	<p>Каждая переменная имеет значение, не зависящее от остальных.</p>
	<p>Ссылочные же переменные хранят лишь ссылки на объекты, причем различные переменные могут ссылаться на один и тот же объект, как это было в нашем примере.</p>
	<p>В этом случае их можно сравнить с наблюдателями, которые с разных позиций смотрят на один и тот же объект и одинаково видят все происходящие с ним изменения.</p>
	<p>Если же один наблюдатель сменит объект наблюдения, то он перестает видеть и изменения, происходящие с прежним объектом:</p>

	<pre class="brush: csharp;">
	Point p1 = new Point(3,5);
	Point p2=p1;
	p1 = new Point(7,9);
	print(p2.x);
	</pre>

	<p>В этом примере мы получим 3, то есть после третьей строки переменные p1 и p2 ссылаются на различные объекты и поэтому имеют разные значения.</p>
	<p>Теперь легко понять смысл литерала null.</p>
	<p>Такое значение может принять переменная любого ссылочного типа.</p>
	<p>Это означает, что ее ссылка никуда не указывает, объект отсутствует.</p>
	<p>Соответственно, любая попытка обратиться к объекту через такую переменную (например, вызвать метод или взять значение поля) приведет к ошибке.</p>
	<p>Также значение null можно передать в качестве любого объектного аргумента при вызове функций (хотя на практике многие методы считают такое значение некорректным).</p>
	<p>Память в Java с точки зрения программиста представляется не нулями и единицами или набором байтов, а как некое виртуальное пространство, в котором существуют объекты.</p>
	<p>И доступ к памяти осуществляется не по физическому адресу или указателю, а лишь через ссылки на объекты.</p>
	<p>Ссылка возвращается при создании объекта и далее может быть сохранена в переменной, передана в качестве аргумента и т.д.</p>
	<p>Как уже говорилось, допускается наличие нескольких ссылок на один объект.</p>
	<p>Возможна и противоположная ситуация – когда на какой-то объект не существует ни одной ссылки.</p>
	<p>Такой объект уже недоступен программе и является "мусором", то есть без толку занимает аппаратные ресурсы.</p>
	<p>Для их освобождения не требуется никаких усилий.</p>
	<p>В состав любой виртуальной машины обязательно входит автоматический сборщик мусора garbage collector – фоновый процесс, который как раз и занимается уничтожением ненужных объектов.</p>
	<p>Очень важно помнить, что объектная переменная, в отличие от примитивной, может иметь значение другого типа, не совпадающего с типом переменной.</p>
	<p>Например, если тип переменной – некий класс, то переменная может ссылаться на объект, порожденный от наследника этого класса.</p>
	<p>Все случаи подобного несовпадения будут рассмотрены в следующих разделах курса.</p>
	<p>Теперь рассмотрим примитивные и ссылочные типы данных более подробно.</p>

	<h1 id="title">
		Примитивные типы
	</h1>

	<p>Как уже говорилось, существует 8 простых типов данных, которые делятся на целочисленные ( integer ), дробные ( floating-point ) и булевы ( boolean ).</p>

	<h1 id="title">
		Целочисленные типы
	</h1>

	<p>Целочисленные типы – это byte, short, int, long, также к ним относят и char.</p>
	<p>Первые четыре типа имеют длину 1, 2, 4 и 8 байт соответственно, длина char – 2 байта, это непосредственно следует из того, что все символы Java описываются стандартом Unicode.</p>
	<p>Длины типов приведены только для оценки областей значения.</p>
	<p>Как уже говорилось, память в Java представляется виртуальной и вычислить, сколько физических ресурсов займет та или иная переменная, так прямолинейно не получится.</p>
	<p>4 основных типа являются знаковыми.</p>
	<p>char добавлен к целочисленным типам данных, так как с точки зрения JVM символ и его код – понятия взаимооднозначные.</p>
	<p>Конечно, код символа всегда положительный, поэтому char – единственный беззнаковый тип.</p>
	<p>Инициализировать его можно как символьным, так и целочисленным литералом.</p>
	<p>Во всем остальном char – полноценный числовой тип данных, который может участвовать, например, в арифметических действиях, операциях сравнения и т.п.</p>
	<p>В таблице ниже сведены данные по всем разобранным типам:</p>

	<table>
		<tr>
			<th>Название</th>
			<th>Длина</th>
			<th>Область значений</th>
		</tr>
		<tr>
			<td>byte</td>
			<td>1</td>
			<td>-128 .. 127</td>
		</tr>
		<tr>
			<td>short</td>
			<td>2</td>
			<td>-32.768 .. 32.767</td>
		</tr>
		<tr>
			<td>int</td>
			<td>4</td>
			<td>-2.147.483.648 .. 2.147.483.647</td>
		</tr>
		<tr>
			<td>long</td>
			<td>8</td>
			<td>-9.223.372.036.854.775.808 .. 9.223.372.036.854.775.807 (примерно 10 в 19 степени)</td>
		</tr>
		<tr>
			<td>char</td>
			<td>2</td>
			<td>'\u0000' .. '\uffff', или 0 .. 65.535</td>
		</tr>
	</table>

	<p>Обратите внимание, что int вмещает примерно 2 миллиарда, а потому подходит во многих случаях, когда не требуются сверхбольшие числа.</p>
	<p>Чтобы представить себе размеры типа long, укажем, что именно он используется в Java для отсчета времени.</p>
	<p>Как и во многих языках, время отсчитывается от 1 января 1970 года в миллисекундах.</p>
	<p>Так вот, вместимость long позволяет отсчитывать время на протяжении миллионов веков(!), причем как в будущее, так и в прошлое.</p>
	<p>Почему были выделены именно эти два типа, int и long?</p>
	<p>Дело в том, что целочисленные литералы имеют тип int по умолчанию, или тип long, если стоит буква L или l.</p>
	<p>Именно поэтому корректным литералом считается только такое число, которое укладывается в 4 или 8 байт, соответственно. Иначе компилятор сочтет это ошибкой.</p>
	<p>Таким образом, следующие литералы являются корректными:</p>

	<pre class="brush: csharp;">
	1
	-2147483648
	2147483648L
	0L
	111111111111111111L
	</pre>

	<p>Над целочисленными аргументами можно производить следующие операции:</p>

	<p>- операции сравнения (возвращают булево значение)</p>
	<p>* &lt;, &lt;=, &gt;, &gt;=</p>
	<p>* ==, !=</p>
	<p>- числовые операции (возвращают числовое значение)</p>
	<p>* унарные операции + и -</p>
	<p>* арифметические операции +, -, *, /, %</p>
	<p>* операции инкремента и декремента (в префиксной и постфиксной форме): ++ и --</p>
	<p>* операции битового сдвига &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;</p>
	<p>* битовые операции ~, &, |, ^</p>
	<p>- оператор с условием ?:</p>
	<p>- оператор приведения типов</p>
	<p>- оператор конкатенации со строкой +</p>

	<p>Операторы сравнения вполне очевидны и отдельно мы их рассматривать не будем.</p>
	<p>Их результат всегда булева типа ( true или false ).</p>
	<p>Работа числовых операторов также понятна, к тому же пояснялась в предыдущей лекции.</p>
	<p>Единственное уточнение можно сделать относительно операторов + и -, которые могут быть как бинарными (иметь два операнда), так и унарными (иметь один операнд).</p>
	<p>Бинарные операнды являются операторами сложения и вычитания, соответственно.</p>
	<p>Унарный оператор + возвращает значение, равное аргументу ( +x всегда равно x ).</p>
	<p>Унарный оператор -, примененный к значению x, возвращает результат, равный 0-x.</p>
	<p>Неожиданный эффект имеет место в том случае, если аргумент равен наименьшему возможному значению примитивного типа.</p>

	<pre class="brush: csharp;">
	// наименьшее возможное значение типа int
	int x=-2147483648;
	int y=-x;
	</pre>

	<p>Теперь значение переменной y на самом деле равно не 2147483648, поскольку такое число не укладывается в область значений типа int, а в точности равно значению x!</p>
	<p>Другими словами, в этом примере выражение -x==x истинно!</p>
	<p>Дело в том, что если при выполнении числовых операций над целыми числами возникает переполнение и результат не может быть сохранен в данном примитивном типе, то Java не создает никаких ошибок.</p>
	<p>Вместо этого все старшие биты, которые превышают вместимость типа, просто отбрасываются.</p>
	<p>Это может привести не только к потере точной абсолютной величины результата, но даже к искажению его знака, если на месте знакового бита окажется противоположное значение.</p>

	<pre class="brush: csharp;">
	int x= 300000;
	print(x*x);
	</pre>

	<p>Результатом такого примера будет:</p>

	<pre class="brush: csharp;">
	-194313216
	</pre>

	<p>Возвращаясь к инвертированию числа -2147483648, мы видим, что математический результат равен в точности +231, или, в двоичном формате, 1000 0000 0000 0000 0000 0000 0000 0000 (единица и 31 ноль).</p>
	<p>Но тип int рассматривает первую единицу как знаковый бит, и результат получается равным -2147483648.</p>
	<p>Таким образом, явное выписывание в коде литералов, которые слишком велики для используемых типов, приводит к ошибке компиляции.</p>
	<p>Если же переполнение возникает в результате выполнения операции, "лишние" биты просто отбрасываются.</p>
	<p>Подчеркнем, что выражение типа -5 не является целочисленным литералом.</p>
	<p>На самом деле оно состоит из литерала 5 и оператора -.</p>
	<p>Напомним, что некоторые литералы (например, 2147483648 ) могут встречаться только в сочетании с унарным оператором -.</p>
	<p>Кроме того, числовые операции в Java обладают еще одной особенностью.</p>
	<p>Хотя целочисленные типы имеют длину 8, 16, 32 и 64 бита, вычисления проводятся только с 32-х и 64-х битной точностью.</p>
	<p>А это значит, что перед вычислениями может потребоваться преобразовать тип одного или нескольких операндов.</p>
	<p>Если хотя бы один аргумент операции имеет тип long, то все аргументы приводятся к этому типу, и результат операции также будет типа long.</p>
	<p>Вычисление будет произведено с точностью в 64 бита, а более старшие биты, если таковые появляются в результате, отбрасываются.</p>
	<p>Если же аргументов типа long нет, то вычисление производится с точностью в 32 бита, и все аргументы преобразуются в int (это относится к byte, short, char ).</p>
	<p>Результат также имеет тип int.</p>
	<p>Все биты старше 32-го игнорируются.</p>
	<p>Никакого способа узнать, произошло ли переполнение, нет.</p>
	<p>Расширим рассмотренный пример:</p>

	<pre class="brush: csharp;">
	int i=300000;

	// умножение с точностью 32 бита
	print(i*i);
	long m=i;

	// умножение с точностью 64 бита
	print(m*m);

	// попробуем получить разность значений int и long
	print(1/(m-i));
	</pre>

	<p>Результатом такого примера будет:</p>

	<pre class="brush: csharp;">
	-194313216
	90000000000
	</pre>

	<p>затем мы получим ошибку деления на ноль, поскольку переменные i и m хоть и разных типов, но хранят одинаковое математическое значение и их разность равна нулю.</p>
	<p>Первое умножение производилось с точностью в 32 бита, более старшие биты были отброшены.</p>
	<p>Второе – с точностью в 64 бита, ответ не исказился.</p>
	<p>Вопрос приведения типов, и в том числе специальный оператор для такого действия, подробно рассматривается в следующих лекциях.</p>
	<p>Однако здесь хотелось бы отметить несколько примеров, которые не столь очевидны и могут создать проблемы при написании программ.</p>
	<p>Во-первых, подчеркнем, что результатом операции с целочисленными аргументами всегда является целое число.</p>
	<p>А значит, в следующем примере</p>

	<pre class="brush: csharp;">
	double x = 1/2;
	</pre>

	<p>переменной x будет присвоено значение 0, а не 0.5, как можно было бы ожидать.</p>
	<p>Подробно операции с дробными аргументами рассматриваются ниже, но чтобы получить значение 0.5, достаточно написать 1./2 (теперь первый аргумент дробный и результат не будет округлен).</p>
	<p>Как уже упоминалось, время в Java измеряется в миллисекундах.</p>
	<p>Попробуем вычислить, сколько миллисекунд содержится в неделе и в месяце:</p>

	<pre class="brush: csharp;">
	// вычисление для недели
	print(1000*60*60*24*7);

	// вычисление для месяца
	print(1000*60*60*24*30);
	</pre>

	<p>Необходимо перемножить количество миллисекунд в одной секунде (1000), секунд – в минуте (60), минут – в часе (60), часов – в дне (24) и дней — в неделе и месяце (7 и 30, соответственно).</p>
	<p>Получаем:</p>

	<pre class="brush: csharp;">
	604800000
	-1702967296
	</pre>

	<p>Очевидно, во втором вычислении произошло переполнение.</p>
	<p>Достаточно сделать последний аргумент величиной типа long:</p>

	<pre class="brush: csharp;">
	// вычисление для месяца
	print(1000*60*60*24*30L);
	</pre>

	<p>Получаем правильный результат:</p>

	<pre class="brush: csharp;">
	2592000000
	</pre>

	<p>Подобные вычисления разумно переводить на 64-битную точность не на последней операции, а заранее, чтобы избежать переполнения.</p>
	<p>Понятно, что типы большей длины могут хранить больший спектр значений, а потому Java не позволяет присвоить переменной меньшего типа значение большего типа.</p>
	<p>Например, такие строки вызовут ошибку компиляции:</p>

	<pre class="brush: csharp;">
	// пример вызовет ошибку компиляции
	int x=1;
	byte b=x;
	</pre>

	<p>Хотя для программиста и очевидно, что переменная b должна получить значение 1, что легко укладывается в тип byte, однако компилятор не может вычислять значение переменной x при обработке второй строки, он знает лишь, что ее тип – int.</p>
	<p>А вот менее очевидный пример:</p>

	<pre class="brush: csharp;">
	// пример вызовет ошибку компиляции
	byte b=1;
	byte c=b+1;
	</pre>

	<p>И здесь компилятор не сможет успешно завершить работу.</p>
	<p>При операции сложения значение переменной b будет преобразовано в тип int и таким же будет результат сложения, а значит, его нельзя так просто присвоить переменной типа byte.</p>
	<p>Аналогично:</p>

	<pre class="brush: csharp;">
	// пример вызовет ошибку компиляции
	int x=2;
	long y=3;
	int z=x+y;
	</pre>

	<p>Здесь результат сложения будет уже типа long.</p>
	<p>Точно так же некорректна такая инициализация:</p>

	<pre class="brush: csharp;">
	// пример вызовет ошибку компиляции
	byte b=5;
	byte c=-b;
	</pre>

	<p>Даже унарный оператор " - " проводит вычисления с точностью не меньше 32 бит.</p>
	<p>Хотя во всех случаях инициализация переменных приводилась только для примера, а предметом рассмотрения были числовые операции, укажем корректный способ преобразовать тип числового значения:</p>

	<pre class="brush: csharp;">
	byte b=1;
	byte c=(byte)-b;
	</pre>

	<p>Итак, все числовые операторы возвращают результат типа int или long.</p>
	<p>Однако существует два исключения.</p>
	<p>Первое из них – операторы инкрементации и декрементации.</p>
	<p>Их действие заключается в прибавлении или вычитании единицы из значения переменной, после чего результат сохраняется в этой переменной и значение всей операции равно значению переменной (до или после изменения, в зависимости от того, является оператор префиксным или постфиксным).</p>
	<p>А значит, и тип значения совпадает с типом переменной.</p>
	<p>(На самом деле, вычисления все равно производятся с точностью минимум 32 бита, однако при присвоении переменной результата его тип понижается.)</p>

	<pre class="brush: csharp;">
	byte x=5;

	// на момент начала исполнения x равен 5
	byte y1=x++;

	// на момент начала исполнения x равен 6
	byte y2=x--;

	// на момент начала исполнения x равен 5
	byte y3=++x;

	// на момент начала исполнения x равен 6
	byte y4=--x;
	println(y1);
	println(y2);
	println(y3);
	println(y4);
	</pre>

	<p>В результате получаем:</p>

	<pre class="brush: csharp;">
	5
	6
	6
	5
	</pre>

	<p>Никаких проблем с присвоением результата операторов ++ и -- переменным типа byte.</p>
	<p>Завершая рассмотрение этих операторов, приведем еще один пример:</p>

	<pre class="brush: csharp;">
	byte x=-128;
	print(-x);

	byte y=127;
	print(++y);
	</pre>

	<p>Результатом будет:</p>

	<pre class="brush: csharp;">
	128
	-128
	</pre>

	<p>Этот пример иллюстрирует вопросы преобразования типов при вычислениях и случаи переполнения.</p>
	<p>Вторым исключением является оператор с условием ?:.</p>
	<p>Если второй и третий операнды имеют одинаковый тип, то и результат операции будет такого же типа.</p>

	<pre class="brush: csharp;">
	byte x=2;
	byte y=3;
	byte z=(x>y) ? x : y;
	// верно, x и y одинакового типа

	byte abs=(x>0) ? x : -x;
	// неверно!
	</pre>

	<p>Последняя строка неверна, так как третий аргумент содержит числовую операцию, стало быть, его тип int, а значит, и тип всей операции будет int, и присвоение некорректно.</p>
	<p>Даже если второй аргумент имеет тип byte, а третий – short, значение будет типа int.</p>
	<p>Наконец, рассмотрим оператор конкатенации со строкой.</p>
	<p>Оператор + может принимать в качестве аргумента строковые величины.</p>
	<p>Если одним из аргументов является строка, а вторым – целое число, то число будет преобразовано в текст и строки объединятся.</p>

	<pre class="brush: csharp;">
	int x=1;
	print("x="+x);
	</pre>

	<p>Результатом будет:</p>

	<pre class="brush: csharp;">
	x=1
	</pre>

	<p>Обратите внимание на следующий пример:</p>

	<pre class="brush: csharp;">
	print(1+2+"text");
	print("text"+1+2);
	</pre>

	<p>Его результатом будет:</p>

	<pre class="brush: csharp;">
	3text
	text12
	</pre>

	<p>Отдельно рассмотрим работу с типом char.</p>
	<p>Значения этого типа могут полноценно участвовать в числовых операциях:</p>

	<pre class="brush: csharp;">
	char c1=10;
	char c2='A';

	// латинская буква A (\u0041, код 65)

	int i=c1+c2-'B';
	</pre>

	<p>Переменная i получит значение 9.</p>
	<p>Рассмотрим следующий пример:</p>

	<pre class="brush: csharp;">
	char c='A';

	print(c);

	print(c+1);

	print("c="+c);

	print('c'+'='+с);
	</pre>

	<p>Его результатом будет:</p>

	<pre class="brush: csharp;">
	A
	66
	c=A
	225
	</pre>

	<p>В первом случае в метод print было передано значение типа char, поэтому отобразился символ.</p>
	<p>Во втором случае был передан результат сложения, то есть число, и именно число появилось на экране.</p>
	<p>Далее при сложении со строкой тип char был преобразован в текст в виде символа.</p>
	<p>Наконец в последней строке произошло сложение трех чисел: 'c' (код 99), '=' (код 61) и переменной c (т.е. код 'A' - 65 ).</p>
	<p>Для каждого примитивного типа существуют специальные вспомогательные классы-обертки (wrapper classes).</p>
	<p>Для типов byte, short, int, long, char это Byte, Short, Integer, Long, Character.</p>
	<p>Эти классы содержат многие полезные методы для работы с целочисленными значениями.</p>
	<p>Например, преобразование из текста в число. Кроме того, есть класс Math, который хоть и предназначен в основном для работы с дробными числами, но также предоставляет некоторые возможности и для целых.</p>
	<p>В заключение подчеркнем, что единственные операции с целыми числами, при которых Java генерирует ошибки,– это деление на ноль (операторы / и % ).</p>

	<script src="../../../../js/progressBarSetIni.js" type="text/javascript"></script>

        <div id="lessMenu" style="margin: 30px 0 0 0;">
            <hr />
            <a href="25.html"><div id="exitLess" ontouchstart="return true;"><img src="../../../../img/menu/pr.png" /></div></a>
            <a href="27.html"><div id="aaLess" ontouchstart="return true;"><img src="../../../../img/menu/ne.png" /></div></a>
        </div>

    </div>

    <script type="text/javascript" src="../../../../cordova.js"></script>
    <script type="text/javascript" src="../../../../js/global.js"></script>
    <script type="text/javascript">
        changeColor();
        if (localStorage.getItem("fSize") < 1) { fSize = 16; localStorage.setItem("fSize", 16); } else { fSize = localStorage.getItem("fSize"); }
        document.getElementById("pageBody").style.fontSize = fSize + "px";

        // goBackMenu
        document.addEventListener("backbutton", goBackMenu, false);
        function goBackMenu()
        {
            window.location.href = 'list.html';
        }

        function changeColor()
        {
            if (localStorage.getItem("colorSheme") <= 1)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#f0f0f0");
            }

            if (localStorage.getItem("colorSheme") == 2)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#212121");
                document.getElementById("pageBody").style.color = localStorage.getItem("#efefef");
            }

            if (localStorage.getItem("colorSheme") == 3)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#efe4d0");
            }
        }

        // bm
        if (localStorage.getItem("arrs") != null)
        {
            var arrs = JSON.parse(localStorage.getItem("arrs"));
        }
        else
        {
            var arrs = [];
        }

        var names = ["../acharter/ru/java/book/26.html", "Примитивные типы", "bm627"];

        function setzBm() { arrs.push(names); localStorage.setItem("arrs", JSON.stringify(arrs)); localStorage.setItem("bm627", 1); RefBms(); }

        window.onload = function() { RefBms(); }

        function RefBms()
        {
            if (localStorage.getItem("bm627") == 1) { document.getElementById("bma627").style.display = "block"; document.getElementById("bm627").style.display = "none"; } else { document.getElementById("bma627").style.display = "none"; document.getElementById("bm627").style.display = "block"; }
        }

        function dellBm() { for (var i = 0; i < arrs.length; i++) { if (arrs[i].indexOf("Примитивные типы") == 1) { arrs.splice(i, 1); localStorage.setItem("bm627", 0); RefBms(); localStorage.setItem("arrs", JSON.stringify(arrs)); } } }

        // sub menu
        var serTimeToClose = 1000;
        
        function OpenSettMenu()
        {
            document.getElementById("subMenuInLess").style.display = "block";
            timeToEvAct();
            serTimeToClose = 1;
        }
        
        function timeToEvAct()
        {
            setTimeout(function() { serTimeToClose = 0 }, 100);
        }
        
        window.addEventListener('click', function(e){
        
            if (serTimeToClose <= 0)
            {
                if (document.getElementById('subMenuInLess').contains(e.target))
                {
                    //
                }
                else
                {
                    document.getElementById("subMenuInLess").style.display = "none";
                }
            }
        });

    </script>

</body>
</html>
