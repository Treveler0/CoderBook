

<!DOCTYPE html>

<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <link rel="stylesheet" type="text/css" href="../../../../css/read.css" />
    <title>Coder Book menu</title>
    <script type="text/javascript" src="../../../../higtline/scripts/shCore.js"></script>
    <script type="text/javascript" src="../../../../higtline/scripts/shBrushCSharp.js"></script>
    <link type="text/css" rel="stylesheet" href="../../../../higtline/styles/shCoreDefault.css"/>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <script src="../../../../js/Hyphenator.js" type="text/javascript"></script>
</head>

<body id="pageBody" class="hyphenate">

<!-- progress bar -->
<script src="../../../../js/progressBar.js" type="text/javascript"></script>
<div class="Reading-progress" id="progressBarType1"><span id="Progress-bar-top" class="bar-top" style="display: block !important;"></span></div>
<div class="Reading-progress" id="progressBarType2"><span id="Progress-bar-bottom" class="bar-bottom"></span></div>
<div class="Reading-progress" id="progressBarType3"><span id="Progress-bar-left" class="bar-left"></span></div>
<div class="Reading-progress" id="progressBarType4"><span id="Progress-bar-right" class="bar-right"></span></div>
<!-- progress bar -->


    <div id="lesonPage">

        <div id="lessMenu">
           <a id="exitLess" href="list.html" ontouchstart="return true;"><img src="../../../../img/menu/ex.png" /></a>
           <div id="aaLess" ontouchstart="return true;" onclick="OpenSettMenu();"><img src="../../../../img/menu/aa.png" /></div>
           <div id="subMenuInLess" style="display: none;">
                <a href="../../../../menu/setfontsize-ru.html" ontouchstart="return true;" id="pastMenuInLess">Размер текста</a>
                <a href="../../../../menu/setcolor-ru.html" ontouchstart="return true;" id="pastMenuInLess">Цветовая темы</a>
                <a href="../../../../menu/setProgressBar-ru.html" ontouchstart="return true;" id="pastMenuInLess" style="border: none;">Прогресс бар</a>
           </div>
           <div id="aaLess" ontouchstart="return true;">
            <div class="bmEdit" onclick="dellBm();" id="bma624" ontouchstart="return true;" style="display: none;"><img src="../../../../img/menu/bmlessa.png" /></div>
            <div class="bmEdit" onclick="setzBm();" id="bm624" ontouchstart="return true;" style="display: block;"><img src="../../../../img/menu/bmless.png" /></div>
           </div>
        </div>

        <hr />

	<!-- ПОЧАТОК -->

	<h1 id="title">
		Работа с операторами
	</h1>

	<p>Рассмотрим некоторые детали использования операторов в Java.</p>
	<p>Здесь будут описаны подробности, относящиеся к работе самих операторов.</p>
	<p>В следующей лекции детально рассматриваются особенности, возникающие при использовании различных типов данных (например, значение операции 1/2 равно 0, а 1/2. равно 0.5 ).</p>

	<h1 id="title">
		Операторы присваивания и сравнения
	</h1>

	<p>Во-первых, конечно же, различаются оператор присваивания = и оператор сравнения ==.</p>

	<pre class="brush: csharp;">
	// присваиваем переменной x значение 1
	x = 1;

	// сравниваем значение переменной x с единицей
	x == 1
	</pre>

	<p>Оператор сравнения всегда возвращает булевское значение true или false.</p>
	<p>Оператор присваивания возвращает значение правого операнда.</p>
	<p>Поэтому обычная опечатка в языке С, когда эти операторы путают:</p>

	<pre class="brush: csharp;">
	// пример вызовет ошибку компилятора
	// здесь должен применяться оператор сравнения ==
	
	if (x=0)
	{
		...
	}
	</pre>

	<p>в Java легко устраняется.</p>
	<p>Поскольку выражение x=0 имеет числовое значение 0, а не булевское (и тем более не воспринимается как всегда истинное), то компилятор сообщает об ошибке (необходимо писать x==0 ).</p>
	<p>Условие "не равно" записывается как !=.</p>
	<p>Например:</p>

	<pre class="brush: csharp;">
	if (x!=0)
	{
		float f = 1./x;
	}
	</pre>

	<p>Сочетание какого-либо оператора с оператором присваивания = (см. нижнюю строку в полном перечне в разделе "Операторы") используется при изменении значения переменной.</p>
	<p>Например, следующие две строки эквивалентны:</p>

	<pre class="brush: csharp;">
	x = x + 1;
	x += 1;
	</pre>

	<h1 id="title">
		Арифметические операции
	</h1>

	<p>Наряду с четырьмя обычными арифметическими операциями +, -, *, /, существует оператор получения остатка от деления %, который может быть применен как к целочисленным аргументам, так и к дробным.</p>
	<p>Работа с целочисленными аргументами подчиняется простым правилам.</p>
	<p>Если делится значение a на значение b, то выражение (a/b)*b+(a%b) должно в точности равняться a.</p>
	<p>Здесь, конечно, оператор деления целых чисел / всегда возвращает целое число.</p>
	<p>Например:</p>

	<pre class="brush: csharp;">
	9/5 возвращает 1
	9/(-5) возвращает -1
	(-9)/5 возвращает -1
	(-9)/(-5) возвращает 1
	</pre>

	<p>Остаток может быть положительным, только если делимое было положительным.</p>
	<p>Соответственно, остаток может быть отрицательным только в случае отрицательного делимого.</p>

	<pre class="brush: csharp;">
	9%5 возвращает 4
	9%(-5) возвращает 4
	(-9)%5 возвращает -4
	(-9)%(-5) возвращает -4
	</pre>

	<p>Попытка получить остаток от деления на 0 приводит к ошибке.</p>
	<p>Деление с остатком для дробных чисел может быть произведено по двум различным алгоритмам.</p>
	<p>Один из них повторяет правила для целых чисел, и именно он представлен оператором %.</p>
	<p>Если в рассмотренном примере деления 9 на 5 перейти к дробным числам, значение остатка во всех вариантах не изменится (оно будет также дробным, конечно).</p>

	<pre class="brush: csharp;">
	9.0%5.0 возвращает 4.0
	9.0%(-5.0) возвращает 4.0
	(-9.0)%5.0 возвращает -4.0
	(-9.0)%(-5.0) возвращает -4.0
	</pre>

	<p>Однако стандарт IEEE 754 определяет другие правила.</p>
	<p>Такой способ представлен методом стандартного класса Math.IEEEremainder(double f1, double f2).</p>
	<p>Результат этого метода – значение, которое равно f1-f2*n, где n – целое число, ближайшее к значению f1/f2, а если два целых числа одинаково близки к этому отношению, то выбирается четное.</p>
	<p>По этому правилу значение остатка будет другим:</p>

	<pre class="brush: csharp;">
	Math.IEEEremainder(9.0, 5.0) возвращает -1.0
	Math.IEEEremainder(9.0, -5.0) возвращает -1.0
	Math.IEEEremainder(-9.0, 5.0) возвращает 1.0
	Math.IEEEremainder(-9.0, -5.0) возвращает 1.0
	</pre>

	<p>Унарные операторы инкрементации ++ и декрементации --, как обычно, можно использовать как справа, так и слева.</p>

	<pre class="brush: csharp;">
	int x=1;
	int y=++x;
	</pre>

	<p>В этом примере оператор ++ стоит перед переменной x, это означает, что сначала произойдет инкрементация, а затем значение x будет использовано для инициализации y.</p>
	<p>В результате после выполнения этих строк значения x и y будут равны 2.</p>

	<pre class="brush: csharp;">
	int x=1;
	int y=x++;
	</pre>

	<p>А в этом примере сначала значение x будет использовано для инициализации y, и лишь затем произойдет инкрементация.</p>
	<p>В результате значение x будет равно 2, а y будет равно 1.</p>

	<h1 id="title">
		Логические операторы
	</h1>

	<p>Логические операторы "и" и "или" ( & и | ) можно использовать в двух вариантах.</p>
	<p>Это связано с тем, что, как легко убедиться, для каждого оператора возможны случаи, когда значение первого операнда сразу определяет значение всего логического выражения.</p>
	<p>Если вторым операндом является значение некоторой функции, то появляется выбор – вызывать ее или нет, причем это решение может сказаться как на скорости, так и на функциональности программы.</p>
	<p>Первый вариант операторов ( &, | ) всегда вычисляет оба операнда, второй же – ( &&, || ) не будет продолжать вычисления, если значение выражения уже очевидно.</p>
	<p>Например:</p>

	<pre class="brush: csharp;">
	int x=1;

	// в таком выражении произойдет вызов calculate
	(x>0) | calculate(x)

	// а в этом - нет
	(x>0) || calculate(x)
	</pre>

	<p>Логический оператор отрицания "не" записывается как ! и, конечно, имеет только один вариант использования.</p>
	<p>Этот оператор меняет булевское значение на противоположное.</p>

	<pre class="brush: csharp;">
	int x=1;

	// выражение истинно
	x>0

	// выражение ложно
	!(x>0)
	</pre>

	<p>Оператор с условием ?: состоит из трех частей – условия и двух выражений.</p>
	<p>Сначала вычисляется условие (булевское выражение), а на основании результата значение всего оператора определяется первым выражением в случае получения истины и вторым – если условие ложно.</p>
	<p>Например, так можно вычислить модуль числа x:</p>

	<pre class="brush: csharp;">
	x>0 ? x : -x
	</pre>

	<h1 id="title">
		Битовые операции
	</h1>

	<p>Прежде чем переходить к битовым операциям, необходимо уточнить, каким именно образом целые числа представляются в двоичном виде.</p>
	<p>Конечно, для неотрицательных величин это практически очевидно:</p>

	<pre class="brush: csharp;">
	0   0
	1   1
	2   10
	3   11
	4   100
	5   101
	</pre>

	<p>и так далее.</p>
	<p>Однако как представляются отрицательные числа?</p>
	<p>Во-первых, вводят понятие знакового бита.</p>
	<p>Первый бит начинает отвечать за знак, а именно 0 означает положительное число, 1 – отрицательное.</p>
	<p>Но не следует думать, что остальные биты остаются неизменными.</p>
	<p>Например, если рассмотреть 8-битовое представление:</p>

	<pre class="brush: csharp;">
	// это НЕВЕРНО!
	-1   10000001

	// это НЕВЕРНО!
	-2   10000010

	// это НЕВЕРНО!
	-3   10000011
	</pre>

	<p>Такой подход неверен!</p>
	<p>В частности, мы получаем сразу два представления нуля – 00000000 и 10000000, что нерационально.</p>
	<p>Правильный алгоритм можно представить себе так.</p>
	<p>Чтобы получить значение -1, надо из 0 вычесть 1:</p>

	<pre class="brush: csharp;">
	00000000
	- 00000001
	------------
	- 11111111
	</pre>

	<p>Итак, -1 в двоичном виде представляется как 11111111.</p>
	<p>Продолжаем применять тот же алгоритм (вычитаем 1):</p>

	<pre class="brush: csharp;">
	0 00000000
	-1 11111111
	-2 11111110
	-3 11111101
	</pre>

	<p>и так далее до значения 10000000, которое представляет собой наибольшее по модулю отрицательное число.</p>
	<p>Для 8-битового представления наибольшее положительное число 01111111 (=127), а наименьшее отрицательное 10000000 (=-128).</p>
	<p>Поскольку всего 8 бит определяет 28=256 значений, причем одно из них отводится для нуля, то становится ясно, почему наибольшие по модулю положительные и отрицательные значения различаются на единицу, а не совпадают.</p>
	<p>Как известно, битовые операции "и", "или", "исключающее или" принимают два аргумента и выполняют логическое действие попарно над соответствующими битами аргументов.</p>
	<p>При этом используются те же обозначения, что и для логических операторов, но, конечно, только в первом (одиночном) варианте.</p>
	<p>Например, вычислим выражение 5&6:</p>

	<pre class="brush: csharp;">
	00000101
	& 00000110
	-------------
	  00000100

	// число 5 в двоичном виде
	// число 6 в двоичном виде

	//проделали операцию "и" попарно над битами в каждой позиции
	</pre>

	<p>То есть выражение 5&6 равно 4.</p>
	<p>Исключение составляет лишь оператор "не" или "NOT", который для побитовых операций записывается как ~ (для логических было !).</p>
	<p>Этот оператор меняет каждый бит в числе на противоположный.</p>
	<p>Например, ~(-1)=0.</p>
	<p>Можно легко установить общее правило для получения битового представления отрицательных чисел:</p>
	<p>Если n – целое положительное число, то -n в битовом представлении равняется ~(n-1).</p>
	<p>Наконец, осталось рассмотреть лишь операторы побитового сдвига.</p>
	<p>В Java есть один оператор сдвига влево и два варианта сдвига вправо.</p>
	<p>Такое различие связано с наличием знакового бита.</p>
	<p>При сдвиге влево оператором &lt;&lt; все биты числа смещаются на указанное количество позиций влево, причем освободившиеся справа позиции заполняются нулями.</p>
	<p>Эта операция аналогична умножению на 2n и действует вполне предсказуемо, как при положительных, так и при отрицательных аргументах.</p>
	<p>Рассмотрим примеры применения операторов сдвига для значений типа int, т.е. 32-битных чисел.</p>
	<p>Пусть положительным аргументом будет число 20, а отрицательным -21.</p>

	<pre class="brush: csharp;">
	// Сдвиг влево для положительного числа 20
	20 << 00 = 00000000000000000000000000010100 = 20
	20 << 01 = 00000000000000000000000000101000 = 40
	20 << 02 = 00000000000000000000000001010000 = 80
	20 << 03 = 00000000000000000000000010100000 = 160
	20 << 04 = 00000000000000000000000101000000 = 320
	...
	20 << 25 = 00101000000000000000000000000000 = 671088640
	20 << 26 = 01010000000000000000000000000000 = 1342177280
	20 << 27 = 10100000000000000000000000000000 = -1610612736
	20 << 28 = 01000000000000000000000000000000 = 1073741824
	20 << 29 = 10000000000000000000000000000000 = -2147483648
	20 << 30 = 00000000000000000000000000000000 = 0
	20 << 31 = 00000000000000000000000000000000 = 0

	// Сдвиг влево для отрицательного числа -21
	-21 << 00 = 11111111111111111111111111101011 = -21
	-21 << 01 = 11111111111111111111111111010110 = -42
	-21 << 02 = 11111111111111111111111110101100 = -84
	-21 << 03 = 11111111111111111111111101011000 = -168
	-21 << 04 = 11111111111111111111111010110000 = -336
	-21 << 05 = 11111111111111111111110101100000 = -672
	...
	-21 << 25 = 11010110000000000000000000000000 = -704643072
	-21 << 26 = 10101100000000000000000000000000 = -1409286144
	-21 << 27 = 01011000000000000000000000000000 = 1476395008
	-21 << 28 = 10110000000000000000000000000000 = -1342177280
	-21 << 29 = 01100000000000000000000000000000 = 1610612736
	-21 << 30 = 11000000000000000000000000000000 = -1073741824
	-21 << 31 = 10000000000000000000000000000000 = -2147483648
	</pre>

	<p>Как видно из примера, неожиданности возникают тогда, когда значащие биты начинают занимать первую позицию и влиять на знак результата.</p>
	<p>При сдвиге вправо все биты аргумента смещаются на указанное количество позиций, соответственно, вправо.</p>
	<p>Однако встает вопрос – каким значением заполнять освобождающиеся позиции слева, в том числе и отвечающую за знак.</p>
	<p>Есть два варианта.</p>
	<p>Оператор &gt;&gt; использует для заполнения этих позиций значение знакового бита, то есть результат всегда имеет тот же знак, что и начальное значение.</p>
	<p>Второй оператор &gt;&gt;&gt; заполняет их нулями, то есть результат всегда положительный.</p>

	<pre class="brush: csharp;">
	// Сдвиг вправо для положительного числа 20

	// Оператор >>
	20 >> 00 = 00000000000000000000000000010100 = 20
	20 >> 01 = 00000000000000000000000000001010 = 10
	20 >> 02 = 00000000000000000000000000000101 = 5
	20 >> 03 = 00000000000000000000000000000010 = 2
	20 >> 04 = 00000000000000000000000000000001 = 1
	20 >> 05 = 00000000000000000000000000000000 = 0

	// Оператор >>>
	20 >>> 00 = 00000000000000000000000000010100 = 20
	20 >>> 01 = 00000000000000000000000000001010 = 10
	20 >>> 02 = 00000000000000000000000000000101 = 5
	20 >>> 03 = 00000000000000000000000000000010 = 2
	20 >>> 04 = 00000000000000000000000000000001 = 1
	20 >>> 05 = 00000000000000000000000000000000 = 0
	</pre>

	<p>Очевидно, что для положительного аргумента операторы &gt;&gt; и &gt;&gt;&gt; работают совершенно одинаково.</p>
	<p>Дальнейший сдвиг на большее количество позиций будет также давать нулевой результат.</p>

	<pre class="brush: csharp;">
	// Сдвиг вправо для отрицательного числа -21

	// Оператор >>
	-21 >> 00 = 11111111111111111111111111101011 = -21
	-21 >> 01 = 11111111111111111111111111110101 = -11
	-21 >> 02 = 11111111111111111111111111111010 = -6
	-21 >> 03 = 11111111111111111111111111111101 = -3
	-21 >> 04 = 11111111111111111111111111111110 = -2
	-21 >> 05 = 11111111111111111111111111111111 = -1

	// Оператор >>>
	-21 >>> 00 = 11111111111111111111111111101011 = -21
	-21 >>> 01 = 01111111111111111111111111110101 = 2147483637
	-21 >>> 02 = 00111111111111111111111111111010 = 1073741818
	-21 >>> 03 = 00011111111111111111111111111101 = 536870909
	-21 >>> 04 = 00001111111111111111111111111110 = 268435454
	-21 >>> 05 = 00000111111111111111111111111111 = 134217727
	...
	-21 >>> 24 = 00000000000000000000000011111111 = 255
	-21 >>> 25 = 00000000000000000000000001111111 = 127
	-21 >>> 26 = 00000000000000000000000000111111 = 63
	-21 >>> 27 = 00000000000000000000000000011111 = 31
	-21 >>> 28 = 00000000000000000000000000001111 = 15
	-21 >>> 29 = 00000000000000000000000000000111 = 7
	-21 >>> 30 = 00000000000000000000000000000011 = 3
	-21 >>> 31 = 00000000000000000000000000000001 = 1
	</pre>

	<p>Как видно из примеров, эти операции аналогичны делению на 2n.</p>
	<p>Причем, если для положительных аргументов с ростом n результат закономерно стремится к 0, то для отрицательных предельным значением является -1.</p>

	<h1 id="title">
		Заключение
	</h1>

	<p>В этой лекции были рассмотрены основы лексического анализа программ Java.</p>
	<p>Для их записи применяется универсальная кодировка Unicode, позволяющая использовать любой язык помимо традиционного английского.</p>
	<p>Еще раз напомним, что использование Unicode возможно и необходимо в следующих конструкциях:</p>
	<p>- комментарии;</p>
	<p>- идентификаторы ;</p>
	<p>- символьные и строковые литералы.</p>
	<p>Остальные же ( пробелы, ключевые слова, числовые, булевские и null- литералы, разделители и операторы) легко записываются с применением лишь ASCII -символов.</p>
	<p>В то же время любой Unicode -символ также можно задать в виде специальной последовательности ASCII -символов.</p>
	<p>Во время анализа компилятор выделяет из текста программы &lt; пробелы &gt; (были рассмотрены все символы, которые рассматриваются как пробелы ) и комментарии, которые полностью удаляются из кода (были рассмотрены все виды комментариев, в частности комментарий разработчика).</p>
	<p>Пробелы и все виды комментариев служат для разбиения текста программы на лексемы.</p>
	<p>Были рассмотрены все виды лексем, в том числе все виды литералов.</p>
	<p>В дополнении были рассмотрены особенности применения различных операторов.</p>

	<script src="../../../../js/progressBarSetIni.js" type="text/javascript"></script>

        <div id="lessMenu" style="margin: 30px 0 0 0;">
            <hr />
            <a href="22.html"><div id="exitLess" ontouchstart="return true;"><img src="../../../../img/menu/pr.png" /></div></a>
            <a href="24.html"><div id="aaLess" ontouchstart="return true;"><img src="../../../../img/menu/ne.png" /></div></a>
        </div>

    </div>

    <script type="text/javascript" src="../../../../cordova.js"></script>
    <script type="text/javascript" src="../../../../js/global.js"></script>
    <script type="text/javascript">
        changeColor();
        if (localStorage.getItem("fSize") < 1) { fSize = 16; localStorage.setItem("fSize", 16); } else { fSize = localStorage.getItem("fSize"); }
        document.getElementById("pageBody").style.fontSize = fSize + "px";

        // goBackMenu
        document.addEventListener("backbutton", goBackMenu, false);
        function goBackMenu()
        {
            window.location.href = 'list.html';
        }

        function changeColor()
        {
            if (localStorage.getItem("colorSheme") <= 1)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#f0f0f0");
            }

            if (localStorage.getItem("colorSheme") == 2)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#212121");
                document.getElementById("pageBody").style.color = localStorage.getItem("#efefef");
            }

            if (localStorage.getItem("colorSheme") == 3)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#efe4d0");
            }
        }

        // bm
        if (localStorage.getItem("arrs") != null)
        {
            var arrs = JSON.parse(localStorage.getItem("arrs"));
        }
        else
        {
            var arrs = [];
        }

        var names = ["../acharter/ru/java/book/23.html", "Работа с операторами", "bm624"];

        function setzBm() { arrs.push(names); localStorage.setItem("arrs", JSON.stringify(arrs)); localStorage.setItem("bm624", 1); RefBms(); }

        window.onload = function() { RefBms(); }

        function RefBms()
        {
            if (localStorage.getItem("bm624") == 1) { document.getElementById("bma624").style.display = "block"; document.getElementById("bm624").style.display = "none"; } else { document.getElementById("bma624").style.display = "none"; document.getElementById("bm624").style.display = "block"; }
        }

        function dellBm() { for (var i = 0; i < arrs.length; i++) { if (arrs[i].indexOf("Работа с операторами") == 1) { arrs.splice(i, 1); localStorage.setItem("bm624", 0); RefBms(); localStorage.setItem("arrs", JSON.stringify(arrs)); } } }

        // sub menu
        var serTimeToClose = 1000;
        
        function OpenSettMenu()
        {
            document.getElementById("subMenuInLess").style.display = "block";
            timeToEvAct();
            serTimeToClose = 1;
        }
        
        function timeToEvAct()
        {
            setTimeout(function() { serTimeToClose = 0 }, 100);
        }
        
        window.addEventListener('click', function(e){
        
            if (serTimeToClose <= 0)
            {
                if (document.getElementById('subMenuInLess').contains(e.target))
                {
                    //
                }
                else
                {
                    document.getElementById("subMenuInLess").style.display = "none";
                }
            }
        });

    </script>

</body>
</html>
