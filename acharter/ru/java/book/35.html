

<!DOCTYPE html>

<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <link rel="stylesheet" type="text/css" href="../../../../css/read.css" />
    <title>Coder Book menu</title>
    <script type="text/javascript" src="../../../../higtline/scripts/shCore.js"></script>
    <script type="text/javascript" src="../../../../higtline/scripts/shBrushCSharp.js"></script>
    <link type="text/css" rel="stylesheet" href="../../../../higtline/styles/shCoreDefault.css"/>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <script src="../../../../js/Hyphenator.js" type="text/javascript"></script>
</head>

<body id="pageBody" class="hyphenate">

<!-- progress bar -->
<script src="../../../../js/progressBar.js" type="text/javascript"></script>
<div class="Reading-progress" id="progressBarType1"><span id="Progress-bar-top" class="bar-top" style="display: block !important;"></span></div>
<div class="Reading-progress" id="progressBarType2"><span id="Progress-bar-bottom" class="bar-bottom"></span></div>
<div class="Reading-progress" id="progressBarType3"><span id="Progress-bar-left" class="bar-left"></span></div>
<div class="Reading-progress" id="progressBarType4"><span id="Progress-bar-right" class="bar-right"></span></div>
<!-- progress bar -->


    <div id="lesonPage">

        <div id="lessMenu">
           <a id="exitLess" href="list.html" ontouchstart="return true;"><img src="../../../../img/menu/ex.png" /></a>
           <div id="aaLess" ontouchstart="return true;" onclick="OpenSettMenu();"><img src="../../../../img/menu/aa.png" /></div>
           <div id="subMenuInLess" style="display: none;">
                <a href="../../../../menu/setfontsize-ru.html" ontouchstart="return true;" id="pastMenuInLess">Размер текста</a>
                <a href="../../../../menu/setcolor-ru.html" ontouchstart="return true;" id="pastMenuInLess">Цветовая темы</a>
                <a href="../../../../menu/setProgressBar-ru.html" ontouchstart="return true;" id="pastMenuInLess" style="border: none;">Прогресс бар</a>
           </div>
           <div id="aaLess" ontouchstart="return true;">
            <div class="bmEdit" onclick="dellBm();" id="bma636" ontouchstart="return true;" style="display: none;"><img src="../../../../img/menu/bmlessa.png" /></div>
            <div class="bmEdit" onclick="setzBm();" id="bm636" ontouchstart="return true;" style="display: block;"><img src="../../../../img/menu/bmless.png" /></div>
           </div>
        </div>

        <hr />

	<!-- ПОЧАТОК -->

	<h1 id="title">
		Объявление классов
	</h1>

	<p>Рассмотрим базовые возможности объявления классов.</p>
	<p>Объявление класса состоит из заголовка и тела класса.</p>

	<h1 id="title">
		Заголовок класса
	</h1>

	<p>Вначале указываются модификаторы класса.</p>
	<p>Модификаторы доступа для класса уже обсуждались.</p>
	<p>Допустимым является public, либо его отсутствие – доступ по умолчанию.</p>
	<p>Класс может быть объявлен как final.</p>
	<p>В этом случае не допускается создание наследников такого класса.</p>
	<p>На своей ветке наследования он является последним.</p>
	<p>Класс String и классы-обертки, например, представляют собой final-классы.</p>
	<p>После списка модификаторов указывается ключевое слово class, а затем имя класса – корректный Java-идентификатор.</p>
	<p>Таким образом, кратчайшим объявлением класса может быть такой модуль компиляции:</p>

	<pre class="brush: csharp;">
	class A {}
	</pre>

	<p>Фигурные скобки обозначают тело класса, но о нем позже.</p>
	<p>Указанный идентификатор становится простым именем класса.</p>
	<p>Полное составное имя класса строится из полного составного имени пакета, в котором он объявлен (если это не безымянный пакет), и простого имени класса, разделенных точкой.</p>
	<p>Область видимости класса, где он может быть доступен по своему простому имени, – его пакет.</p>
	<p>Далее заголовок может содержать ключевое слово extends, после которого должно быть указано имя (простое или составное) доступного не- final класса.</p>
	<p>В этом случае объявляемый класс наследуется от указанного класса.</p>
	<p>Если выражение extends не применяется, то класс наследуется напрямую от Object.</p>
	<p>Выражение extends Object допускается и игнорируется.</p>

	<pre class="brush: csharp;">
	class Parent {}
	// = class Parent extends Object {}
	final class LastChild extends Parent {}
	// class WrongChild extends LastChild {}
	// ошибка!!
	</pre>

	<p>Попытка расширить final-класс приведет к ошибке компиляции.</p>
	<p>Если в объявлении класса A указано выражение extends B, то класс A называют прямым наследником класса B.</p>
	<p>Класс A считается наследником класса B, если:</p>
	<p>- A является прямым наследником B;</p>
	<p>- существует класс C, который является наследником B, а A является наследником C (это правило применяется рекурсивно).</p>
	<p>Таким образом можно проследить цепочки наследования на несколько уровней вверх.</p>
	<p>Если компилятор обнаруживает, что класс является своим наследником, возникает ошибка компиляции:</p>

	<pre class="brush: csharp;">
	// пример вызовет ошибку компиляции
	class A extends B {}
	class B extends C {}
	class C extends A {}
	// ошибка! Класс А стал своим наследником
	</pre>

	<p>Далее в заголовке может быть указано ключевое слово implements, за которым должно следовать перечисление через запятую имен (простых или составных, повторения запрещены) доступных интерфейсов:</p>

	<pre class="brush: csharp;">
	public final class String implements
	Serializable, Comparable {}
	</pre>

	<p>В этом случае говорят, что класс реализует перечисленные интерфейсы.</p>
	<p>Как видно из примера, класс может реализовывать любое количество интерфейсов.</p>
	<p>Если выражение implements отсутствует, то класс действительно не реализует никаких интерфейсов, здесь значений по умолчанию нет.</p>
	<p>Далее следует пара фигурных скобок, которые могут быть пустыми или содержать описание тела класса.</p>

	<h1 id="title">
		Тело класса
	</h1>

	<p>Тело класса может содержать объявление элементов (members) класса:</p>
	<p>- полей;</p>
	<p>- внутренних типов (классов и интерфейсов);</p>
	<p>- и остальных допустимых конструкций:</p>
	<p>* конструкторов;</p>
	<p>* инициализаторов</p>
	<p>* статических инициализаторов.</p>
	<p>Элементы класса имеют имена и передаются по наследству, не-элементы – нет.</p>
	<p>Для элементов простые имена указываются при объявлении, составные формируются из имени класса, или имени переменной объектного типа, и простого имени элемента.</p>
	<p>Областью видимости элементов является все объявление тела класса.</p>
	<p>Допускается применение любого из всех четырех модификаторов доступа.</p>
	<p>Напоминаем, что соглашения по именованию классов и их элементов обсуждались в прошлой лекции.</p>
	<p>Не-элементы не обладают именами, а потому не могут быть вызваны явно.</p>
	<p>Их вызывает сама виртуальная машина. Например, конструктор вызывается при создании объекта.</p>
	<p>По той же причине не-элементы не обладают модификаторами доступа.</p>
	<p>Элементами класса являются элементы, описанные в объявлении тела класса и переданные по наследству от класса-родителя (кроме Object – единственного класса, не имеющего родителя) и всех реализуемых интерфейсов при условии достаточного уровня доступа.</p>
	<p>Таким образом, если класс содержит элементы с доступом по умолчанию, то его наследники из разных пакетов будут обладать разным набором элементов.</p>
	<p>Классы из того же пакета могут пользоваться полным набором элементов, а из других пакетов – только protected и public.</p>
	<p>private -элементы по наследству не передаются.</p>
	<p>Поля и методы могут иметь одинаковые имена, поскольку обращение к полям всегда записывается без скобок, а к методам – всегда со скобками.</p>
	<p>Рассмотрим все эти конструкции более подробно.</p>

	<h1 id="title">
		Объявление полей
	</h1>

	<p>Объявление полей начинается с перечисления модификаторов.</p>
	<p>Возможно применение любого из трех модификаторов доступа, либо никакого вовсе, что означает уровень доступа по умолчанию.</p>
	<p>Поле может быть объявлено как final, это означает, что оно инициализируется один раз и больше не будет менять своего значения.</p>
	<p>Простейший способ работы с final-переменными - инициализация при объявлении:</p>

	<pre class="brush: csharp;">
	final double PI=3.1415;
	</pre>

	<p>Также допускается инициализация final-полей в конце каждого конструктора класса.</p>
	<p>Не обязательно использовать для инициализации константы компиляции, возможно обращение к различным функциям, например:</p>

	<pre class="brush: csharp;">
	final long creationTime = System.currentTimeMillis();
	</pre>

	<p>Данное поле будет хранить время создания объекта.</p>
	<p>Существует еще два специальных модификатора - transient и volatile.</p>
	<p>Они будут рассмотрены в соответствующих лекциях.</p>
	<p>После списка модификаторов указывается тип поля.</p>
	<p>Затем идет перечисление одного или нескольких имен полей с возможными инициализаторами:</p>

	<pre class="brush: csharp;">
	int a;
	int b=3, c=b+5, d;
	Point p, p1=null, p2=new Point();
	</pre>

	<p>Повторяющиеся имена полей запрещены.</p>
	<p>Указанный идентификатор при объявлении становится простым именем поля.</p>
	<p>Составное имя формируется из имени класса или имени переменной объектного типа, и простого имени поля.</p>
	<p>Областью видимости поля является все объявление тела класса.</p>
	<p>Запрещается использовать поле в инициализации других полей до его объявления.</p>

	<pre class="brush: csharp;">
	int y=x;
	int x=3;
	</pre>

	<p>Однако, в остальном поля можно объявлять и ниже их использования:</p>

	<pre class="brush: csharp;">
	class Point
	{
		int getX() {return x;}
		int y=getX();
		int x=3;
	}

	public static void main (String s[])
	{
		Point p=new Point();
		System.out.println(p.x+", "+p.y);
	}
	</pre>

	<p>Результатом будет:</p>

	<pre class="brush: csharp;">
	3, 0
	</pre>

	<p>Данный пример корректен, но для понимания его результата необходимо вспомнить, что все поля класса имеют значение по умолчанию:</p>
	<p>- для числовых полей примитивных типов – 0 ;</p>
	<p>- для булевского типа – false ;</p>
	<p>- для ссылочных – null.</p>
	<p>Таким образом, при инициализации переменной y был использован результат метода getX(), который вернул значение по умолчанию переменной x, то есть 0.</p>
	<p>Затем переменная x получила значение 3.</p>

	<script src="../../../../js/progressBarSetIni.js" type="text/javascript"></script>

        <div id="lessMenu" style="margin: 30px 0 0 0;">
            <hr />
            <a href="34.html"><div id="exitLess" ontouchstart="return true;"><img src="../../../../img/menu/pr.png" /></div></a>
            <a href="36.html"><div id="aaLess" ontouchstart="return true;"><img src="../../../../img/menu/ne.png" /></div></a>
        </div>

    </div>

    <script type="text/javascript" src="../../../../cordova.js"></script>
    <script type="text/javascript" src="../../../../js/global.js"></script>
    <script type="text/javascript">
        changeColor();
        if (localStorage.getItem("fSize") < 1) { fSize = 16; localStorage.setItem("fSize", 16); } else { fSize = localStorage.getItem("fSize"); }
        document.getElementById("pageBody").style.fontSize = fSize + "px";

        // goBackMenu
        document.addEventListener("backbutton", goBackMenu, false);
        function goBackMenu()
        {
            window.location.href = 'list.html';
        }

        function changeColor()
        {
            if (localStorage.getItem("colorSheme") <= 1)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#f0f0f0");
            }

            if (localStorage.getItem("colorSheme") == 2)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#212121");
                document.getElementById("pageBody").style.color = localStorage.getItem("#efefef");
            }

            if (localStorage.getItem("colorSheme") == 3)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#efe4d0");
            }
        }

        // bm
        if (localStorage.getItem("arrs") != null)
        {
            var arrs = JSON.parse(localStorage.getItem("arrs"));
        }
        else
        {
            var arrs = [];
        }

        var names = ["../acharter/ru/java/book/35.html", "Объявление классов", "bm636"];

        function setzBm() { arrs.push(names); localStorage.setItem("arrs", JSON.stringify(arrs)); localStorage.setItem("bm636", 1); RefBms(); }

        window.onload = function() { RefBms(); }

        function RefBms()
        {
            if (localStorage.getItem("bm636") == 1) { document.getElementById("bma636").style.display = "block"; document.getElementById("bm636").style.display = "none"; } else { document.getElementById("bma636").style.display = "none"; document.getElementById("bm636").style.display = "block"; }
        }

        function dellBm() { for (var i = 0; i < arrs.length; i++) { if (arrs[i].indexOf("Объявление классов") == 1) { arrs.splice(i, 1); localStorage.setItem("bm636", 0); RefBms(); localStorage.setItem("arrs", JSON.stringify(arrs)); } } }

        // sub menu
        var serTimeToClose = 1000;
        
        function OpenSettMenu()
        {
            document.getElementById("subMenuInLess").style.display = "block";
            timeToEvAct();
            serTimeToClose = 1;
        }
        
        function timeToEvAct()
        {
            setTimeout(function() { serTimeToClose = 0 }, 100);
        }
        
        window.addEventListener('click', function(e){
        
            if (serTimeToClose <= 0)
            {
                if (document.getElementById('subMenuInLess').contains(e.target))
                {
                    //
                }
                else
                {
                    document.getElementById("subMenuInLess").style.display = "none";
                }
            }
        });

    </script>

</body>
</html>
