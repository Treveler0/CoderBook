

<!DOCTYPE html>

<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <link rel="stylesheet" type="text/css" href="../../../../css/read.css" />
    <title>Coder Book menu</title>
    <script type="text/javascript" src="../../../../higtline/scripts/shCore.js"></script>
    <script type="text/javascript" src="../../../../higtline/scripts/shBrushCSharp.js"></script>
    <link type="text/css" rel="stylesheet" href="../../../../higtline/styles/shCoreDefault.css"/>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <script src="../../../../js/Hyphenator.js" type="text/javascript"></script>
</head>

<body id="pageBody" class="hyphenate">

<!-- progress bar -->
<script src="../../../../js/progressBar.js" type="text/javascript"></script>
<div class="Reading-progress" id="progressBarType1"><span id="Progress-bar-top" class="bar-top" style="display: block !important;"></span></div>
<div class="Reading-progress" id="progressBarType2"><span id="Progress-bar-bottom" class="bar-bottom"></span></div>
<div class="Reading-progress" id="progressBarType3"><span id="Progress-bar-left" class="bar-left"></span></div>
<div class="Reading-progress" id="progressBarType4"><span id="Progress-bar-right" class="bar-right"></span></div>
<!-- progress bar -->


    <div id="lesonPage">

        <div id="lessMenu">
           <a id="exitLess" href="list.html" ontouchstart="return true;"><img src="../../../../img/menu/ex.png" /></a>
           <div id="aaLess" ontouchstart="return true;" onclick="OpenSettMenu();"><img src="../../../../img/menu/aa.png" /></div>
           <div id="subMenuInLess" style="display: none;">
                <a href="../../../../menu/setfontsize-ru.html" ontouchstart="return true;" id="pastMenuInLess">Размер текста</a>
                <a href="../../../../menu/setcolor-ru.html" ontouchstart="return true;" id="pastMenuInLess">Цветовая темы</a>
                <a href="../../../../menu/setProgressBar-ru.html" ontouchstart="return true;" id="pastMenuInLess" style="border: none;">Прогресс бар</a>
           </div>
           <div id="aaLess" ontouchstart="return true;">
            <div class="bmEdit" onclick="dellBm();" id="bma611" ontouchstart="return true;" style="display: none;"><img src="../../../../img/menu/bmlessa.png" /></div>
            <div class="bmEdit" onclick="setzBm();" id="bm611" ontouchstart="return true;" style="display: block;"><img src="../../../../img/menu/bmless.png" /></div>
           </div>
        </div>

        <hr />

	<!-- ПОЧАТОК -->

	<h1 id="title">
		Платформа Java
	</h1>
	<p><i>Часть 3</i></p>

	<p>Итак, Java обладает длинной и непростой историей развития, однако настало время рассмотреть, что же получилось у создателей, какими свойствами обладает данная технология.</p>
	<p>Самое широко известное, и в то же время вызывающее самые бурные споры, свойство — много- или кроссплатформенность.</p>
	<p>Уже говорилось, что оно достигается за счет использования виртуальной машины JVM, которая является обычной программой, исполняемой операционной системой и предоставляющей Java -приложениям все необходимые возможности.</p>
	<p>Поскольку все параметры JVM специфицированы, то остается единственная задача - реализовать виртуальные машины на всех существующих и используемых платформах.</p>
	<p>Наличие виртуальной машины определяет многие свойства Java, однако сейчас остановимся на следующем вопросе - является Java языком компилируемым или интерпретируемым?</p>
	<p>На самом деле, используются оба подхода.</p>
	<p>Исходный код любой программы на языке Java представляется обычными текстовыми файлами, которые могут быть созданы в любом текстовом редакторе или специализированном средстве разработки и имеют расширение .java.</p>
	<p>Эти файлы подаются на вход Java-компилятора, который транслирует их в специальный Java байт-код.</p>
	<p>Именно этот компактный и эффективный набор инструкций поддерживается JVM и является неотъемлемой частью платформы Java.</p>
	<p>Результат работы компилятора сохраняется в бинарных файлах с расширением .class.</p>
	<p>Java-приложение, состоящее из таких файлов, подается на вход виртуальной машине, которая начинает их исполнять, или интерпретировать, так как сама является программой.</p>
	<p>Многие разработчики поначалу жестко критиковали смелый лозунг Sun "Write once, run everywhere", обнаруживая все больше и больше несоответствий и нестыковок на различных платформах.</p>
	<p>Однако надо признать, что они просто были слишком нетерпеливы.</p>
	<p>Java только появилась на свет, а первые версии спецификаций были недостаточно исчерпывающими.</p>
	<p>Очень скоро специалисты Sun пришли к выводу, что просто свободно публиковать спецификации (что уже делалось задолго до Java) недостаточно.</p>
	<p>Необходимо еще и создавать специальные процедуры проверки новых продуктов на соответствие стандартам.</p>
	<p>Первый такой тест для JVM содержал всего около 600 проверок, через год их число выросло до десяти тысяч и с тех пор все время увеличивается (именно его в свое время не смог пройти MS IE 4.0).</p>
	<p>Безусловно, авторы виртуальных машин все время совершенствовали их, устраняя ошибки и оптимизируя работу.</p>
	<p>Все-таки любая, даже очень хорошо задуманная технология требует времени для создания высококачественной реализации.</p>
	<p>Аналогичный путь развития сейчас проходит Java 2 Micro Edition ( J2ME ), но об этом позже.</p>
	<p>Следующим по важности свойством является объектная ориентированность Java, что всегда упоминается во всех статьях и пресс-релизах.</p>
	<p>Сам объектно-ориентированный подход (ООП) рассматривается в следующей лекции, однако важно подчеркнуть, что в Java практически все реализовано в виде объектов - потоки выполнения (threads) и потоки данных (streams), работа с сетью, работа с изображениями, с пользовательским интерфейсом, обработка ошибок и т.д.</p>
	<p>В конце концов, любое приложение на Java - это набор классов, описывающих новые типы объектов.</p>
	<p>Подробное рассмотрение объектной модели Java проводится на протяжении всего курса, однако обозначим основные особенности.</p>
	<p>Прежде всего, создатели отказались от множественного наследования.</p>
	<p>Было решено, что оно слишком усложняет и запутывает программы.</p>
	<p>В языке используется альтернативный подход - специальный тип " интерфейс ".</p>
	<p>Он подробно рассматривается в соответствующей лекции.</p>
	<p>Далее, в Java применяется строгая типизация.</p>
	<p>Это означает, что любая переменная и любое выражение имеет тип, известный уже на момент компиляции.</p>
	<p>Такой подход применен для упрощения выявления проблем, ведь компилятор сразу сообщает об ошибках и указывает их расположение в коде.</p>
	<p>Поиск же исключительных ситуаций (exceptions - так в Java называются некорректные ситуации) во время исполнения программы (runtime) потребует сложного тестирования, при этом причина дефекта может обнаружиться совсем в другом классе.</p>
	<p>Таким образом, нужно прикладывать дополнительные усилия при написании кода, зато существенно повышается его надежность (а это одна из основополагающих целей, для которых и создавался новый язык).</p>
	<p>В Java существует всего 8 типов данных, которые не являются объектами.</p>
	<p>Они были определены с самой первой версии и никогда не менялись.</p>
	<p>Это пять целочисленных типов: byte, short, int, long, а также к ним относят символьный char.</p>
	<p>Затем два дробных типа float и double и, наконец, булевский тип boolean.</p>
	<p>Такие типы называются простыми, или примитивными (от английского primitive), и они подробно рассматриваются в лекции, посвященной типам данных.</p>
	<p>Все остальные типы - объектные или ссылочные (англ. reference).</p>
	<p>Синтаксис Java почему-то многих ввел в заблуждение.</p>
	<p>Он действительно создан на основе синтаксиса языков C/C++, так что если посмотреть на исходный код программ, написанных на этих языках и на Java, то не сразу удается понять, какая из них на каком языке написана.</p>
	<p>Это почему-то дало многим повод думать, что Java - это упрощенный C++ с дополнительными возможностями, такими как garbage collector.</p>
	<p>Автоматический сборщик мусора ( garbage collector ) мы рассмотрим чуть ниже, но считать, что Java такой же язык, как и C++,- большое заблуждение.</p>
	<p>Конечно, разрабатывая новую технологию, авторы Java опирались на широко распространенный язык программирования по целому ряду причин.</p>
	<p>Во-первых, они сами на тот момент считали C++ своим основным инструментом.</p>
	<p>Во-вторых, зачем придумывать что-то новое, когда есть вполне подходящее старое?</p>
	<p>Наконец, очевидно, что незнакомый синтаксис отпугнет разработчиков и существенно осложнит внедрение нового языка, а ведь Java должна была максимально быстро получить широкое распространение.</p>
	<p>Поэтому синтаксис был лишь слегка упрощен, чтобы избежать слишком запутанных конструкций.</p>
	<p>Но, как уже говорилось, С++ принципиально не годился для новых задач, которые поставили себе разработчики из компании Sun, поэтому модель Java была построена заново, причем в соответствии с совсем другими целями.</p>
	<p>Дальнейшие лекции будут постепенно раскрывать конкретные различия.</p>
	<p>Что же касается объектной модели, то она скорее была построена по образцу таких языков, как Smalltalk от IBM, или разработанный еще в 60-е годы в Норвежском Вычислительном Центре язык Simula, на который ссылается сам создатель Java Джеймс Гослинг.</p>
	<p>Другое немаловажное свойство Java - легкость в освоении и разработке - также получило неоднозначную оценку.</p>
	<p>Действительно, авторы потрудились избавить программистов от наиболее распространенных ошибок, которые порой допускают даже опытные разработчики на C/C++.</p>
	<p>И первое место здесь занимает работа с памятью.</p>
	<p>В Java с самого начала был введен механизм автоматической сборки мусора (от английского garbage collector ).</p>
	<p>Предположим, программа создает некоторый объект, работает с ним, а дальше наступает момент, когда он больше уже не нужен.</p>
	<p>Необходимо освободить занимаемую память, чтобы не мешать операционной системе нормально функционировать.</p>
	<p>В С/С++ это необходимо делать явным образом из программы.</p>
	<p>Очевидно, что при таком подходе существует две опасности - либо удалить объект, который еще кому-то необходим (и если к нему действительно произойдет обращение, то возникнет ошибка), либо не удалять объект, ставший ненужным, а это означает утечку памяти, то есть программа начинает потреблять все большее количество оперативной памяти.</p>
	<p>При разработке на Java программист вообще не думает об освобождении памяти.</p>
	<p>Виртуальная машина сама подсчитывает количество ссылок на каждый объект, и если оно становится равным нулю, то такой объект помечается для обработки garbage collector.</p>
	<p>Таким образом, программист должен следить лишь за тем, чтобы не оставалось ссылок на ненужные объекты.</p>
	<p>Сборщик мусора - это фоновый поток исполнения, который регулярно просматривает существующие объекты и удаляет уже не нужные.</p>
	<p>Из программы никак нельзя повлиять на работу garbage collector, можно только явно инициировать его очередной проход с помощью стандартной функции.</p>
	<p>Ясно, что это существенно упрощает разработку программ, особенно для начинающих программистов.</p>
	<p>Однако опытные разработчики были недовольны тем, что они не могут полностью контролировать все, что происходит с их системой.</p>
	<p>Нет точной информации, когда именно будет удален объект, ставший ненужным, когда начнет работать (а значит, и занимать системные ресурсы) поток сборщика мусора и т.д.</p>
	<p>Но, при всем уважении к опыту таких программистов, необходимо отметить, что подавляющее количество сбоев программ, написанных на С/С++, приходится именно на некорректную работу с памятью, причем порой это случается даже с широко распространенными продуктами весьма серьезных компаний.</p>
	<p>Кроме того, особый упор делался на легкость освоения новой технологии.</p>
	<p>Как уже было сказано, ожидалось (и эти ожидания оправдались, в подтверждение правильности выбранного пути!), что Java должна получить максимально широкое применение, даже в тех компаниях, где никогда до этого не занимались программированием на таком уровне (бытовая техника типа тостеров и кофеварок, создание игр и других приложений для сотовых телефонов и т.д.).</p>
	<p>Был и целый ряд других соображений.</p>
	<p>Продукты для обычных пользователей, а не профессиональных программистов, должны быть особенно надежными.</p>
	<p>Internet стал Всемирной Сетью, поскольку появились непрофессиональные пользователи, а возможность создавать апплеты для них не менее привлекательна.</p>
	<p>Им требовался простой инструмент для создания надежных приложений.</p>
	<p>Наконец, Internet-бум 90-х годов набирал обороты и выдвигал новые, более жесткие требования к срокам разработки.</p>
	<p>Многолетние проекты, которые были в прошлом обычным делом, перестали отвечать потребностям заказчиков, новые системы надо было создавать максимум за год, а то и за считаные месяцы.</p>
	<p>Кроме введения garbage collector, были предприняты и другие шаги для облегчения разработки.</p>
	<p>Некоторые из них уже упоминались - отказ от множественного наследования, упрощение синтаксиса и др.</p>
	<p>Возможность создания многопоточных приложений была реализована в первой же версии Java (исследования показали, что это очень удобно для пользователей, а существующие стандарты опираются на телетайпные системы, которые устарели много лет назад).</p>
	<p>Другие особенности будут рассмотрены в следующих лекциях.</p>
	<p>Однако то, что создание и поддержка систем действительно проще на Java, чем на C/C++, давно является общепризнанным фактом.</p>
	<p>Впрочем, все-таки эти языки созданы для разных целей, и каждый имеет свои неоспоримые преимущества.</p>
	<p>Следующее важное свойство Java - безопасность.</p>

	<p>Изначальная нацеленность на распределенные приложения, и в особенности решение исполнять апплеты на клиентской машине, сделали вопрос защиты одним из самых приоритетных.</p>
	<p>При работе любой виртуальной машины Java действует целый комплекс мер.</p>
	<p>Далее приводится лишь краткое описание некоторых из них.</p>
	<p>Во-первых, это правила работы с памятью.</p>
	<p>Уже говорилось, что очистка памяти производится автоматически.</p>
	<p>Резервирование ее также определяется JVM, а не компилятором, или явным образом из программы, разработчик может лишь указать, что он хочет создать еще один новый объект.</p>
	<p>Указатели по физическим адресам отсутствуют принципиально.</p>
	<p>Во-вторых, наличие виртуальной машины-интерпретатора значительно облегчает отсечение опасного кода на каждом этапе работы.</p>
	<p>Сначала байт-код загружается в систему, как правило, в виде class-файлов.</p>
	<p>JVM тщательно проверяет, все ли они подчиняются общим правилам безопасности Java и не созданы ли злоумышленниками с помощью каких-то других средств (и не искажены ли при передаче).</p>
	<p>Затем, во время исполнения программы, интерпретатор легко может проверить каждое действие на допустимость.</p>
	<p>Возможности классов, которые были загружены с локального диска или по сети, существенно различаются (пользователь легко может назначать или отменять конкретные права).</p>
	<p>Например, апплеты по умолчанию никогда не получат доступ к локальной файловой системе.</p>
	<p>Такие встроенные ограничения есть во всех стандартных библиотеках Java.</p>
	<p>Наконец, существует механизм подписания апплетов и других приложений, загружаемых по сети.</p>
	<p>Специальный сертификат гарантирует, что пользователь получил код именно в том виде, в каком его выпустил производитель.</p>
	<p>Это, конечно, не дает дополнительных средств защиты, но позволяет клиенту либо отказаться от работы с приложениями ненадежных производителей, либо сразу увидеть, что в программу внесены неавторизованные изменения.</p>
	<p>В худшем случае он знает, кто ответственен за причиненный ущерб.</p>
	<p>Совокупность описанных свойств Java позволяет утверждать, что язык весьма приспособлен для разработки Internet- и интранет (внутренние сети корпораций)-приложений.</p>
	<p>Наконец, важная отличительная особенность Java - это его динамичность.</p>
	<p>Язык очень удачно задуман, в его развитии участвуют сотни тысяч разработчиков и многие крупные компании.</p>
	<p>Основные этапы этого развития кратко освещены в следующем разделе.</p>
	<p>Итак, подведем итоги. Java-платформа обладает следующими преимуществами:</p>
	<p><b>*</b> переносимость, или кроссплатформенность;</p>
	<p><b>*</b> объектная ориентированность, создана эффективная объектная модель;</p>
	<p><b>*</b> привычный синтаксис С/С++;</p>
	<p><b>*</b> встроенная и прозрачная модель безопасности;</p>
	<p><b>*</b> ориентация на Internet-задачи, сетевые распределенные приложения;</p>
	<p><b>*</b> динамичность, легкость развития и добавления новых возможностей;</p>
	<p><b>*</b> простота освоения.</p>
	<p>Но не следует считать, что более легкое освоение означает, что изучать язык не нужно вовсе.</p>
	<p>Чтобы писать действительно хорошие программы, создавать большие сложные системы, необходимо четкое понимание всех базовых концепций Java и используемых библиотек</p>
	<p>Именно этому и посвящен данный курс.</p>

	<script src="../../../../js/progressBarSetIni.js" type="text/javascript"></script>

        <div id="lessMenu" style="margin: 30px 0 0 0;">
            <hr />
            <a href="9.html"><div id="exitLess" ontouchstart="return true;"><img src="../../../../img/menu/pr.png" /></div></a>
            <a href="11.html"><div id="aaLess" ontouchstart="return true;"><img src="../../../../img/menu/ne.png" /></div></a>
        </div>

    </div>

    <script type="text/javascript" src="../../../../cordova.js"></script>
    <script type="text/javascript" src="../../../../js/global.js"></script>
    <script type="text/javascript">
        changeColor();
        if (localStorage.getItem("fSize") < 1) { fSize = 16; localStorage.setItem("fSize", 16); } else { fSize = localStorage.getItem("fSize"); }
        document.getElementById("pageBody").style.fontSize = fSize + "px";

        // goBackMenu
        document.addEventListener("backbutton", goBackMenu, false);
        function goBackMenu()
        {
            window.location.href = 'list.html';
        }

        function changeColor()
        {
            if (localStorage.getItem("colorSheme") <= 1)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#f0f0f0");
            }

            if (localStorage.getItem("colorSheme") == 2)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#212121");
                document.getElementById("pageBody").style.color = localStorage.getItem("#efefef");
            }

            if (localStorage.getItem("colorSheme") == 3)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#efe4d0");
            }
        }

        // bm
        if (localStorage.getItem("arrs") != null)
        {
            var arrs = JSON.parse(localStorage.getItem("arrs"));
        }
        else
        {
            var arrs = [];
        }

        var names = ["../acharter/ru/java/book/10.html", "ИР ч. 3: Сетевые компьютеры", "bm611"];

        function setzBm() { arrs.push(names); localStorage.setItem("arrs", JSON.stringify(arrs)); localStorage.setItem("bm611", 1); RefBms(); }

        window.onload = function() { RefBms(); }

        function RefBms()
        {
            if (localStorage.getItem("bm611") == 1) { document.getElementById("bma611").style.display = "block"; document.getElementById("bm611").style.display = "none"; } else { document.getElementById("bma611").style.display = "none"; document.getElementById("bm611").style.display = "block"; }
        }

        function dellBm() { for (var i = 0; i < arrs.length; i++) { if (arrs[i].indexOf("ИР ч. 3: Сетевые компьютеры") == 1) { arrs.splice(i, 1); localStorage.setItem("bm611", 0); RefBms(); localStorage.setItem("arrs", JSON.stringify(arrs)); } } }

        // sub menu
        var serTimeToClose = 1000;
        
        function OpenSettMenu()
        {
            document.getElementById("subMenuInLess").style.display = "block";
            timeToEvAct();
            serTimeToClose = 1;
        }
        
        function timeToEvAct()
        {
            setTimeout(function() { serTimeToClose = 0 }, 100);
        }
        
        window.addEventListener('click', function(e){
        
            if (serTimeToClose <= 0)
            {
                if (document.getElementById('subMenuInLess').contains(e.target))
                {
                    //
                }
                else
                {
                    document.getElementById("subMenuInLess").style.display = "none";
                }
            }
        });

    </script>

</body>
</html>
