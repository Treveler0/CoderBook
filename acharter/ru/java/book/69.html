

<!DOCTYPE html>

<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <link rel="stylesheet" type="text/css" href="../../../../css/read.css" />
    <title>Coder Book menu</title>
    <script type="text/javascript" src="../../../../higtline/scripts/shCore.js"></script>
    <script type="text/javascript" src="../../../../higtline/scripts/shBrushCSharp.js"></script>
    <link type="text/css" rel="stylesheet" href="../../../../higtline/styles/shCoreDefault.css"/>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <script src="../../../../js/Hyphenator.js" type="text/javascript"></script>
</head>

<body id="pageBody" class="hyphenate">

<!-- progress bar -->
<script src="../../../../js/progressBar.js" type="text/javascript"></script>
<div class="Reading-progress" id="progressBarType1"><span id="Progress-bar-top" class="bar-top" style="display: block !important;"></span></div>
<div class="Reading-progress" id="progressBarType2"><span id="Progress-bar-bottom" class="bar-bottom"></span></div>
<div class="Reading-progress" id="progressBarType3"><span id="Progress-bar-left" class="bar-left"></span></div>
<div class="Reading-progress" id="progressBarType4"><span id="Progress-bar-right" class="bar-right"></span></div>
<!-- progress bar -->


    <div id="lesonPage">

        <div id="lessMenu">
           <a id="exitLess" href="list.html" ontouchstart="return true;"><img src="../../../../img/menu/ex.png" /></a>
           <div id="aaLess" ontouchstart="return true;" onclick="OpenSettMenu();"><img src="../../../../img/menu/aa.png" /></div>
           <div id="subMenuInLess" style="display: none;">
                <a href="../../../../menu/setfontsize-ru.html" ontouchstart="return true;" id="pastMenuInLess">Размер текста</a>
                <a href="../../../../menu/setcolor-ru.html" ontouchstart="return true;" id="pastMenuInLess">Цветовая темы</a>
                <a href="../../../../menu/setProgressBar-ru.html" ontouchstart="return true;" id="pastMenuInLess" style="border: none;">Прогресс бар</a>
           </div>
           <div id="aaLess" ontouchstart="return true;">
            <div class="bmEdit" onclick="dellBm();" id="bma670" ontouchstart="return true;" style="display: none;"><img src="../../../../img/menu/bmlessa.png" /></div>
            <div class="bmEdit" onclick="setzBm();" id="bm670" ontouchstart="return true;" style="display: block;"><img src="../../../../img/menu/bmless.png" /></div>
           </div>
        </div>

        <hr />

	<!-- ПОЧАТОК -->

	<h1 id="title">
		Network layer (layer 3)
	</h1>

	<p>В предыдущей лекции мы рассмотрели второй уровень в модели OSI.</p>
	<p>Одним из ограничений этого уровня является использование "плоской" одноуровневой модели адресации.</p>
	<p>При попытке построить большую сеть, применяя для идентификации компьютеров MAC-адреса, мы получим огромное количество broadcast -трафика.</p>
	<p>Протокол, который поддерживается третьим уровнем, задействует иерархическую структуру для уникальной идентификации компьютеров.</p>
	<p>Для примера представим себе телефонную сеть. Она также имеет иерархическую адресацию.</p>
	<p>Например, в номере +7-095-101-12-34 первая цифра обозначает код страны, далее идет код области/города( 095 ), а затем указывается сам телефон (101-12-34).</p>
	<p>Последний номер также является составным.</p>
	<p>101 – это код станции, куда подключен телефон, а 12-34 определяет местоположение телефона.</p>
	<p>Благодаря такой иерархической структуре мы можем определить расположение требуемого абонента с наименьшими затратами.</p>
	<p>Иерархическая адресация для компьютерной сети также должна позволять устанавливать связь между разрозненными и удаленными сетями.</p>
	<p>На сетевом уровне (Network layer) существует несколько протоколов, которые позволяют передавать данные между сетями.</p>
	<p>Наиболее распространенным из них на сегодняшний день является IP.</p>
	<p>Его предшественник, протокол IPX, сейчас уже практически не используется в публичных сетях, но его можно найти в частных, закрытых сетях.</p>
	<p>Основное устройство, применяемое на 3-м уровне, называется роутером (router), или маршрутизатором.</p>
	<p>Он соединяет удаленные локальные сети (LAN), образуя глобальную сеть (Wide area network, WAN).</p>
	<p>Роутер имеет два или более сетевых интерфейса и таким образом подключен сразу к нескольким локальным сетям.</p>
	<p>Получив пакет с локального устройства или компьютера, принадлежащего к одной из LAN, роутер просматривает заголовок третьего уровня.</p>
	<p>На основании полученной информации роутер принимает решение, что делать с пакетом.</p>
	<p>Если получатель пакета находится в той же локальной сети, что и отправитель, роутер игнорирует его, поскольку сообщение, как уже рассматривалось, доставляется средствами более низкоуровневых протоколов (например, Ethernet ).</p>
	<p>В противном случае пакет нужно передать в одну из других LAN, к которым подключен роутер.</p>
	<p>Основная задача этого устройства – выбор пути, по которому будет пересылаться сообщение.</p>
	<p>Поскольку может существовать множество связей между некоторыми двумя сетями отправителя и получателя, роутер должен выбрать наиболее оптимальный путь.</p>
	<p>Пересылка пакета от одного узла сети к следующему называется hop (дословно – прыжок, скачок).</p>
	<p>Выбор очередного узла, которому роутер перешлет сообщение, может зависеть от многих факторов – загрузка сети, наименьший путь до получателя, стоимость трафика по различным маршрутам и т.д.</p>
	<p>Новая система адресации, вводимая на сетевом уровне, должна облегчать роутеру определение пути для доставки пакета через глобальные сети.</p>
	<p>Рассмотрим реализацию наиболее популярного на сегодняшний день протокола IP более подробно.</p>
	<p>При прохождении данных с верхних уровней на нижние на сетевом уровне к пакету добавляется служебный заголовок этого уровня.</p>
	<p>В заголовке IP-пакета содержится необходимая для дальнейшей передачи информация, такая как адреса отправителя и получателя.</p>
	<p>Понятие IP-адреса очень важно для понимания работы глобальных сетей, поэтому остановимся на нем более подробно.</p>

	<h1 id="title">
		IP-адрес
	</h1>

	<p>IP-адрес представляется 32-битным бинарным числом, которое часто записывают в виде 4 десятичных чисел, от 0 до 255 каждое.</p>
	<p>Например: 60.13.54.11, 130.154.201.1, 194.11.3.200.</p>
	<p>Логически он состоит из двух частей – адреса машины (host) и адреса сети (network).</p>
	<p>Сетевая часть IP-адреса показывает, к какой сети принадлежит адресат, а хост-часть (host) идентифицирует сетевое устройство в этой сети.</p>
	<p>Компьютеры с одинаковой сетевой частью находятся в одной локальной сети, а потому могут легко обмениваться данными.</p>
	<p>Если же у них различные network-ID, то, даже находясь в одном физическом сегменте, они обычно не могут "увидеть" друг друга.</p>
	<p>Так как IP-адрес состоит из 4-х октетов (так называют эти числа, поскольку 256=2^8 ), один, два или три первых октета могут использоваться для определения сетевого адреса, остальные задают host-части.</p>
	<p>Для удобства выделения адресов пользователям (ведь, как правило, организации требуется их сразу несколько), было введено 5 классов адресов.</p>
	<p>Их обозначают латинскими буквами от A до E.</p>
	<p>В открытых сетях используются первые три из них.</p>
	<p>В таблице ниже дано примерное разбиение IP-адресов на сетевую (N) и машинную (H) части в зависимости от класса сети.</p>

	<table>
		<tr>
			<th>Класс</th>
			<th>1</th>
			<th>2</th>
			<th>3</th>
			<th>4</th>
		</tr><tr>
			<td>А</td>
			<td>N</td>
			<td>H</td>
			<td>H</td>
			<td>H</td>
		</tr><tr>
			<td>B</td>
			<td>N</td>
			<td>N</td>
			<td>H</td>
			<td>H</td>
		</tr><tr>
			<td>C</td>
			<td>N</td>
			<td>N</td>
			<td>N</td>
			<td>H</td>
		</tr>
	</table>

	<h1 id="title">
		Класс A
	</h1>

	<p>В классе A для идентификации сети, к которой принадлежит адрес, используется первый октет, причем, первый бит всегда равен 0.</p>
	<p>Остальные октеты задают адрес хоста.</p>
	<p>Таким образом, адрес сети класса A может быть в диапазоне 0-126.</p>
	<p>127-й адрес зарезервирован для специального использования – все адреса, начинающиеся со 127, считаются локальными для сетевого адаптера, то есть всегда отправитель сам является и получателем.</p>
	<p>Остальные свободные три октета применяются для задания адреса хоста в данной сети.</p>
	<p>Это означает, что в одной сети может быть использовано до 2^24 адресов (из них два крайних, то есть 0 и 2^24-1, зарезервированы, они рассматриваются ниже).</p>
	<p>Стало быть, в каждой из 127 сетей класса A можно адресовать 16,777,214 машин.</p>

	<p>Диапазон адресов 10.0.0.0-10.255.255.255 в публичных сетях не используется.</p>
	<p>Эти адреса специально зарезервированы для применения в локальных сетях и глобальными маршрутизаторами не обрабатываются.</p>

	<h1 id="title">
		Класс B
	</h1>

	<p>В сети класса B первые два октета (причем, первый бит всегда равен 1, второй – 0) используются для определения сети, последние два октета – для определения адреса хоста.</p>
	<p>Диапазон адресов сети класса B лежит в пределах от 128.0.x.x до 191.255.x.x, что дает 16,384 таких сетей.</p>
	<p>В каждой из них может быть не более 65,534=2^16-2 адресов (два крайних адреса исключаются).</p>
	<p>В этой подсети зарезервированными для локального использования являются следующие адреса: 172.16.0.0-172.31.0.0.</p>

	<h1 id="title">
		Класс C
	</h1>

	<p>Диапазон сети класса C определяется первыми тремя октетами (первые биты всегда 110 ).</p>
	<p>И в десятичном виде эта сеть может начинаться со 192 по 223.</p>
	<p>Для определения адреса хоста используется последний октет.</p>
	<p>Таким образом, в каждой из 2,097,152 сетей класса C может быть задействовано 2^8 (без двух крайних) или 254 адреса.</p>
	<p>Зарезервированными для локального использования являются следующие адреса: 192.168.0.0-192.168.255.255.</p>

	<h1 id="title">
		Class D
	</h1>

	<p>Этот класс используется для особых задач (multicast-группы).</p>
	<p>Диапазон адресов – 224.0.0.0-239.255.255.255</p>

	<h1 id="title">
		Class E
	</h1>

	<p>Этот класс адресов зарезервирован для применения в будущем.</p>
	<p>Диапазон адресов – 240.0.0.0-247.255.255.255.</p>
	<p>Два адреса в каждой подсети являются зарезервированными.</p>
	<p>IP-адрес, в котором вся хост-часть состоит из бинарных нулей, используется для обозначения адреса самой сети.</p>
	<p>Например, сеть класса A может иметь адрес 112.0.0.0, а компьютер, подключенный к ней, – адрес 112.2.3.4.</p>
	<p>Адрес сети используется роутерами для задания маршрута.</p>
	<p>Второй зарезервированный адрес – броадкаст-адрес ( broadcast ).</p>
	<p>Этот адрес применяется, когда источник хочет послать данные всем устройствам в локальной сети.</p>
	<p>Для этого хост-часть заполняется бинарными единицами.</p>
	<p>Например, для рассмотренной сети 112.0.0.0 это будет адрес 112.255.255.255, а для сети класса B 171.10.0.0 броадкаст-адрес будет выглядеть как 171.10.255.255.</p>
	<p>Данные, посланные по адресу 171.10.255.255, будут получены всеми устройствами в сети 171.10.0.0.</p>

	<h1 id="title">
		Подсети. Маска подсети
	</h1>

	<p>Введение классов сетей во многом упростило задачу распределения адресов по организациям.</p>
	<p>Но не всегда имеет смысл использовать, например, целую сеть класса C, если в ней реально будет размещено лишь 10 компьютеров.</p>
	<p>Для более рационального использования сетей организуют подсети.</p>
	<p>Адрес подсети включает в себя сетевую часть от сети класса A, B или C и так называемое поле подсети (subnet field).</p>
	<p>Для этого значения выделяют дополнительные биты, принадлежащие хост-части (то есть для адреса подсети может быть использовано до 3-х октетов из сети класса A, до 2-х из сети класса B, и 1 для C, соответственно).</p>
	<p>Таких битов может быть минимально один (таким образом одна сеть разделяется на две подсети), а максимально столько, чтобы для хост-части оставалось еще два бита (иначе подсеть будет состоять лишь из двух служебных адресов - адреса подсети и броадкаст-адреса).</p>
	<p>Для сетей класса A это дает от 1 до 22 битов, для B – от 1 до 14 битов, для C – от 1 до 6.</p>
	<p>Разбиение на подсети уменьшает также размеры броадкаст-доменов, что необходимо, иначе для сети класса A броадкаст-запрос может рассылаться на 16 миллионов компьютеров.</p>
	<p>И если каждый из них пошлет хотя бы по одному такому запросу, нагрузка на сеть будет чрезмерно большой.</p>
	<p>Если же компьютер находится в выделенной подсети, то в соседние сети и подсети роутер пересылать броадкаст-запрос не будет, вследствие чего экономится полоса пропускания физических каналов связи.</p>
	<p>Для определения длины адреса подсети используется специальное понятие – маска подсети.</p>
	<p>Это число определяет, какая часть IP-адреса применяется для задания сетевой и подсетевой части. Маску подсети можно определить следующим образом.</p>
	<p>Запишем IP-адрес в бинарном виде. Все разряды, относящиеся к network- и subnet-части, заменим на 1, все значения, относящиеся к host-части,– на 0.</p>
	<p>В результате получим маску подсети.</p>
	<p>Например, маска подсети для целой сети класса A будет выглядеть как 255.0.0.0, для сети класса B: 255.255.0.0, для сети класса C – 255.255.255.0.</p>
	<p>Для разделения на подсети, как было сказано выше, нужно некоторые биты хост-части выделить для поля подсети.</p>
	<p>Например, маска 255.255.255.192 определяет подсеть класса C, для которой количество хостов будет равно 62.</p>

	<h1 id="title">
		Протоколы ARP, RARP
	</h1>

	<p>Когда формируется пакет для отправления, на сетевом уровне закладывается IP-адрес получателя.</p>
	<p>Однако для передачи на нижестоящий канальный уровень также нужно знать MAC-адрес.</p>
	<p>Для определения соответствия IP-адресу MAC-адреса существует ARP-протокол (Address Resolution Protocol, протокол определения адресов).</p>
	<p>Он работает следующим образом.</p>
	<p>Формируется специальный широковещательный ( broadcast ) запрос.</p>
	<p>Он рассматривался выше, его особенность в том, что его получают все устройства, подключенные к этой локальной сети.</p>
	<p>В таком запросе MAC-адрес получателя состоит из одних бинарных единиц, а в поле IP-адреса записывается именно тот адрес, для которого требуется определить MAC-адрес.</p>
	<p>Когда некий компьютер получает такой запрос, он сравнивает указанный IP-адрес со своим.</p>
	<p>Если они различаются, сообщение игнорируется.</p>
	<p>Если они равны, то формируется ответ, в котором по всем правилам указаны IP- и MAC-адреса отправителя, то есть искомой машины.</p>
	<p>Для того, чтобы не нагружать широковещательными запросами сеть, ARP-протокол поддерживает специальную ARP-таблицу, которая находится в оперативной памяти и хранит соответствие между IP- и MAC-адресами.</p>
	<p>После удачного определения MAC-адреса какого-нибудь узла сети делается соответствующая запись в таблицу, чтобы при следующей отсылке пакета не пришлось снова рассылать broadcast -запросы.</p>
	<p>Спустя некоторое время запись удаляется.</p>
	<p>Это позволяет автоматически подстраиваться под изменения в сети, ведь у какого-то узла могли изменить MAC- или IP-адрес.</p>
	<p>Если отправитель не находит IP-адрес получателя в ARP-таблице, то снова формируется и отправляется ARP-запрос.</p>
	<p>Протокол RARP (Reverse ARP – обратный ARP) действует наоборот – он известному MAC-адресу сопоставляет IP-адрес.</p>
	<p>Это необходимо, например, для работы таких протоколов, как BOOTP (Bootstrap Protocol, протокол автоматической настройки) и DHCP (Dynamic Host Configuration Protocol, протокол динамической конфигурации хостов).</p>
	<p>Их назначение – облегчить задачи системному администратору.</p>
	<p>Они позволяют не вводить IP-адрес в каждый компьютер локальной сети, а назначают их сами в автоматическом режиме.</p>
	<p>При загрузке очередной машины посылается broadcast -запрос – противоположный ARP-запросу.</p>
	<p>Если в ARP-запросе идет опрос "IP получателя известен, MAC получателя – ???", то в RARP-запросе "MAC получателя известен, IP - ???".</p>
	<p>Если в сети есть DHCP-сервер, он отвечает на RARP-запрос, указывая IP-адрес для этого компьютера (особенно это эффективно при большом количестве компьютеров).</p>
	<p>Оба эти протокола работают в рамках лишь локальной сети, поскольку все пакеты, направляемые в другие сети, обрабатываются и маршрутизируются роутером, поэтому знать MAC-адрес не требуется (отправитель указывает MAC-адрес самого роутера).</p>

	<script src="../../../../js/progressBarSetIni.js" type="text/javascript"></script>

        <div id="lessMenu" style="margin: 30px 0 0 0;">
            <hr />
            <a href="68.html"><div id="exitLess" ontouchstart="return true;"><img src="../../../../img/menu/pr.png" /></div></a>
            <a href="70.html"><div id="aaLess" ontouchstart="return true;"><img src="../../../../img/menu/ne.png" /></div></a>
        </div>

    </div>

    <script type="text/javascript" src="../../../../cordova.js"></script>
    <script type="text/javascript" src="../../../../js/global.js"></script>
    <script type="text/javascript">
        changeColor();
        if (localStorage.getItem("fSize") < 1) { fSize = 16; localStorage.setItem("fSize", 16); } else { fSize = localStorage.getItem("fSize"); }
        document.getElementById("pageBody").style.fontSize = fSize + "px";

        // goBackMenu
        document.addEventListener("backbutton", goBackMenu, false);
        function goBackMenu()
        {
            window.location.href = 'list.html';
        }

        function changeColor()
        {
            if (localStorage.getItem("colorSheme") <= 1)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#f0f0f0");
            }

            if (localStorage.getItem("colorSheme") == 2)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#212121");
                document.getElementById("pageBody").style.color = localStorage.getItem("#efefef");
            }

            if (localStorage.getItem("colorSheme") == 3)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#efe4d0");
            }
        }

        // bm
        if (localStorage.getItem("arrs") != null)
        {
            var arrs = JSON.parse(localStorage.getItem("arrs"));
        }
        else
        {
            var arrs = [];
        }

        var names = ["../acharter/ru/java/book/69.html", "Network layer (layer 3)", "bm670"];

        function setzBm() { arrs.push(names); localStorage.setItem("arrs", JSON.stringify(arrs)); localStorage.setItem("bm670", 1); RefBms(); }

        window.onload = function() { RefBms(); }

        function RefBms()
        {
            if (localStorage.getItem("bm670") == 1) { document.getElementById("bma670").style.display = "block"; document.getElementById("bm670").style.display = "none"; } else { document.getElementById("bma670").style.display = "none"; document.getElementById("bm670").style.display = "block"; }
        }

        function dellBm() { for (var i = 0; i < arrs.length; i++) { if (arrs[i].indexOf("Network layer (layer 3)") == 1) { arrs.splice(i, 1); localStorage.setItem("bm670", 0); RefBms(); localStorage.setItem("arrs", JSON.stringify(arrs)); } } }

        // sub menu
        var serTimeToClose = 1000;
        
        function OpenSettMenu()
        {
            document.getElementById("subMenuInLess").style.display = "block";
            timeToEvAct();
            serTimeToClose = 1;
        }
        
        function timeToEvAct()
        {
            setTimeout(function() { serTimeToClose = 0 }, 100);
        }
        
        window.addEventListener('click', function(e){
        
            if (serTimeToClose <= 0)
            {
                if (document.getElementById('subMenuInLess').contains(e.target))
                {
                    //
                }
                else
                {
                    document.getElementById("subMenuInLess").style.display = "none";
                }
            }
        });

    </script>

</body>
</html>
