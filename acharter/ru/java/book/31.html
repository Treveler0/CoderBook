

<!DOCTYPE html>

<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <link rel="stylesheet" type="text/css" href="../../../../css/read.css" />
    <title>Coder Book menu</title>
    <script type="text/javascript" src="../../../../higtline/scripts/shCore.js"></script>
    <script type="text/javascript" src="../../../../higtline/scripts/shBrushCSharp.js"></script>
    <link type="text/css" rel="stylesheet" href="../../../../higtline/styles/shCoreDefault.css"/>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <script src="../../../../js/Hyphenator.js" type="text/javascript"></script>
</head>

<body id="pageBody" class="hyphenate">

<!-- progress bar -->
<script src="../../../../js/progressBar.js" type="text/javascript"></script>
<div class="Reading-progress" id="progressBarType1"><span id="Progress-bar-top" class="bar-top" style="display: block !important;"></span></div>
<div class="Reading-progress" id="progressBarType2"><span id="Progress-bar-bottom" class="bar-bottom"></span></div>
<div class="Reading-progress" id="progressBarType3"><span id="Progress-bar-left" class="bar-left"></span></div>
<div class="Reading-progress" id="progressBarType4"><span id="Progress-bar-right" class="bar-right"></span></div>
<!-- progress bar -->


    <div id="lesonPage">

        <div id="lessMenu">
           <a id="exitLess" href="list.html" ontouchstart="return true;"><img src="../../../../img/menu/ex.png" /></a>
           <div id="aaLess" ontouchstart="return true;" onclick="OpenSettMenu();"><img src="../../../../img/menu/aa.png" /></div>
           <div id="subMenuInLess" style="display: none;">
                <a href="../../../../menu/setfontsize-ru.html" ontouchstart="return true;" id="pastMenuInLess">Размер текста</a>
                <a href="../../../../menu/setcolor-ru.html" ontouchstart="return true;" id="pastMenuInLess">Цветовая темы</a>
                <a href="../../../../menu/setProgressBar-ru.html" ontouchstart="return true;" id="pastMenuInLess" style="border: none;">Прогресс бар</a>
           </div>
           <div id="aaLess" ontouchstart="return true;">
            <div class="bmEdit" onclick="dellBm();" id="bma632" ontouchstart="return true;" style="display: none;"><img src="../../../../img/menu/bmlessa.png" /></div>
            <div class="bmEdit" onclick="setzBm();" id="bm632" ontouchstart="return true;" style="display: block;"><img src="../../../../img/menu/bmless.png" /></div>
           </div>
        </div>

        <hr />

	<!-- ПОЧАТОК -->

	<h1 id="title">
		Импорт-выражения
	</h1>

	<p>Как будет рассмотрено ниже, область видимости объявления типа - пакет, в котором он располагается.</p>
	<p>Это означает, что внутри данного пакета допускается обращение к типу по его простому имени.</p>
	<p>Из всех других пакетов необходимо обращаться по составному имени, то есть полное имя пакета плюс простое имя типа, разделенные точкой.</p>
	<p>Поскольку пакеты могут иметь довольно длинные имена (например, дополнительный пакет в составе JDK1.2 называется com.sun.image.codec.jpeg ), а тип может многократно использоваться в модуле компиляции, такое ограничение может привести к усложнению исходного кода и сложностям в разработке.</p>
	<p>Для решения этой проблемы вводятся import -выражения, позволяющие импортировать типы в модуль компиляции и далее обращаться к ним по простым именам.</p>
	<p>Существует два вида таких выражений:</p>
	<p>- импорт одного типа;</p>
	<p>- импорт пакета.</p>
	<p>Важно подчеркнуть, что импортирующие выражения являются, по сути, подсказкой для компилятора.</p>
	<p>Он пользуется ими, чтобы для каждого простого имени типа из другого пакета получить его полное имя, которое и попадает в компилированный код.</p>
	<p>Это означает, что импортирующих выражений может быть очень много, включая и те, что импортируют неиспользуемые пакеты и типы, но это никак не отразится ни на размере, ни на качестве бинарного кода.</p>
	<p>Также безразлично, обращаться к типу по его полному имени, или включить его в импортирующее выражение и обращаться по простому имени – результат будет один и тот же.</p>
	<p>Импортирующие выражения имеют эффект только внутри модуля компиляции, в котором они объявлены.</p>
	<p>Все объявления типов высшего уровня, находящиеся в этом же модуле, могут одинаково пользоваться импортированными типами.</p>
	<p>К импортированным типам возможен и обычный доступ по полному имени.</p>
	<p>Выражение, импортирующее один тип, записывается с помощью ключевого слова import и полного имени типа.</p>
	<p>Например:</p>

	<pre class="brush: csharp;">
	import java.net.URL;
	</pre>

	<p>Такое выражение означает, что в дальнейшем в этом модуле компиляции простое имя URL будет обозначать одноименный класс из пакета java.net.</p>
	<p>Попытка импортировать тип, недоступный на момент компиляции, вызовет ошибку.</p>
	<p>Если один и тот же тип импортируется несколько раз, то это не создает ошибки, а дублированные выражения игнорируются.</p>
	<p>Если же импортируются типы с одинаковыми простыми именами из разных пакетов, то такая ситуация породит ошибку компиляции.</p>
	<p>Выражение, импортирующее пакет, включает в себя полное имя пакета следующим образом.</p>

	<pre class="brush: csharp;">
	import java.awt.*;
	</pre>

	<p>Это выражение делает доступными все типы, находящиеся в пакете java.awt, по их простому имени.</p>
	<p>Попытка импортировать пакет, недоступный на момент компиляции, вызовет ошибку.</p>
	<p>Импортирование одного пакета многократно не создает ошибки, дублированные выражения игнорируются. Обратите внимание, что импортировать вложенный пакет нельзя.</p>
	<p>Например:</p>

	<pre class="brush: csharp;">
	// пример вызовет ошибку компиляции
	import java.awt.image;
	</pre>

	<p>Создается впечатление, что теперь мы можем обращаться к типам пакета java.awt.image по упрощенному имени, например, image.ImageFilter.</p>
	<p>На самом деле пример вызовет ошибку компиляции, так как данное выражение расценивается как импорт типа, а в пакете java.awt отсутствует тип image.</p>
	<p>Аналогично, выражение</p>

	<pre class="brush: csharp;">
	import java.awt.*;
	</pre>

	<p>не делает более доступными классы пакета java.awt.image, их необходимо импортировать отдельно.</p>
	<p>Поскольку пакет java.lang содержит типы, без которых невозможно создать ни одну программу, он неявным образом импортируется в каждый модуль компиляции.</p>
	<p>Таким образом, все типы из этого пакета доступны по их простым именам без каких-либо дополнительных усилий.</p>
	<p>Попытка импортировать данный пакет еще раз будет проигнорирована.</p>
	<p>Допускается одновременно импортировать пакет и какой-нибудь тип из него:</p>

	<pre class="brush: csharp;">
	import java.awt.*;
	import java.awt.Point;
	</pre>

	<p>Может возникнуть вопрос, как же лучше поступать – импортировать типы по отдельности или весь пакет сразу?</p>
	<p>Есть ли какая-нибудь разница в этих подходах?</p>
	<p>Разница заключается в алгоритме работы компилятора, который приводит каждое простое имя к полному.</p>
	<p>Он состоит из трех шагов:</p>
	<p>- сначала просматриваются выражения, импортирующие типы;</p>
	<p>- затем другие типы, объявленные в текущем пакете, в том числе в текущем модуле компиляции;</p>
	<p>- наконец, просматриваются выражения, импортирующие пакеты.</p>
	<p>Таким образом, если тип явно импортирован, то невозможно ни объявление нового типа с таким же именем, ни доступ по простому имени к одноименному типу в текущем пакете.</p>
	<p>Например:</p>

	<pre class="brush: csharp;">
	// пример вызовет ошибку компиляции
	package my_geom;
	import java.awt.Point;
	class Point { }
	</pre>

	<p>Этот модуль вызовет ошибку компиляции, так как имя Point в объявлении высшего типа будет рассматриваться как обращение к импортированному классу java.awt.Point, а его переопределять, конечно, нельзя.</p>
	<p>Если в пакете объявлен тип:</p>

	<pre class="brush: csharp;">
	package my_geom;
	class Point { }
	</pre>

	<p>то в другом модуле компиляции:</p>

	<pre class="brush: csharp;">
	package my_geom;
	import java.awt.Point;
	
	class Line
	{
		void main()
		{
			System.out.println(new Point());
		}
	}
	</pre>

	<p>складывается неопределенная ситуация – какой из классов, my_geom.Point или java.awt.Point, будет использоваться при создании объекта?</p>
	<p>Результатом будет:</p>

	<pre class="brush: csharp;">
	java.awt.Point[x=0,y=0]
	</pre>

	<p>В соответствии с правилами, имя Point было трактовано на основе импорта типа.</p>
	<p>К классу текущего пакета все еще можно обращаться по полному имени: my_geom.Point.</p>
	<p>Если бы рассматривался безымянный пакет, то обратиться к такому "перекрытому" типу было бы уже невозможно, что является дополнительным аргументом к рекомендации располагать важные программ</p>
	<p>Теперь рассмотрим импорт пакета.</p>
	<p>Его еще называют "импорт по требованию", подразумевая, что никакой "загрузки" всех типов импортированного пакета сразу при указании импортирующего выражения не происходит, их полные имена подставляются по мере использования простых имен в коде.</p>
	<p>Можно импортировать пакет и задействовать только один тип (или даже ни одного) из него.</p>
	<p>Изменим рассмотренный выше пример:</p>

	<pre class="brush: csharp;">
	package my_geom;
	import java.awt.*;
	
	class Line
	{
		void main()
		{
			System.out.println(new Point());
			System.out.println(new Rectangle());
		}
	}
	</pre>

	<p>Теперь результатом будет:</p>

	<pre class="brush: csharp;">
	my_geom.Point@92d342
	java.awt.Rectangle[x=0,y=0,width=0,height=0]
	</pre>

	<p>Тип Point нашелся в текущем пакете, поэтому компилятору не пришлось выполнять поиск по пакету java.awt.</p>
	<p>Второй объект порождается от класса Rectangle, которого не существует в текущем пакете, зато он обнаруживается в java.awt.</p>
	<p>Также корректен теперь пример:</p>

	<pre class="brush: csharp;">
	package my_geom;
	import java.awt.*;
	class Point { }
	</pre>

	<p>Таким образом, импорт пакета не препятствует объявлению новых типов или обращению к существующим типам текущего пакета по простым именам.</p>
	<p>Если все же нужно работать именно с внешними типами, то можно воспользоваться импортом типа, или обращаться к ним по полным именам.</p>
	<p>Кроме того, считается, что импорт конкретных типов помогает при прочтении кода сразу понять, какие внешние классы и интерфейсы используются в этом модуле компиляции.</p>
	<p>Однако полностью полагаться на такое соображение не стоит, так как возможны случаи, когда импортированные типы не используются и, напротив, в коде стоит обращение к другим типам по полному имени.</p>

	<h1 id="title">
		Объявление верхнего уровня
	</h1>

	<p>Далее модуль компиляции может содержать одно или несколько объявлений классов и интерфейсов.</p>
	<p>Подробно формат такого объявления рассматривается в следующих лекциях, однако приведем краткую информацию и здесь.</p>
	<p>Объявление класса начинается с ключевого слова class, интерфейса – interface. Далее указывается имя типа, а затем в фигурных скобках описывается тело типа.</p>
	<p>Например:</p>

	<pre class="brush: csharp;">
	package first;
	class FirstClass { }
	interface MyInterface { }
	</pre>

	<p>Область видимости типа - пакет, в котором он описан.</p>
	<p>Из других пакетов к типу можно обращаться либо по составному имени, либо с помощью импортирующих выражений.</p>
	<p>Однако, кроме области видимости, в Java также есть средства разграничения доступа.</p>
	<p>По умолчанию тип объявляется доступным только для других типов своего пакета.</p>
	<p>Чтобы другие пакеты также могли использовать его, можно указать ключевое слово public:</p>

	<pre class="brush: csharp;">
	package second;
	public class OpenClass { }
	public interface PublicInterface { }
	</pre>

	<p>Такие типы доступны для всех пакетов.</p>
	<p>Объявления верхнего уровня описывают классы и интерфейсы, хранящиеся в пакетах.</p>
	<p>В версии Java 1.1 были введены внутренние (inner) типы, которые объявляются внутри других типов и являются их элементами наряду с полями и методами.</p>
	<p>Данная возможность является вспомогательной и довольно запутанной, поэтому в курсе подробно не рассматривается, хотя некоторые примеры и пояснения помогут в целом ее освоить.</p>
	<p>Если пакеты, исходный и бинарный код хранятся в файловой системе, то Java может накладывать ограничение на объявления классов в модулях компиляции.</p>
	<p>Это ограничение создает ошибку компиляции в случае, если описание типа не обнаруживается в файле с названием, составленным из имени типа и расширения (например, java), и при этом:</p>
	<p>- тип объявлен как public и, значит, может использоваться из других пакетов;</p>
	<p>- тип используется из других модулей компиляции в своем пакете.</p>
	<p>Эти условия означают, что в модуле компиляции может быть максимум один тип, отвечающий этим условиям.</p>
	<p>Другими словами, в модуле компиляции может быть максимум один public тип, и его имя и имя файла должны совпадать.</p>
	<p>Если же в нем есть не- public типы, имена которых не совпадают с именем файла, то они должны использоваться только внутри этого модуля компиляции.</p>
	<p>Если же для хранения пакетов применяется БД, то такое ограничение не должно накладываться.</p>
	<p>На практике же программисты зачастую помещают в один модуль компиляции только один тип, независимо от того, public он или нет.</p>
	<p>Это существенно упрощает работу с ними.</p>
	<p>Например, описание класса space.sun.Size хранится в файле space\sun\Size.java, а бинарный код – в файле Size.class в том же каталоге.</p>
	<p>Именно так устроены все стандартные библиотеки Java.</p>
	<p>Обратите внимание, что при объявлении классов вполне допускаются перекрестные обращения.</p>
	<p>В частности, следующий пример совершенно корректен:</p>

	<pre class="brush: csharp;">
	package test;

	/*
		Класс Human, описывающий человека
	*/

	class Human
	{
		String name;
		// принадлежащая человеку машина
		Car car;
	}

	/*
	Класс Car, описывающий автомобиль
	*/

	class Car
	{
		String model;
		// водитель, управляющий машиной
		Human driver;
	}
	</pre>

	<p>Кроме того, класс Car был использован раньше, чем был объявлен.</p>
	<p>Такое перекрестное применение типов также допускается в случае, если они находятся в разных пакетах.</p>
	<p>Компилятор должен поддерживать возможность транслировать их одновременно.</p>

	<h1 id="title">
		Уникальность имен пакетов
	</h1>

	<p>Поскольку Java создавался как язык, предназначенный для распространения приложений через Internet, а приложения состоят из структуры пакетов, необходимо предпринять некоторые усилия, чтобы не произошел конфликт имен.</p>
	<p>Имена двух используемых пакетов могут совпасть по прошествии значительного времени после их создания.</p>
	<p>Исправить такое положение обычному программисту будет крайне затруднительно.</p>
	<p>Поэтому создатели Java предлагают следующий способ уникального именования пакетов.</p>
	<p>Если программа создается разработчиком, у которого есть Internet-сайт, либо же он работает на организацию, у которой имеется сайт, и доменное имя такого сайта, например, company.com, то имена пакетов должны начинаться с этих же слов, выписанных в обратном порядке: com.company.</p>
	<p>Дальнейшие вложенные пакеты могут носить названия подразделений компании, пакетов, фамилии разработчиков, имена компьютеров и т.д.</p>
	<p>Таким образом, пакет верхнего уровня всегда записывается ASCII-буквами в нижнем регистре и может иметь одно из следующих имен:</p>
	<p>- трехбуквенные com, edu, gov, mil, net, org, int (этот список расширяется);</p>
	<p>- двухбуквенные, обозначающие имена стран, такие как ru, su, de, uk и другие.</p>
	<p>Если имя сайта противоречит требованиям к идентификаторам Java, то можно предпринять следующие шаги:</p>
	<p>- если в имени стоит запрещенный символ, например, тире, то его можно заменить знаком подчеркивания;</p>
	<p>- если имя совпадает с зарезервированным словом, можно в конце добавить знак подчеркивания;</p>
	<p>- если имя начинается с цифры, можно в начале добавить знак подчеркивания.</p>
	<p>Примеры имен пакетов, составленных по таким правилам:</p>
	<p>- com.sun.image.codec.jpeg</p>
	<p>- org.omg.CORBA.ORBPackage</p>
	<p>- oracle.jdbc.driver.OracleDriver</p>
	<p>Однако, конечно, никто не требует, чтобы Java-пакеты были обязательно доступны на Internet-сайте, который дал им имя.</p>
	<p>Скорее была сделана попытка воспользоваться существующей системой имен вместо того, чтобы создавать новую для именования библиотек.</p>

	<script src="../../../../js/progressBarSetIni.js" type="text/javascript"></script>

        <div id="lessMenu" style="margin: 30px 0 0 0;">
            <hr />
            <a href="30.html"><div id="exitLess" ontouchstart="return true;"><img src="../../../../img/menu/pr.png" /></div></a>
            <a href="32.html"><div id="aaLess" ontouchstart="return true;"><img src="../../../../img/menu/ne.png" /></div></a>
        </div>

    </div>

    <script type="text/javascript" src="../../../../cordova.js"></script>
    <script type="text/javascript" src="../../../../js/global.js"></script>
    <script type="text/javascript">
        changeColor();
        if (localStorage.getItem("fSize") < 1) { fSize = 16; localStorage.setItem("fSize", 16); } else { fSize = localStorage.getItem("fSize"); }
        document.getElementById("pageBody").style.fontSize = fSize + "px";

        // goBackMenu
        document.addEventListener("backbutton", goBackMenu, false);
        function goBackMenu()
        {
            window.location.href = 'list.html';
        }

        function changeColor()
        {
            if (localStorage.getItem("colorSheme") <= 1)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#f0f0f0");
            }

            if (localStorage.getItem("colorSheme") == 2)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#212121");
                document.getElementById("pageBody").style.color = localStorage.getItem("#efefef");
            }

            if (localStorage.getItem("colorSheme") == 3)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#efe4d0");
            }
        }

        // bm
        if (localStorage.getItem("arrs") != null)
        {
            var arrs = JSON.parse(localStorage.getItem("arrs"));
        }
        else
        {
            var arrs = [];
        }

        var names = ["../acharter/ru/java/book/31.html", "Пакеты (ч. 2)", "bm632"];

        function setzBm() { arrs.push(names); localStorage.setItem("arrs", JSON.stringify(arrs)); localStorage.setItem("bm632", 1); RefBms(); }

        window.onload = function() { RefBms(); }

        function RefBms()
        {
            if (localStorage.getItem("bm632") == 1) { document.getElementById("bma632").style.display = "block"; document.getElementById("bm632").style.display = "none"; } else { document.getElementById("bma632").style.display = "none"; document.getElementById("bm632").style.display = "block"; }
        }

        function dellBm() { for (var i = 0; i < arrs.length; i++) { if (arrs[i].indexOf("Пакеты (ч. 2)") == 1) { arrs.splice(i, 1); localStorage.setItem("bm632", 0); RefBms(); localStorage.setItem("arrs", JSON.stringify(arrs)); } } }

        // sub menu
        var serTimeToClose = 1000;
        
        function OpenSettMenu()
        {
            document.getElementById("subMenuInLess").style.display = "block";
            timeToEvAct();
            serTimeToClose = 1;
        }
        
        function timeToEvAct()
        {
            setTimeout(function() { serTimeToClose = 0 }, 100);
        }
        
        window.addEventListener('click', function(e){
        
            if (serTimeToClose <= 0)
            {
                if (document.getElementById('subMenuInLess').contains(e.target))
                {
                    //
                }
                else
                {
                    document.getElementById("subMenuInLess").style.display = "none";
                }
            }
        });

    </script>

</body>
</html>
