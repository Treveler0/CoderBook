

<!DOCTYPE html>

<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <link rel="stylesheet" type="text/css" href="../../../../css/read.css" />
    <title>Coder Book menu</title>
    <script type="text/javascript" src="../../../../higtline/scripts/shCore.js"></script>
    <script type="text/javascript" src="../../../../higtline/scripts/shBrushCSharp.js"></script>
    <link type="text/css" rel="stylesheet" href="../../../../higtline/styles/shCoreDefault.css"/>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <script src="../../../../js/Hyphenator.js" type="text/javascript"></script>
</head>

<body id="pageBody" class="hyphenate">

<!-- progress bar -->
<script src="../../../../js/progressBar.js" type="text/javascript"></script>
<div class="Reading-progress" id="progressBarType1"><span id="Progress-bar-top" class="bar-top" style="display: block !important;"></span></div>
<div class="Reading-progress" id="progressBarType2"><span id="Progress-bar-bottom" class="bar-bottom"></span></div>
<div class="Reading-progress" id="progressBarType3"><span id="Progress-bar-left" class="bar-left"></span></div>
<div class="Reading-progress" id="progressBarType4"><span id="Progress-bar-right" class="bar-right"></span></div>
<!-- progress bar -->


    <div id="lesonPage">

        <div id="lessMenu">
           <a id="exitLess" href="list.html" ontouchstart="return true;"><img src="../../../../img/menu/ex.png" /></a>
           <div id="aaLess" ontouchstart="return true;" onclick="OpenSettMenu();"><img src="../../../../img/menu/aa.png" /></div>
           <div id="subMenuInLess" style="display: none;">
                <a href="../../../../menu/setfontsize-ru.html" ontouchstart="return true;" id="pastMenuInLess">Размер текста</a>
                <a href="../../../../menu/setcolor-ru.html" ontouchstart="return true;" id="pastMenuInLess">Цветовая темы</a>
                <a href="../../../../menu/setProgressBar-ru.html" ontouchstart="return true;" id="pastMenuInLess" style="border: none;">Прогресс бар</a>
           </div>
           <div id="aaLess" ontouchstart="return true;">
            <div class="bmEdit" onclick="dellBm();" id="bma665" ontouchstart="return true;" style="display: none;"><img src="../../../../img/menu/bmlessa.png" /></div>
            <div class="bmEdit" onclick="setzBm();" id="bm665" ontouchstart="return true;" style="display: block;"><img src="../../../../img/menu/bmless.png" /></div>
           </div>
        </div>

        <hr />

	<!-- ПОЧАТОК -->

	<h1 id="title">
		Синхронизация
	</h1>

	<p>При многопоточной архитектуре приложения возможны ситуации, когда несколько потоков будут одновременно работать с одними и теми же данными, используя их значения и присваивая новые.</p>
	<p>В таком случае результат работы программы становится невозможно предугадать, глядя только на исходный код.</p>
	<p>Финальные значения переменных будут зависеть от случайных факторов, исходя из того, какой поток какое действие успел сделать первым или последним.</p>
	<p>Рассмотрим пример:</p>

	<pre class="brush: csharp;">
	public class ThreadTest
	{
		private int a=1, b=2;
		
		public void one()
		{
			a=b;
		}

		public void two()
		{
			b=a;
		}
		
		public static void main(String s[])
		{
			int a11=0, a22=0, a12=0;
			
			for (int i=0; i < 1000; i++)
			{
				final ThreadTest o = new ThreadTest();
				
				// Запускаем первый поток, который вызывает один метод
				new Thread()
				{
					public void run()
					{
						o.one();
					}
				}.start();

				// Запускаем второй поток, который вызывает второй метод
				new Thread()
				{
					public void run()
					{
						o.two();
					}
				}.start();

				// даем потокам время отработать
				try
				{
					Thread.sleep(100);
				} catch (InterruptedException e) {}
				
				// анализируем финальные значения
				if (o.a==1 && o.b==1) a11++;
				if (o.a==2 && o.b==2) a22++;
				if (o.a!=o.b) a12++;
			}

			System.out.println(a11+" "+a22+" "+a12);
		}
	}
	</pre>

	<p>В этом примере два потока исполнения одновременно обращаются к одному и тому же объекту, вызывая у него два разных метода, one() и two().</p>
	<p>Эти методы пытаются приравнять два поля класса a и b друг другу, но в разном порядке.</p>
	<p>Учитывая, что исходные значения полей равны 1 и 2, соответственно, можно было ожидать, что после того, как потоки завершат свою работу, поля будут иметь одинаковое значение.</p>
	<p>Однако понять, какое из двух возможных значений они примут, уже невозможно.</p>
	<p>Посмотрим на результат программы:</p>

	<pre class="brush: csharp;">
	135 864 1
	</pre>

	<p>Первое число показывает, сколько раз из тысячи обе переменные приняли значение 1.</p>
	<p>Второе число соответствует значению 2.</p>
	<p>Такое сильное преобладание одного из значений обусловлено последовательностью запусков потоков.</p>
	<p>Если ее изменить, то и количества случаев с 1 и 2 также меняются местами.</p>
	<p>Третье же число сообщает, что на тысячу случаев произошел один, когда поля вообще обменялись значениями!</p>
	<p>При количестве итераций, равном 10000, были получены следующие данные, которые подтверждают сделанные выводы:</p>

	<pre class="brush: csharp;">
	494 9498 8
	</pre>

	<p>А если убрать задержку перед анализом результатов, то получаемые данные радикально меняются:</p>

	<pre class="brush: csharp;">
	0 3 997
	</pre>

	<p>Видимо, потоки просто не успевают отработать.</p>
	<p>Итак, наглядно показано, сколь сильно и непредсказуемо может меняться результат работы одной и той же программы, применяющей многопоточную архитектуру.</p>
	<p>Необходимо учитывать, что в приведенном простом примере задержки создавались вручную методом Thread.sleep().</p>
	<p>В реальных сложных системах задержки могут возникать в местах проведения сложных операций, их длина непредсказуема и оценить их последствия невозможно.</p>
	<p>Для более глубокого понимания принципов многопоточной работы в Java рассмотрим организацию памяти в виртуальной машине для нескольких потоков.</p>

	<h1 id="title">
		Хранение переменных в памяти
	</h1>

	<p>Виртуальная машина поддерживает основное хранилище данных (main storage), в котором сохраняются значения всех переменных и которое используется всеми потоками.</p>
	<p>Под переменными здесь понимаются поля объектов и классов, а также элементы массивов.</p>
	<p>Что касается локальных переменных и параметров методов, то их значения не могут быть доступны другим потокам, поэтому они не представляют интереса.</p>
	<p>Для каждого потока создается его собственная рабочая память (working memory), в которую перед использованием копируются значения всех переменных.</p>
	<p>Рассмотрим основные операции, доступные для потоков при работе с памятью:</p>
	<p><b>use</b> – чтение значения переменной из рабочей памяти потока;</p>
	<p><b>assign</b> – запись значения переменной в рабочую память потока;</p>
	<p><b>read</b> – получение значения переменной из основного хранилища;</p>
	<p><b>load</b> – сохранение значения переменной, прочитанного из основного хранилища, в рабочей памяти;</p>
	<p><b>store</b> – передача значения переменной из рабочей памяти в основное хранилище для дальнейшего хранения;</p>
	<p><b>write</b> – сохраняет в основном хранилище значение переменной, переданной командой store.</p>
	<p>Подчеркнем, что перечисленные команды не являются методами каких-либо классов, они недоступны программисту.</p>
	<p>Сама виртуальная машина использует их для обеспечения корректной работы потоков исполнения.</p>
	<p>Поток, работая с переменной, регулярно применяет команды use и assign для использования ее текущего значения и присвоения нового.</p>
	<p>Кроме того, должны осуществляться действия по передаче значений в основное хранилище и из него. Они выполняются в два этапа.</p>
	<p>При получении данных сначала основное хранилище считывает значение командой read, а затем поток сохраняет результат в своей рабочей памяти командой load.</p>
	<p>Эта пара команд всегда выполняется вместе именно в таком порядке, т.е. нельзя выполнить одну, не выполнив другую.</p>
	<p>При отправлении данных сначала поток считывает значение из рабочей памяти командой store, а затем основное хранилище сохраняет его командой write.</p>
	<p>Эта пара команд также всегда выполняется вместе именно в таком порядке, т.е. нельзя выполнить одну, не выполнив другую.</p>
	<p>Набор этих правил составлялся с тем, чтобы операции с памятью были достаточно строги для точного анализа их результатов, а с другой стороны, правила должны оставлять достаточное пространство для различных технологий оптимизаций (регистры, очереди, кэш и т.д.).</p>
	<p>Последовательность команд подчиняется следующим правилам:</p>
	<p><b>* все действия, выполняемые одним потоком</b>, строго упорядочены, т.е. выполняются одно за другим;</p>
	<p><b>* все действия, выполняемые с одной переменной</b> в основном хранилище памяти, строго упорядочены, т.е. следуют одно за другим.</p>
	<p>За исключением некоторых дополнительных очевидных правил, больше никаких ограничений нет.</p>
	<p>Например, если поток изменил значение сначала одной, а затем другой переменной, то эти изменения могут быть переданы в основное хранилище в обратном порядке.</p>
	<p>Поток создается с чистой рабочей памятью и должен перед использованием загрузить все необходимые переменные из основного хранилища.</p>
	<p>Любая переменная сначала создается в основном хранилище и лишь затем копируется в рабочую память потоков, которые будут ее применять.</p>
	<p>Таким образом, потоки никогда не взаимодействуют друг с другом напрямую, только через главное хранилище.</p>

	<h1 id="title">
		Модификатор volatile
	</h1>

	<p>При объявлении полей объектов и классов может быть указан модификатор volatile.</p>
	<p>Он устанавливает более строгие правила работы со значениями переменных.</p>
	<p>Если поток собирается выполнить команду use для volatile переменной, то требуется, чтобы предыдущим действием с этой переменной было обязательно load, и наоборот – операция load может выполняться только перед use.</p>
	<p>Таким образом, переменная и главное хранилище всегда имеют самое последнее значение этой переменной.</p>
	<p>Аналогично, если поток собирается выполнить команду store для volatile переменной, то требуется, чтобы предыдущим действием над этой переменной было обязательно assign, и наоборот – операция assign может выполняться, только если следующей будет store.</p>
	<p>Таким образом, переменная и главное хранилище всегда имеют самое последнее значение этой переменной.</p>
	<p>Наконец, если проводятся операции над несколькими volatile переменными, то передача соответствующих изменений в основное хранилище должна проводиться строго в том же порядке.</p>
	<p>При работе с обычными переменными компилятор имеет больше пространства для маневра.</p>
	<p>Например, при благоприятных обстоятельствах может оказаться возможным предсказать значение переменной, заранее вычислить и сохранить его, а затем в нужный момент использовать уже готовым.</p>
	<p>Следует обратить внимание на два 64-разрядных типа, double и long.</p>
	<p>Поскольку многие платформы поддерживают лишь 32-битную память, величины этих типов рассматриваются как две переменные и все описанные действия выполняются независимо для двух половинок таких значений.</p>
	<p>Конечно, если производитель виртуальной машины считает возможным, он может обеспечить атомарность операций и над этими типами.</p>
	<p>Для volatile переменных это является обязательным требованием.</p>

	<h1 id="title">
		Блокировки
	</h1>

	<p>В основном хранилище для каждого объекта поддерживается блокировка ( lock ), над которой можно произвести два действия – установить ( lock ) и снять ( unlock ).</p>
	<p>Только один поток в один момент времени может установить блокировку на некоторый объект.</p>
	<p>Если до того, как этот поток выполнит операцию unlock, другой поток попытается установить блокировку, его выполнение будет приостановлено до тех пор, пока первый поток не отпустит ее.</p>
	<p>Операции lock и unlock накладывают жесткое ограничение на работу с переменными в рабочей памяти потока.</p>
	<p>После успешно выполненного lock рабочая память очищается и все переменные необходимо заново считывать из основного хранилища.</p>
	<p>Аналогично, перед операцией unlock необходимо все переменные сохранить в основном хранилище.</p>
	<p>Важно подчеркнуть, что блокировка является чем-то вроде флага.</p>
	<p>Если блокировка на объект установлена, это не означает, что данным объектом нельзя пользоваться, что его поля и методы становятся недоступными,– это не так.</p>
	<p>Единственное действие, которое становится невозможным,– установка этой же блокировки другим потоком, до тех пор, пока первый поток не выполнит unlock.</p>
	<p>В Java-программе для того, чтобы воспользоваться механизмом блокировок, существует ключевое слово synchronized.</p>
	<p>Оно может быть применено в двух вариантах – для объявления synchronized -блока и как модификатор метода.</p>
	<p>В обоих случаях действие его примерно одинаковое.</p>

	<pre class="brush: csharp;">
	Synchronized -блок записывается следующим образом:
	
	synchronized (ref)
	{
		...
	}
	</pre>

	<p>Прежде, чем начать выполнять действия, описанные в этом блоке, поток обязан установить блокировку на объект, на который ссылается переменная ref (поэтому она не может быть null).</p>
	<p>Если другой поток уже установил блокировку на этот объект, то выполнение первого потока приостанавливается до тех пор, пока не удастся выполнить операцию lock.</p>
	<p>После этого блок выполняется.</p>
	<p>При завершении исполнения (как успешном, так и в случае ошибок) производится операция unlock, чтобы освободить объект для других потоков.</p>
	<p>Рассмотрим пример:</p>

	<pre class="brush: csharp;">
	public class ThreadTest implements Runnable
	{
		private static ThreadTest
		
		shared = new ThreadTest();
		
		public void process()
		{
			for (int i=0; i < 3; i++)
			{
				System.out.println(
				Thread.currentThread().getName()+" "+i);
				Thread.yield();
			}
		}
		
		public void run()
		{
			shared.process();
		}
		
		public static void main(String s[])
		{
			for (int i=0; i < 3; i++)
			{
				new Thread(new ThreadTest(),"Thread-"+i).start();
			}
		}
	}
	</pre>

	<p>В этом простом примере три потока вызывают метод у одного объекта, чтобы тот распечатал три значения.</p>
	<p>Результатом будет:</p>

	<pre class="brush: csharp;">
	Thread-0 0
	Thread-1 0
	Thread-2 0
	Thread-0 1
	Thread-2 1
	Thread-0 2
	Thread-1 1
	Thread-2 2
	Thread-1 2
	</pre>

	<p>То есть все потоки одновременно работают с одним методом одного объекта.</p>
	<p>Заключим обращение к методу в synchronized -блок:</p>

	<pre class="brush: csharp;">
	public void run()
	{
		synchronized (shared)
		{
			shared.process();
		}
	}
	</pre>

	<p>Теперь результат будет строго упорядочен:</p>

	<pre class="brush: csharp;">
	Thread-0 0
	Thread-0 1
	Thread-0 2
	Thread-1 0
	Thread-1 1
	Thread-1 2
	Thread-2 0
	Thread-2 1
	Thread-2 2
	</pre>

	<p>Synchronized -методы работают аналогичным образом.</p>
	<p>Прежде, чем начать выполнять их, поток пытается заблокировать объект, у которого вызывается метод.</p>
	<p>После выполнения блокировка снимается.</p>
	<p>В предыдущем примере аналогичной упорядоченности можно было добиться, если использовать не synchronized -блок, а объявить метод process() синхронизированным.</p>
	<p>Также допустимы методы static synchronized.</p>
	<p>При их вызове блокировка устанавливается на объект класса Class, отвечающего за тип, у которого вызывается этот метод.</p>
	<p>При работе с блокировками всегда надо помнить о возможности появления deadlock – взаимных блокировок, которые приводят к зависанию программы.</p>
	<p>Если один поток заблокировал один ресурс и пытается заблокировать второй, а другой поток заблокировал второй и пытается заблокировать первый, то такие потоки уже никогда не выйдут из состояния ожидания.</p>
	<p>Рассмотрим простейший пример:</p>

	<pre class="brush: csharp;">
	public class DeadlockDemo
	{
		// Два объекта-ресурса
		public final static Object one=new Object(), two=new Object();
		
		public static void main(String s[])
		{
			// Создаем два потока, которые будут конкурировать за доступ к объектам one и two
			Thread t1 = new Thread()
			{
				public void run()
				{
					// Блокировка первого объекта
					synchronized(one)
					{
						Thread.yield();
						
						// Блокировка второго объекта
						synchronized (two)
						{
							System.out.println("Success!");
						}
					}
				}
			};

			Thread t2 = new Thread()
			{
				public void run()
				{
					// Блокировка второго объекта
					synchronized(two)
					{
						Thread.yield();
						
						// Блокировка первого объекта
						synchronized (one)
						{
							System.out.println("Success!");
						}
					}
				}
			};

			// Запускаем потоки
			t1.start();
			t2.start();
		}
	}
	</pre>

	<p>Если запустить такую программу, то она никогда не закончит свою работу.</p>
	<p>Обратите внимание на вызовы метода yield() в каждом потоке.</p>
	<p>Они гарантируют, что когда один поток выполнил первую блокировку и переходит к следующей, второй поток находится в таком же состоянии.</p>
	<p>Очевидно, что в результате оба потока "замрут", не смогут продолжить свое выполнение.</p>
	<p>Первый поток будет ждать освобождения второго объекта, и наоборот.</p>
	<p>Именно такая ситуация называется "мертвой блокировкой", или deadlock.</p>
	<p>Если один из потоков успел бы заблокировать оба объекта, то программа успешно бы выполнилась до конца.</p>
	<p>Однако многопоточная архитектура не дает никаких гарантий, как именно потоки будут выполняться друг относительно друга.</p>
	<p>Задержки (которые в примере моделируются вызовами yield()) могут возникать из логики программы (необходимость произвести вычисления), действий пользователя (не сразу нажал кнопку "ОК"), занятости ОС (из-за нехватки физической оперативной памяти пришлось воспользоваться виртуальной), значений приоритетов потоков и так далее.</p>
	<p>В Java нет никаких средств распознавания или предотвращения ситуаций deadlock.</p>
	<p>Также нет способа перед вызовом синхронизированного метода узнать, заблокирован ли уже объект другим потоком.</p>
	<p>Программист сам должен строить работу программы таким образом, чтобы неразрешимые блокировки не возникали.</p>
	<p>Например, в рассмотренном примере достаточно было организовать блокировки объектов в одном порядке (всегда сначала первый, затем второй) – и программа всегда выполнялась бы успешно.</p>
	<p>Опасность возникновения взаимных блокировок заставляет с особенным вниманием относиться к работе с потоками.</p>
	<p>Например, важно помнить, что если у объекта потока был вызван метод sleep(..), то такой поток будет бездействовать определенное время, но при этом все заблокированные им объекты будут оставаться недоступными для блокировок со стороны других потоков, а это потенциальный deadlock.</p>
	<p>Такие ситуации крайне сложно выявить путем тестирования и отладки, поэтому вопросам синхронизации надо уделять много времени на этапе проектирования.</p>

	<script src="../../../../js/progressBarSetIni.js" type="text/javascript"></script>

        <div id="lessMenu" style="margin: 30px 0 0 0;">
            <hr />
            <a href="63.html"><div id="exitLess" ontouchstart="return true;"><img src="../../../../img/menu/pr.png" /></div></a>
            <a href="65.html"><div id="aaLess" ontouchstart="return true;"><img src="../../../../img/menu/ne.png" /></div></a>
        </div>

    </div>

    <script type="text/javascript" src="../../../../cordova.js"></script>
    <script type="text/javascript" src="../../../../js/global.js"></script>
    <script type="text/javascript">
        changeColor();
        if (localStorage.getItem("fSize") < 1) { fSize = 16; localStorage.setItem("fSize", 16); } else { fSize = localStorage.getItem("fSize"); }
        document.getElementById("pageBody").style.fontSize = fSize + "px";

        // goBackMenu
        document.addEventListener("backbutton", goBackMenu, false);
        function goBackMenu()
        {
            window.location.href = 'list.html';
        }

        function changeColor()
        {
            if (localStorage.getItem("colorSheme") <= 1)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#f0f0f0");
            }

            if (localStorage.getItem("colorSheme") == 2)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#212121");
                document.getElementById("pageBody").style.color = localStorage.getItem("#efefef");
            }

            if (localStorage.getItem("colorSheme") == 3)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#efe4d0");
            }
        }

        // bm
        if (localStorage.getItem("arrs") != null)
        {
            var arrs = JSON.parse(localStorage.getItem("arrs"));
        }
        else
        {
            var arrs = [];
        }

        var names = ["../acharter/ru/java/book/64.html", "Синхронизация", "bm665"];

        function setzBm() { arrs.push(names); localStorage.setItem("arrs", JSON.stringify(arrs)); localStorage.setItem("bm665", 1); RefBms(); }

        window.onload = function() { RefBms(); }

        function RefBms()
        {
            if (localStorage.getItem("bm665") == 1) { document.getElementById("bma665").style.display = "block"; document.getElementById("bm665").style.display = "none"; } else { document.getElementById("bma665").style.display = "none"; document.getElementById("bm665").style.display = "block"; }
        }

        function dellBm() { for (var i = 0; i < arrs.length; i++) { if (arrs[i].indexOf("Синхронизация") == 1) { arrs.splice(i, 1); localStorage.setItem("bm665", 0); RefBms(); localStorage.setItem("arrs", JSON.stringify(arrs)); } } }

        // sub menu
        var serTimeToClose = 1000;
        
        function OpenSettMenu()
        {
            document.getElementById("subMenuInLess").style.display = "block";
            timeToEvAct();
            serTimeToClose = 1;
        }
        
        function timeToEvAct()
        {
            setTimeout(function() { serTimeToClose = 0 }, 100);
        }
        
        window.addEventListener('click', function(e){
        
            if (serTimeToClose <= 0)
            {
                if (document.getElementById('subMenuInLess').contains(e.target))
                {
                    //
                }
                else
                {
                    document.getElementById("subMenuInLess").style.display = "none";
                }
            }
        });

    </script>

</body>
</html>
