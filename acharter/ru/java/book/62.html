

<!DOCTYPE html>

<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <link rel="stylesheet" type="text/css" href="../../../../css/read.css" />
    <title>Coder Book menu</title>
    <script type="text/javascript" src="../../../../higtline/scripts/shCore.js"></script>
    <script type="text/javascript" src="../../../../higtline/scripts/shBrushCSharp.js"></script>
    <link type="text/css" rel="stylesheet" href="../../../../higtline/styles/shCoreDefault.css"/>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <script src="../../../../js/Hyphenator.js" type="text/javascript"></script>
</head>

<body id="pageBody" class="hyphenate">

<!-- progress bar -->
<script src="../../../../js/progressBar.js" type="text/javascript"></script>
<div class="Reading-progress" id="progressBarType1"><span id="Progress-bar-top" class="bar-top" style="display: block !important;"></span></div>
<div class="Reading-progress" id="progressBarType2"><span id="Progress-bar-bottom" class="bar-bottom"></span></div>
<div class="Reading-progress" id="progressBarType3"><span id="Progress-bar-left" class="bar-left"></span></div>
<div class="Reading-progress" id="progressBarType4"><span id="Progress-bar-right" class="bar-right"></span></div>
<!-- progress bar -->


    <div id="lesonPage">

        <div id="lessMenu">
           <a id="exitLess" href="list.html" ontouchstart="return true;"><img src="../../../../img/menu/ex.png" /></a>
           <div id="aaLess" ontouchstart="return true;" onclick="OpenSettMenu();"><img src="../../../../img/menu/aa.png" /></div>
           <div id="subMenuInLess" style="display: none;">
                <a href="../../../../menu/setfontsize-ru.html" ontouchstart="return true;" id="pastMenuInLess">Размер текста</a>
                <a href="../../../../menu/setcolor-ru.html" ontouchstart="return true;" id="pastMenuInLess">Цветовая темы</a>
                <a href="../../../../menu/setProgressBar-ru.html" ontouchstart="return true;" id="pastMenuInLess" style="border: none;">Прогресс бар</a>
           </div>
           <div id="aaLess" ontouchstart="return true;">
            <div class="bmEdit" onclick="dellBm();" id="bma663" ontouchstart="return true;" style="display: none;"><img src="../../../../img/menu/bmlessa.png" /></div>
            <div class="bmEdit" onclick="setzBm();" id="bm663" ontouchstart="return true;" style="display: block;"><img src="../../../../img/menu/bmless.png" /></div>
           </div>
        </div>

        <hr />

	<!-- ПОЧАТОК -->

	<h1 id="title">
		Введение
	</h1>

	<p>До сих пор во всех рассматриваемых примерах подразумевалось, что в один момент времени исполняется лишь одно выражение или действие.</p>
	<p>Однако начиная с самых первых версий, виртуальные машины Java поддерживают многопоточность, т.е. поддержку нескольких потоков исполнения ( threads ) одновременно.</p>
	<p>В данной лекции сначала рассматриваются преимущества такого подхода, способы реализации и возможные недостатки.</p>
	<p>Затем описываются базовые классы Java, которые позволяют запускать потоки исполнения и управлять ими.</p>
	<p>При одновременном обращении нескольких потоков к одним и тем же данным может возникнуть ситуация, когда результат программы будет зависеть от случайных факторов, таких как временное чередование исполнения операций несколькими потоками.</p>
	<p>В такой ситуации становятся необходимыми механизмы синхронизации, обеспечивающие последовательный, или монопольный, доступ.</p>
	<p>В Java этой цели служит ключевое слово synchronized.</p>
	<p>Предварительно будет рассмотрен подход к организации хранения данных в виртуальной машине.</p>
	<p>В заключение рассматриваются методы wait(), notify(), notifyAll() класса Object.</p>

	<h1 id="title">
		Многопоточная архитектура
	</h1>

	<p>Не претендуя на полноту изложения, рассмотрим общее устройство многопоточной архитектуры, ее достоинства и недостатки.</p>
	<p>Реализацию многопоточной архитектуры проще всего представить себе для системы, в которой есть несколько центральных вычислительных процессоров.</p>
	<p>В этом случае для каждого из них можно выделить задачу, которую он будет выполнять.</p>
	<p>В результате несколько задач будут обслуживаться одновременно.</p>
	<p>Однако возникает вопрос – каким же тогда образом обеспечивается многопоточность в системах с одним центральным процессором, который, в принципе, выполняет лишь одно вычисление в один момент времени?</p>
	<p>В таких системах применяется процедура квантования времени ( time-slicing ).</p>
	<p>Время разделяется на небольшие интервалы.</p>
	<p>Перед началом каждого интервала принимается решение, какой именно поток выполнения будет отрабатываться на протяжении этого кванта времени.</p>
	<p>За счет частого переключения между задачами эмулируется многопоточная архитектура.</p>
	<p>На самом деле, как правило, и для многопроцессорных систем применяется процедура квантования времени.</p>
	<p>Дело в том, что даже в мощных серверах приложений процессоров не так много (редко бывает больше десяти), а потоков исполнения запускается, как правило, гораздо больше.</p>
	<p>Например, операционная система Windows без единого запущенного приложения инициализирует десятки, а то и сотни потоков.</p>
	<p>Квантование времени позволяет упростить управление выполнением задач на всех процессорах.</p>
	<p>Теперь перейдем к вопросу о преимуществах – зачем вообще может потребоваться более одного потока выполнения?</p>
	<p>Среди начинающих программистов бытует мнение, что многопоточные программы работают быстрее.</p>
	<p>Рассмотрев способ реализации многопоточности, можно утверждать, что такие программы работают на самом деле медленнее.</p>
	<p>Действительно, для переключения между задачами на каждом интервале требуется дополнительное время, а ведь они (переключения) происходят довольно часто.</p>
	<p>Если бы процессор, не отвлекаясь, выполнял задачи последовательно, одну за другой, он завершил бы их заметно быстрее.</p>
	<p>Стало быть, преимущества заключаются не в этом.</p>
	<p>Первый тип приложений, который выигрывает от поддержки многопоточности, предназначен для задач, где действительно требуется выполнять несколько действий одновременно.</p>
	<p>Например, будет вполне обоснованно ожидать, что сервер общего пользования станет обслуживать несколько клиентов одновременно.</p>
	<p>Можно легко представить себе пример из сферы обслуживания, когда имеется несколько потоков клиентов и желательно обслуживать их все одновременно.</p>
	<p>Другой пример – активные игры, или подобные приложения.</p>
	<p>Необходимо одновременно опрашивать клавиатуру и другие устройства ввода, чтобы реагировать на действия пользователя.</p>
	<p>В то же время необходимо рассчитывать и перерисовывать изменяющееся состояние игрового поля.</p>
	<p>Понятно, что в случае отсутствия поддержки многопоточности для реализации подобных приложений потребовалось бы реализовывать квантование времени вручную.</p>
	<p>Условно говоря, одну секунду проверять состояние клавиатуры, а следующую – пересчитывать и перерисовывать игровое поле.</p>
	<p>Если сравнить две реализации time-slicing, одну – на низком уровне, выполненную средствами, как правило, операционной системы, другую – выполняемую вручную, на языке высокого уровня, мало подходящего для таких задач, то становится понятным первое и, возможно, главное преимущество многопоточности.</p>
	<p>Она обеспечивает наиболее эффективную реализацию процедуры квантования времени, существенно облегчая и укорачивая процесс разработки приложения.</p>
	<p>Код переключения между задачами на Java выглядел бы куда более громоздко, чем независимое описание действий для каждого потока.</p>
	<p>Следующее преимущество проистекает из того, что компьютер состоит не только из одного или нескольких процессоров.</p>
	<p>Вычислительное устройство – лишь один из ресурсов, необходимых для выполнения задач.</p>
	<p>Всегда есть оперативная память, дисковая подсистема, сетевые подключения, периферия и т.д.</p>
	<p>Предположим, пользователю требуется распечатать большой документ и скачать большой файл из сети.</p>
	<p>Очевидно, что обе задачи требуют совсем незначительного участия процессора, а основные необходимые ресурсы, которые будут задействованы на пределе возможностей, у них разные – сетевое подключение и принтер.</p>
	<p>Значит, если выполнять задачи одновременно, то замедление от организации квантования времени будет незначительным, процессор легко справится с обслуживанием обеих задач.</p>
	<p>В то же время, если каждая задача по отдельности занимала, скажем, два часа, то вполне вероятно, что и при одновременном исполнении потребуется не более тех же двух часов, а сделано при этом будет гораздо больше.</p>
	<p>Если же задачи в основном загружают процессор (например, математические расчеты), то их одновременное исполнение займет в лучшем случае столько же времени, что и последовательное, а то и больше.</p>
	<p>Третье преимущество появляется из-за возможности более гибко управлять выполнением задач.</p>
	<p>Предположим, пользователь системы, не поддерживающей многопоточность, решил скачать большой файл из сети, или произвести сложное вычисление, что занимает, скажем, два часа.</p>
	<p>Запустив задачу на выполнение, он может внезапно обнаружить, что ему нужен не этот, а какой-нибудь другой файл (или вычисление с другими начальными параметрами).</p>
	<p>Однако если приложение занимается только работой с сетью (вычислениями) и не реагирует на действия пользователя (не обрабатываются данные с устройств ввода, таких как клавиатура или мышь), то он не сможет быстро исправить ошибку.</p>
	<p>Получается, что процессор выполняет большее количество вычислений, но при этом приносит гораздо меньше пользы.</p>
	<p>Процедура квантования времени поддерживает приоритеты (priority) задач.</p>
	<p>В Java приоритет представляется целым числом. Чем больше число, тем выше приоритет.</p>
	<p>Строгих правил работы с приоритетами нет, каждая реализация может вести себя по-разному на разных платформах.</p>
	<p>Однако есть общее правило – поток с более высоким приоритетом будет получать большее количество квантов времени на исполнение и таким образом сможет быстрее выполнять свои действия и реагировать на поступающие данные.</p>
	<p>В описанном примере представляется разумным запустить дополнительный поток, отвечающий за взаимодействие с пользователем.</p>
	<p>Ему можно поставить высокий приоритет, так как в случае бездействия пользователя этот поток практически не будет занимать ресурсы машины.</p>
	<p>В случае же активности пользователя необходимо как можно быстрее произвести необходимые действия, чтобы обеспечить максимальную эффективность работы пользователя.</p>
	<p>Рассмотрим здесь же еще одно свойство потоков.</p>
	<p>Раньше, когда рассматривались однопоточные приложения, завершение вычислений однозначно приводило к завершению выполнения программы.</p>
	<p>Теперь же приложение должно работать до тех пор, пока есть хоть один действующий поток исполнения.</p>
	<p>В то же время часто бывают нужны обслуживающие потоки, которые не имеют никакого смысла, если они остаются в системе одни.</p>
	<p>Например, автоматический сборщик мусора в Java запускается в виде фонового (низкоприоритетного) процесса.</p>
	<p>Его задача – отслеживать объекты, которые уже не используются другими потоками, и затем уничтожать их, освобождая оперативную память.</p>
	<p>Понятно, что работа одного потока garbage collector 'а не имеет никакого смысла.</p>
	<p>Такие обслуживающие потоки называют демонами ( daemon ), это свойство можно установить любому потоку.</p>
	<p>В итоге приложение выполняется до тех пор, пока есть хотя бы один поток не- демон.</p>
	<p>Рассмотрим, как потоки реализованы в Java.</p>

	<script src="../../../../js/progressBarSetIni.js" type="text/javascript"></script>

        <div id="lessMenu" style="margin: 30px 0 0 0;">
            <hr />
            <a href="61.html"><div id="exitLess" ontouchstart="return true;"><img src="../../../../img/menu/pr.png" /></div></a>
            <a href="63.html"><div id="aaLess" ontouchstart="return true;"><img src="../../../../img/menu/ne.png" /></div></a>
        </div>

    </div>

    <script type="text/javascript" src="../../../../cordova.js"></script>
    <script type="text/javascript" src="../../../../js/global.js"></script>
    <script type="text/javascript">
        changeColor();
        if (localStorage.getItem("fSize") < 1) { fSize = 16; localStorage.setItem("fSize", 16); } else { fSize = localStorage.getItem("fSize"); }
        document.getElementById("pageBody").style.fontSize = fSize + "px";

        // goBackMenu
        document.addEventListener("backbutton", goBackMenu, false);
        function goBackMenu()
        {
            window.location.href = 'list.html';
        }

        function changeColor()
        {
            if (localStorage.getItem("colorSheme") <= 1)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#f0f0f0");
            }

            if (localStorage.getItem("colorSheme") == 2)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#212121");
                document.getElementById("pageBody").style.color = localStorage.getItem("#efefef");
            }

            if (localStorage.getItem("colorSheme") == 3)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#efe4d0");
            }
        }

        // bm
        if (localStorage.getItem("arrs") != null)
        {
            var arrs = JSON.parse(localStorage.getItem("arrs"));
        }
        else
        {
            var arrs = [];
        }

        var names = ["../acharter/ru/java/book/62.html", "Многопоточная архитектура", "bm663"];

        function setzBm() { arrs.push(names); localStorage.setItem("arrs", JSON.stringify(arrs)); localStorage.setItem("bm663", 1); RefBms(); }

        window.onload = function() { RefBms(); }

        function RefBms()
        {
            if (localStorage.getItem("bm663") == 1) { document.getElementById("bma663").style.display = "block"; document.getElementById("bm663").style.display = "none"; } else { document.getElementById("bma663").style.display = "none"; document.getElementById("bm663").style.display = "block"; }
        }

        function dellBm() { for (var i = 0; i < arrs.length; i++) { if (arrs[i].indexOf("Многопоточная архитектура") == 1) { arrs.splice(i, 1); localStorage.setItem("bm663", 0); RefBms(); localStorage.setItem("arrs", JSON.stringify(arrs)); } } }

        // sub menu
        var serTimeToClose = 1000;
        
        function OpenSettMenu()
        {
            document.getElementById("subMenuInLess").style.display = "block";
            timeToEvAct();
            serTimeToClose = 1;
        }
        
        function timeToEvAct()
        {
            setTimeout(function() { serTimeToClose = 0 }, 100);
        }
        
        window.addEventListener('click', function(e){
        
            if (serTimeToClose <= 0)
            {
                if (document.getElementById('subMenuInLess').contains(e.target))
                {
                    //
                }
                else
                {
                    document.getElementById("subMenuInLess").style.display = "none";
                }
            }
        });

    </script>

</body>
</html>
