

<!DOCTYPE html>

<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <link rel="stylesheet" type="text/css" href="../../../../css/read.css" />
    <title>Coder Book menu</title>
    <script type="text/javascript" src="../../../../higtline/scripts/shCore.js"></script>
    <script type="text/javascript" src="../../../../higtline/scripts/shBrushCSharp.js"></script>
    <link type="text/css" rel="stylesheet" href="../../../../higtline/styles/shCoreDefault.css"/>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <script src="../../../../js/Hyphenator.js" type="text/javascript"></script>
</head>

<body id="pageBody" class="hyphenate">

<!-- progress bar -->
<script src="../../../../js/progressBar.js" type="text/javascript"></script>
<div class="Reading-progress" id="progressBarType1"><span id="Progress-bar-top" class="bar-top" style="display: block !important;"></span></div>
<div class="Reading-progress" id="progressBarType2"><span id="Progress-bar-bottom" class="bar-bottom"></span></div>
<div class="Reading-progress" id="progressBarType3"><span id="Progress-bar-left" class="bar-left"></span></div>
<div class="Reading-progress" id="progressBarType4"><span id="Progress-bar-right" class="bar-right"></span></div>
<!-- progress bar -->


    <div id="lesonPage">

        <div id="lessMenu">
           <a id="exitLess" href="list.html" ontouchstart="return true;"><img src="../../../../img/menu/ex.png" /></a>
           <div id="aaLess" ontouchstart="return true;" onclick="OpenSettMenu();"><img src="../../../../img/menu/aa.png" /></div>
           <div id="subMenuInLess" style="display: none;">
                <a href="../../../../menu/setfontsize-ru.html" ontouchstart="return true;" id="pastMenuInLess">Размер текста</a>
                <a href="../../../../menu/setcolor-ru.html" ontouchstart="return true;" id="pastMenuInLess">Цветовая темы</a>
                <a href="../../../../menu/setProgressBar-ru.html" ontouchstart="return true;" id="pastMenuInLess" style="border: none;">Прогресс бар</a>
           </div>
           <div id="aaLess" ontouchstart="return true;">
            <div class="bmEdit" onclick="dellBm();" id="bma623" ontouchstart="return true;" style="display: none;"><img src="../../../../img/menu/bmlessa.png" /></div>
            <div class="bmEdit" onclick="setzBm();" id="bm623" ontouchstart="return true;" style="display: block;"><img src="../../../../img/menu/bmless.png" /></div>
           </div>
        </div>

        <hr />

	<!-- ПОЧАТОК -->

	<h1 id="title">
		Виды лексем
	</h1>

	<p>Ниже перечислены все виды лексем в Java:</p>
	<p>- идентификаторы (identifiers);</p>
	<p>- ключевые слова (key words);</p>
	<p>- литералы (literals);</p>
	<p>- разделители (separators);</p>
	<p>- операторы (operators).</p>
	<p>Рассмотрим их по отдельности.</p>

	<h1 id="title">
		Идентификаторы
	</h1>

	<p>Идентификаторы – это имена, которые даются различным элементам языка для упрощения доступа к ним.</p>
	<p>Имена имеют пакеты, классы, интерфейсы, поля, методы, аргументы и локальные переменные (все эти понятия подробно рассматриваются в следующих лекциях).</p>
	<p>Идентификаторы можно записывать символами Unicode, то есть на любом удобном языке.</p>
	<p>Длина имени не ограничена.</p>
	<p>Идентификатор состоит из букв и цифр.</p>
	<p>Имя не может начинаться с цифры.</p>
	<p>Java-буквы, используемые в идентификаторах, включают в себя ASCII -символы A-Z ( \u0041 - \u005a ), a-z ( \u0061 - \u007a ), а также знаки подчеркивания _ ( ASCII underscore, \u005f ) и доллара $ ( \u0024 ).</p>
	<p>Знак доллара используется только при автоматической генерации кода (чтобы исключить случайное совпадение имен), либо при использовании каких-либо старых библиотек, в которых допускались имена с этим символом.</p>
	<p>Java-цифры включают в себя обычные ASCII -цифры 0-9 ( \u0030 - \u0039 ).</p>
	<p>Для идентификаторов не допускаются совпадения с зарезервированными словами (это ключевые слова, булевские литералы true и false и null- литерал null ).</p>
	<p>Конечно, если 2 идентификатора включают в себя разные буквы, которые одинаково выглядят (например, латинская и русская буквы A ), то они считаются различными.</p>
	<p>В этой лекции уже применялись следующие идентификаторы:</p>

	<pre class="brush: csharp;">
	Character, a, b, c, D, x1, x2, Math, sqrt, x, y, i, s, PI, getRadius, circle, getAbs, calculate, condition, getWidth, getHeight, java, lang, String
	</pre>

	<p>Также допустимыми являются идентификаторы:</p>

	<pre class="brush: csharp;">
	Computer, COLOR_RED, _, aVeryLongNameOfTheMethod
	</pre>

	<h1 id="title">
		Ключевые слова
	</h1>

	<p>Ключевые слова – это зарезервированные слова, состоящие из ASCII -символов и выполняющие различные задачи языка.</p>
	<p>Вот их полный список (48 слов):</p>

	<pre class="brush: csharp;">
	abstract
	double
	int
	strictfp
	boolean
	else
	interface
	super
	break
	extends
	long
	switch
	byte
	final
	native
	synchronized
	case
	finally
	new
	this
	catch
	float
	package
	throw
	char
	for
	private
	throws
	class
	goto
	protected
	transient
	const
	if
	public
	try
	continue
	implements
	return
	void
	default
	import
	short
	volatile
	do
	instanceof
	static
	while
	</pre>

	<p>Ключевые слова goto и const зарезервированы, но не используются.</p>
	<p>Это сделано для того, чтобы компилятор мог правильно отреагировать на их использование в других языках.</p>
	<p>Напротив, оба булевских литерала true, false и null- литерал null часто считают ключевыми словами (возможно, потому, что многие средства разработки подсвечивают их таким же образом), однако это именно литералы.</p>
	<p>Значение всех ключевых слов будет рассматриваться в следующих лекциях.</p>

	<h1 id="title">
		Литералы
	</h1>

	<p>Литералы позволяют задать в программе значения для числовых, символьных и строковых выражений, а также null- литералов.</p>
	<p>Всего в Java определено 6 видов литералов:</p>
	<p>- целочисленный (integer);</p>
	<p>- дробный (floating-point);</p>
	<p>- булевский (boolean);</p>
	<p>- символьный (character);</p>
	<p>- строковый (string);</p>
	<p>- null- литерал (null-literal).</p>
	<p>Рассмотрим их по отдельности.</p>

	<h1 id="title">
		Целочисленные литералы
	</h1>

	<p>Целочисленные литералы позволяют задавать целочисленные значения в десятичном, восьмеричном и шестнадцатеричном виде.</p>
	<p>Десятичный формат традиционен и ничем не отличается от правил, принятых в других языках.</p>
	<p>Значения в восьмеричном виде начинаются с нуля, и, конечно, использование цифр 8 и 9 запрещено.</p>
	<p>Запись шестнадцатеричных чисел начинается с 0x или 0X (цифра 0 и латинская ASCII -буква X в произвольном регистре).</p>
	<p>Таким образом, ноль можно записать тремя различными способами:</p>

	<pre class="brush: csharp;">
	0
	0X0
	0x0
	</pre>

	<p>Как обычно, для записи цифр 10 - 15 в шестнадцатеричном формате используются буквы A, B, C, D, E, F, прописные или строчные.</p>
	<p>Примеры таких литералов:</p>

	<pre class="brush: csharp;">
	0xaBcDeF, 0xCafe, 0xDEC
	</pre>

	<p>Типы данных рассматриваются ниже, однако здесь необходимо упомянуть два целочисленных типа int и long длиной 4 и 8 байт, соответственно (или 32 и 64 бита, соответственно).</p>
	<p>Оба эти типа знаковые, т.е. тип int хранит значения от -231 до 231-1, или от -2.147.483.648 до 2.147.483.647.</p>
	<p>По умолчанию целочисленный литерал имеет тип int, а значит, в программе допустимо использовать литералы только от 0 до 2147483648, иначе возникнет ошибка компиляции.</p>
	<p>При этом литерал 2147483648 можно использовать только как аргумент унарного оператора - :</p>

	<pre class="brush: csharp;">
	\\ верно
	int x = -2147483648;

	\\ здесь возникнет ошибка компиляции
	int y = -5-2147483648;
	</pre>

	<p>Соответственно, допустимые литералы в восьмеричной записи должны быть от 00 до 017777777777 ( =231-1 ), с унарным оператором - допустимо также -020000000000 ( = -231 ).</p>
	<p>Аналогично для шестнадцатеричного формата – от 0x0 до 0x7fffffff ( =231-1 ), а также -0x80000000 ( = -231 ).</p>
	<p>Тип long имеет длину 64 бита, а значит, позволяет хранить значения от -263 до 263-1.</p>
	<p>Чтобы ввести такой литерал, необходимо в конце поставить латинскую букву L или l, тогда все значение будет трактоваться как long.</p>
	<p>Аналогично можно выписать максимальные допустимые значения для них:</p>

	<pre class="brush: csharp;">
	9223372036854775807L
	0777777777777777777777L
	0x7fffffffffffffffL

	// наименьшие отрицательные значения:

	-9223372036854775808L
	-01000000000000000000000L
	-0x8000000000000000L
	</pre>

	<p>Другие примеры целочисленных литералов типа long:</p>

	<pre class="brush: csharp;">
	0L, 123l, 0xC0B0L
	</pre>

	<h1 id="title">
		Дробные литералы
	</h1>

	<p>Дробные литералы представляют собой числа с плавающей десятичной точкой.</p>
	<p>Правила записи таких чисел такие же, как и в большинстве современных языков программирования.</p>
	<p>Примеры:</p>

	<pre class="brush: csharp;">
	3.14
	2.
	.5
	7e10
	3.1E-20
	</pre>

	<p>Таким образом, дробный литерал состоит из следующих составных частей:</p>
	<p>- целая часть;</p>
	<p>- десятичная точка (используется ASCII -символ точка);</p>
	<p>- дробная часть;</p>
	<p>- порядок (состоит из латинской ASCII -буквы E в произвольном регистре и целого числа с опциональным знаком + или - );</p>
	<p>- окончание-указатель типа.</p>
	<p>Целая и дробная части записываются десятичными цифрами, а указатель типа (аналог указателя L или l для целочисленных литералов типа long ) имеет два возможных значения – латинская ASCII -буква D (для типа double ) или F (для типа float ) в произвольном регистре.</p>
	<p>Они будут подробно рассмотрены ниже.</p>
	<p>Необходимыми частями являются:</p>
	<p>- хотя бы одна цифра в целой или дробной части;</p>
	<p>- десятичная точка или показатель степени, или указатель типа.</p>
	<p>Все остальные части необязательные.</p>
	<p>Таким образом, "минимальные" дробные литералы могут быть записаны, например, так:</p>

	<pre class="brush: csharp;">
	1.
	.1
	1e1
	1f
	</pre>

	<p>В Java есть два дробных типа, упомянутые выше, – float и double.</p>
	<p>Их длина – 4 и 8 байт или 32 и 64 бита, соответственно.</p>
	<p>Дробный литерал имеет тип float, если он заканчивается на латинскую букву F в произвольном регистре.</p>
	<p>В противном случае он рассматривается как значение типа double и может включать в себя окончание D или d, как признак типа double (используется только для наглядности).</p>

	<pre class="brush: csharp;">
	// float-литералы:
	1f, 3.14F, 0f, 1e+5F

	// double-литералы:
	0., 3.14d, 1e-4, 31.34E45D
	</pre>

	<p>В Java дробные числа 32-битного типа float и 64-битного типа double хранятся в памяти в бинарном виде в формате, стандартизированном спецификацией IEEE 754 (полное название – IEEE Standard for Binary Floating-Point Arithmetic, ANSI/IEEE Standard 754-1985 (IEEE, New York)).</p>
	<p>В этой спецификации описаны не только конечные дробные величины, но и еще несколько особых значений, а именно:</p>
	<p>- положительная и отрицательная бесконечности (positive/negative infinity);</p>
	<p>- значение "не число", Not-a-Number, сокращенно NaN;</p>
	<p>- положительный и отрицательный нули.</p>
	<p>Для этих значений нет специальных обозначений.</p>
	<p>Чтобы получить такие величины, необходимо либо произвести арифметическую операцию (например, результатом деления ноль на ноль 0.0/0.0 является NaN ), либо обратиться к константам в классах Float и Double, а именно POSITIVE_INFINITY, NEGATIVE_INFINITY и NaN.</p>
	<p>Более подробно работа с этими особенными значениями рассматривается в следующей лекции.</p>
	<p>Типы данных накладывают ограничения на возможные значения литералов, как и для целочисленных типов.</p>
	<p>Максимальное положительное конечное значение дробного литерала:</p>
	<p>- для float: 3.40282347e+38f</p>
	<p>- для double: 1.79769313486231570e+308</p>
	<p>Кроме того, для дробных величин становится важным еще одно предельное значение – минимальное положительное ненулевое значение:</p>
	<p>- для float: 1.40239846e-45f</p>
	<p>- для double: 4.94065645841246544e-324</p>
	<p>Попытка указать литерал со слишком большим абсолютным значением (например, 1e40F ) приведет к ошибке компиляции.</p>
	<p>Такая величина должна представляться бесконечностью.</p>
	<p>Аналогично, указание литерала со слишком малым ненулевым значением (например, 1e-350 ) также приводит к ошибке.</p>
	<p>Это значение должно быть округлено до нуля.</p>
	<p>Однако если округление приводит не к нулю, то компилятор произведет его сам:</p>

	<pre class="brush: csharp;">
	// ошибка, выражение должно быть округлено до 0
	0.00000000000000000000000000000000000000000001f

	// ошибки нет, компилятор сам округляет до 1
	1.00000000000000000000000000000000000000000001f
	</pre>

	<p>Стандартных возможностей вводить дробные значения не в десятичной системе в Java нет, однако классы Float и Double предоставляют много вспомогательных методов, в том числе и для такой задачи.</p>

	<h1 id="title">
		Логические литералы
	</h1>

	<p>Логические литералы имеют два возможных значения – true и false.</p>
	<p>Эти два зарезервированных слова не являются ключевыми, но также не могут использоваться в качестве идентификатора.</p>

	<h1 id="title">
		Символьные литералы
	</h1>

	<p>Символьные литералы описывают один символ из набора Unicode, заключенный в одиночные кавычки, или апострофы ( ASCII -символ single quote, \u0027 ).</p>
	<p>Например:</p>

	<pre class="brush: csharp;">
	'a' // латинская буква а
	' ' // пробел
	'K' // греческая буква каппа
	</pre>

	<p>Также допускается специальная запись для описания символа через его код (см. тему "Кодировка").</p>
	<p>Примеры:</p>

	<pre class="brush: csharp;">
	'\u0041' // латинская буква A
	'\u0410' // русская буква А
	'\u0391' // греческая буква A
	</pre>

	<p>Символьный литерал должен содержать строго один символ, или специальную последовательность, начинающуюся с \.</p>
	<p>Для записи специальных символов (неотображаемых и служебных, таких как ", ', \ ) используются следующие обозначения:</p>

	<pre class="brush: csharp;">
	\b  \u0008  backspace BS – забой
	\t  \u0009  horizontal tab HT – табуляция
	\n  \u000a  linefeed LF – конец строки
	\f  \u000c  form feed FF – конец страницы
	\r  \u000d  carriage return CR – возврат каретки
	\"  \u0022  double quote " – двойная кавычка
	\'  \u0027  single quote ' – одинарная кавычка
	\\  \u005c  backslash \ – обратная косая черта
	\шестнадцатеричный код  от \u0000 до \u00ff символа в шестнадцатеричном формате.
	</pre>

	<p>Первая колонка описывает стандартные обозначения специальных символов, используемые в Java-программах.</p>
	<p>Вторая колонка представляет их в стандартном виде Unicode -символов.</p>
	<p>Третья колонка содержит английские и русские описания.</p>
	<p>Использование \ в комбинации с другими символами приведет к ошибке компиляции.</p>
	<p>Поддержка ввода символов через восьмеричный код обеспечивается для совместимости с С.</p>
	<p>Например:</p>

	<pre class="brush: csharp;">
	// Эквивалентно '\u0041'
	'\101'
	</pre>

	<p>Однако таким образом можно задать лишь символы от \u0000 до \u00ff (т.е. с кодом от 0 до 255), поэтому Unicode -последовательности предпочтительней.</p>
	<p>Поскольку обработка Unicode -последовательностей (\uhhhh) производится раньше лексического анализа, то следующий пример является ошибкой:</p>

	<pre class="brush: csharp;">
	// символ конца строки
	'\u000a'
	</pre>

	<p>Компилятор сначала преобразует \u000a в символ конца строки и кавычки окажутся на разных строках кода, что является ошибкой.</p>
	<p>Необходимо использовать специальную последовательность:</p>

	<pre class="brush: csharp;">
	// правильное обозначение конца строки
	'\n'
	</pre>

	<p>Аналогично и для символа \u000d (возврат каретки) необходимо использовать обозначение \r.</p>
	<p>Специальные символы можно использовать в составе как символьных, так и строковых литералов.</p>

	<h1 id="title">
		Строковые литералы
	</h1>

	<p>Строковые литералы состоят из набора символов и записываются в двойных кавычках.</p>
	<p>Длина может быть нулевой или сколь угодно большой.</p>
	<p>Любой символ может быть представлен специальной последовательностью, начинающейся с \ (см. "Символьные литералы ").</p>

	<pre class="brush: csharp;">
	// литерал нулевой длины
	""

	//литерал, состоящий из одного символа "
	"\""

	//литерал длины 13
	"Простой текст"
	</pre>

	<p>Строковый литерал нельзя разбивать на несколько строк в коде программы.</p>
	<p>Если требуется текстовое значение, состоящее из нескольких строк, то необходимо воспользоваться специальными символами \n и/или \r.</p>
	<p>Если же текст просто слишком длинный, чтобы уместиться на одной строке кода, можно использовать оператор конкатенации строк +.</p>
	<p>Примеры строковых литералов:</p>

	<pre class="brush: csharp;">
	// выражение-константа, составленное из двух литералов
	"Длинный текст " +
	"с переносом"

	/*
	Строковый литерал, содержащий текст из двух строк:
	Hello, world!
	Hello!
	*/

	"Hello, world!\r\nHello!"
	</pre>

	<p>На строковые литералы распространяются те же правила, что и на символьные в отношении использования символов новой строки \u000a и \u000d.</p>
	<p>Каждый строковый литерал является экземпляром класса String.</p>
	<p>Это определяет некоторые необычные свойства строковых литералов, которые будут рассмотрены в следующей лекции.</p>

	<h1 id="title">
		Null-литерал
	</h1>

	<p>Null- литерал может принимать всего одно значение: null.</p>
	<p>Это литерал ссылочного типа, причем эта ссылка никуда не ссылается, объект отсутствует.</p>
	<p>Разумеется, его можно применять к ссылкам любого объектного типа данных.</p>
	<p>Типы данных подробно рассматриваются в следующей лекции.</p>

	<h1 id="title">
		Разделители
	</h1>

	<p>Разделители – это специальные символы, которые используются в служебных целях языка.</p>
	<p>Назначение каждого из них будет рассмотрено по ходу изложения курса.</p>
	<p>Вот их полный список:</p>

	<pre class="brush: csharp;">
	( ) [ ] { } ; . ,
	</pre>

	<h1 id="title">
		Операторы
	</h1>

	<p>Операторы используются в различных операциях – арифметических, логических, битовых, операциях сравнения и присваивания.</p>
	<p>Следующие 37 лексем (все состоят только из ASCII символов) являются операторами языка Java:</p>

	<pre class="brush: csharp;">
	=
	>
	<
	!
	~
	?
	:
	==
	<=
	>=
	!=
	&&
	||
	+
	--
	+
	-
	*
	/
	&
	|
	^
	%
	<<
	>>
	>>>
	+=
	-=
	*=
	/=
	&=
	|=
	^=
	%=
	<<=
	>>=
	>>>=
	</pre>

	<p>Большинство из них вполне очевидны и хорошо известны из других языков программирования, однако некоторые нюансы в работе с операторами в Java все же присутствуют, поэтому в конце лекции приводятся краткие комментарии к ним.</p>

	<h1 id="title">
		Пример программы
	</h1>

	<p>В заключение для примера приведем простейшую программу (традиционное Hello, world!), а затем классифицируем и подсчитаем используемые лексемы:</p>

	<pre class="brush: csharp;">
	public class Demo
	{
		/*
			Основной метод, с которого начинается выполнение любой Java программы.
		*/
		
		public static void main (String args[])
		{
			System.out.println("Hello, world!");
		}
	}
	</pre>

	<p>Итак, в приведенной программе есть один комментарий разработчика, 7 идентификаторов, 5 ключевых слов, 1 строковый литерал, 13 разделителей и ни одного оператора.</p>
	<p>Этот текст можно сохранить в файле Demo.java, скомпилировать и запустить.</p>
	<p>Результатом работы будет, как очевидно:</p>

	<pre class="brush: csharp;">
	Hello, world!
	</pre>

	<script src="../../../../js/progressBarSetIni.js" type="text/javascript"></script>

        <div id="lessMenu" style="margin: 30px 0 0 0;">
            <hr />
            <a href="21.html"><div id="exitLess" ontouchstart="return true;"><img src="../../../../img/menu/pr.png" /></div></a>
            <a href="23.html"><div id="aaLess" ontouchstart="return true;"><img src="../../../../img/menu/ne.png" /></div></a>
        </div>

    </div>

    <script type="text/javascript" src="../../../../cordova.js"></script>
    <script type="text/javascript" src="../../../../js/global.js"></script>
    <script type="text/javascript">
        changeColor();
        if (localStorage.getItem("fSize") < 1) { fSize = 16; localStorage.setItem("fSize", 16); } else { fSize = localStorage.getItem("fSize"); }
        document.getElementById("pageBody").style.fontSize = fSize + "px";

        // goBackMenu
        document.addEventListener("backbutton", goBackMenu, false);
        function goBackMenu()
        {
            window.location.href = 'list.html';
        }

        function changeColor()
        {
            if (localStorage.getItem("colorSheme") <= 1)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#f0f0f0");
            }

            if (localStorage.getItem("colorSheme") == 2)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#212121");
                document.getElementById("pageBody").style.color = localStorage.getItem("#efefef");
            }

            if (localStorage.getItem("colorSheme") == 3)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#efe4d0");
            }
        }

        // bm
        if (localStorage.getItem("arrs") != null)
        {
            var arrs = JSON.parse(localStorage.getItem("arrs"));
        }
        else
        {
            var arrs = [];
        }

        var names = ["../acharter/ru/java/book/22.html", "Виды лексем", "bm623"];

        function setzBm() { arrs.push(names); localStorage.setItem("arrs", JSON.stringify(arrs)); localStorage.setItem("bm623", 1); RefBms(); }

        window.onload = function() { RefBms(); }

        function RefBms()
        {
            if (localStorage.getItem("bm623") == 1) { document.getElementById("bma623").style.display = "block"; document.getElementById("bm623").style.display = "none"; } else { document.getElementById("bma623").style.display = "none"; document.getElementById("bm623").style.display = "block"; }
        }

        function dellBm() { for (var i = 0; i < arrs.length; i++) { if (arrs[i].indexOf("Виды лексем") == 1) { arrs.splice(i, 1); localStorage.setItem("bm623", 0); RefBms(); localStorage.setItem("arrs", JSON.stringify(arrs)); } } }

        // sub menu
        var serTimeToClose = 1000;
        
        function OpenSettMenu()
        {
            document.getElementById("subMenuInLess").style.display = "block";
            timeToEvAct();
            serTimeToClose = 1;
        }
        
        function timeToEvAct()
        {
            setTimeout(function() { serTimeToClose = 0 }, 100);
        }
        
        window.addEventListener('click', function(e){
        
            if (serTimeToClose <= 0)
            {
                if (document.getElementById('subMenuInLess').contains(e.target))
                {
                    //
                }
                else
                {
                    document.getElementById("subMenuInLess").style.display = "none";
                }
            }
        });

    </script>

</body>
</html>
