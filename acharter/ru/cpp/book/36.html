<!DOCTYPE html>

<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <link rel="stylesheet" type="text/css" href="../../../../css/read.css" />
    <title>Coder Book menu</title>
    <script type="text/javascript" src="../../../../higtline/scripts/shCore.js"></script>
    <script type="text/javascript" src="../../../../higtline/scripts/shBrushCSharp.js"></script>
    <link type="text/css" rel="stylesheet" href="../../../../higtline/styles/shCoreDefault.css"/>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <script src="../../../../js/Hyphenator.js" type="text/javascript"></script>
</head>

<body id="pageBody" class="hyphenate">

<!-- progress bar -->
<script src="../../../../js/progressBar.js" type="text/javascript"></script>
<div class="Reading-progress" id="progressBarType1"><span id="Progress-bar-top" class="bar-top" style="display: block !important;"></span></div>
<div class="Reading-progress" id="progressBarType2"><span id="Progress-bar-bottom" class="bar-bottom"></span></div>
<div class="Reading-progress" id="progressBarType3"><span id="Progress-bar-left" class="bar-left"></span></div>
<div class="Reading-progress" id="progressBarType4"><span id="Progress-bar-right" class="bar-right"></span></div>
<!-- progress bar -->


    <div id="lesonPage">

        <div id="lessMenu">
           <a id="exitLess" href="list.html" ontouchstart="return true;"><img src="../../../../img/menu/ex.png" /></a>
           <div id="aaLess" ontouchstart="return true;" onclick="OpenSettMenu();"><img src="../../../../img/menu/aa.png" /></div>
           <div id="subMenuInLess" style="display: none;">
                <a href="../../../../menu/setfontsize-ru.html" ontouchstart="return true;" id="pastMenuInLess">Размер текста</a>
                <a href="../../../../menu/setcolor-ru.html" ontouchstart="return true;" id="pastMenuInLess">Цветовая темы</a>
                <a href="../../../../menu/setProgressBar-ru.html" ontouchstart="return true;" id="pastMenuInLess" style="border: none;">Прогресс бар</a>
           </div>
           <div id="aaLess" ontouchstart="return true;">
            <div class="bmEdit" onclick="dellBm();" id="bma57" ontouchstart="return true;" style="display: none;"><img src="../../../../img/menu/bmlessa.png" /></div>
            <div class="bmEdit" onclick="setzBm();" id="bm57" ontouchstart="return true;" style="display: block;"><img src="../../../../img/menu/bmless.png" /></div>
           </div>
        </div>

        <hr />

	<!-- ПОЧАТОК -->
	
	<h1 id="title">
		Символы и строки в С++
	</h1>

	<p>Символ – элементарная единица, некоторый набор которых несет определенный смысл.</p>
	<p>В языке программирования С++ предусмотрено использование символьных констант.</p>
	<p>Символьная константа – это целочисленное значение (типа int) представленное в виде символа, заключённого в одинарные кавычки, например 'a'.</p>
	<p>В таблице ASCII представлены символы и их целочисленные значения.</p>

	<pre class="brush: csharp;">
	// объявления символьной переменной
	char symbol = 'a';
	//  где symbol – имя переменной типа  char
	//  char – тип данных для хранения символов
	</pre>

	<p>Строки в С++ представляются как массивы элементов типа char, заканчивающиеся нуль-терминатором \0 называются С строками или строками в стиле С.</p>
	<p>\0  — символ нуль-терминатора.</p>
	<p>Символьные строки состоят из набора символьных констант заключённых в двойные кавычки.</p>
	<p>При объявлении строкового массива необходимо учитывать наличие в конце строки нуль-терминатора, и отводить дополнительный байт под него.</p>

	<pre class="brush: csharp;">
	// пример объявления строки
	char string[10];
	// где string – имя строковой переменной
	// 10 – размер массива, то есть в данной строке может поместиться 9 символов , последнее место отводится под нуль-терминатор.
	</pre>

	<p>Строка при объявлении  может быть инициализирована начальным значением, например, так:</p>

	<pre class="brush: csharp;">
	char string[10] = "abcdefghf";
	</pre>

	<p>Если подсчитать кол-во символов в двойных кавычках после символа равно их окажется 9, а размер строки 10 символов,  последнее  место отводится под нуль–терминатор, причём компилятор сам добавит его в конец строки.</p>

	<pre class="brush: csharp;">
	// посимвольная инициализация строки:
	char string[10] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'f', '\0'};
	// десятый  символ это  нуль-терминатор.
	</pre>

	<p>При объявлении строки не обязательно указывать её размер, но при этом обязательно нужно её инициализировать начальным значением.</p>
	<p>Тогда размер строки определится автоматически и в конец строки добавится нуль-терминатор.</p>

	<pre class="brush: csharp;">
	//инициализация строки без указания размера
	char string[] = "abcdefghf";
	//всё то же самое только размер не указываем.
	</pre>

	<p>Строка может содержать символы, цифры и специальные знаки.</p>
	<p>В С++ строки заключаются в двойные кавычки.</p>
	<p>Имя строки является константным указателем на первый символ.</p>
	<p>Разработаем программу, с использованием строк.</p>

	<pre class="brush: csharp;">
	// symbols.cpp: определяет точку входа для консольного приложения.
	#include "stdafx.h"
	#include &lt;iostream&gt;
	using namespace std;
	 
	int main(int argc, char* argv[])
	{
		// объявление и инициализация строки
		char string[] = "this is string - ";
		cout << "Enter the string: ";
		// строковый массив для ввода 
		char in_string[500];
		// функция gets() считывает все введённые символы с пробелами до тех пор, пока не будет нажата клавиша Enter 
		gets(in_string);
		// вывод строкового значения
		cout << string << in_string << endl;
		system("pause");
		return 0;
	}
	</pre>

	<p>В строке 12 с помощью функции gets() считаются все введённые символы с пробелами до тех пор, пока во вводимом потоке не встретится код клавиши enter.</p>
	<p>Если использовать операцию cin то из всего введённого считается последовательность символов до первого пробела.</p>

	<pre class="brush: csharp;">
	Enter the string: CppStudio.com
	this is string - CppStudio.com

	Для продолжения нажмите любую клавишу . . .
	</pre>

	<table>
		<tr>
			<th>Функция</th>
			<th>Пояснение</th>
		</tr>
		<tr>
			<td>strlen(имя_строки)</td>
			<td>определяет длину указанной строки, без учёта нуль-символа</td>
		</tr>
		<tr>
			<td>strcpy(s1,s2)</td>
			<td>выполняет побайтное копирование символов из строки s2 в строку s1</td>
		</tr>
		<tr>
			<td>strncpy(s1,s2, n)</td>
			<td>выполняет побайтное копирование n символов из строки s2 в строку s1. возвращает значения s1</td>
		</tr>
		<tr>
			<td>strcat(s1,s2)</td>
			<td>объединяет строку s2 со строкой s1. Результат сохраняется в s1</td>
		</tr>
		<tr>
			<td>strncat(s1,s2,n)</td>
			<td>объединяет n символов строки s2 со строкой s1. Результат сохраняется в s1</td>
		</tr>
		<tr>
			<td>strcmp(s1,s2)</td>
			<td>сравнивает строку s1 со строкой s2 и возвращает результат типа int: 0 –если строки эквивалентны, &gt;0 – если s1&lt;s2, &lt;0  — если s1&gt;s2 С учётом регистра</td>
		</tr>
		<tr>
			<td>strncmp(s1,s2,n)</td>
			<td>сравнивает n символов строки s1 со строкой s2 и возвращает результат типа int: 0 –если строки эквивалентны, &gt;0 – если s1&lt;s2, &lt;0  — если s1&gt;s2 С учётом регистра</td>
		</tr>
		<tr>
			<td>stricmp(s1,s2)</td>
			<td>сравнивает строку s1 со строкой s2 и возвращает результат типа int: 0 –если строки эквивалентны, &gt;0 – если s1&lt;s2, &lt;0  — если s1&gt;s2 Без учёта регистра</td>
		</tr>
		<tr>
			<td>strnicmp(s1,s2,n)</td>
			<td>сравнивает n символов строки s1 со строкой s2 и возвращает результат типа int: 0 –если строки эквивалентны, &gt;0 – если s1&lt;s2, &lt;0 — если s1&gt;s2 Без учёта регистра</td>
		</tr>
		<tr>
			<td>isalnum(c)</td>
			<td>возвращает значение true, если с является буквой или цифрой, и false в других случаях</td>
		</tr>
		<tr>
			<td>isalpha(c)</td>
			<td>возвращает значение true, если с является буквой,  и false в других случаях</td>
		</tr>
		<tr>
			<td>isdigit(c)</td>
			<td>возвращает значение true, если с является цифрой, и false в других случаях</td>
		</tr>
		<tr>
			<td>islower(c)</td>
			<td>возвращает значение true, если с является буквой нижнего регистра, и false в других случаях</td>
		</tr>
		<tr>
			<td>isupper(c)</td>
			<td>возвращает значение true, если с является буквой верхнего регистра, и false в других случаях</td>
		</tr>
		<tr>
			<td>isspace(c)</td>
			<td>возвращает значение true, если с является пробелом, и false в других случаях</td>
		</tr>
		<tr>
			<td>toupper(c)</td>
			<td>если символ с, является символом нижнего регистра, то функция возвращает преобразованный символ с в верхнем регистре, иначе символ возвращается без изменений.</td>
		</tr>
		<tr>
			<td>strchr(s,c)</td>
			<td>поиск первого вхождения символа с в строке s. В случае удачного поиска возвращает указатель на место первого вхождения символа с. Если символ не найден, то возвращается ноль.</td>
		</tr>
		<tr>
			<td>strcspn(s1,s2)</td>
			<td>определяет длину начального сегмента строки s1, содержащего те символы, которые не входят в строку s2</td>
		</tr>
		<tr>
			<td>strspn(s1,s2)</td>
			<td>возвращает длину начального сегмента строки s1, содержащего только те символы, которые входят в строку s2</td>
		</tr>
		<tr>
			<td>strprbk(s1,s2)</td>
			<td>Возвращает указатель  первого вхождения любого символа строки s2 в строке s1</td>
		</tr>
		<tr>
			<td>atof(s1)</td>
			<td>преобразует строку s1 в тип double</td>
		</tr>
		<tr>
			<td>atoi(s1)</td>
			<td>преобразует строку s1 в тип int</td>
		</tr>
		<tr>
			<td>atol(s1)</td>
			<td>преобразует строку s1 в тип long int</td>
		</tr>
		<tr>
			<td>getchar(с)</td>
			<td>считывает символ с со стандартного потока ввода, возвращает символ в формате int</td>
		</tr>
		<tr>
			<td>gets(s)</td>
			<td>считывает поток символов со стандартного устройства ввода в строку s до тех пор, пока не будет нажата клавиша ENTER</td>
		</tr>
	</table>

	<p>Разработаем несколько программ, используя функции для работы со строками и символами.</p>

	<h1 id="title">
		Копирование строк
	</h1>
	
	<pre class="brush: csharp;">
	// str_cpy.cpp: определяет точку входа для консольного приложения.
	#include "stdafx.h"
	#include &lt;iostream&gt;
	using namespace std;
	 
	int main(int argc, char* argv[])
	{
		// инициализация строки s2
		char s2[27] = "Counter-Strike 1.6 forever";
		// резервируем строку для функции strcpy()
		char s1[27];
		// содержимое строки s2 скопировалось в строку s1, возвращается указатель на s1
		cout << "strcpy(s1,s2) = " << strcpy(s1,s2) << endl;
		// вывод содержимого строки s1
		cout << "s1= " << s1 << endl;
		// резервируем строку для следующей функции
		char s3[7];
		// копируем 7 символов из строки s2 в строку s3
		cout << strncpy(s3, s2, 7) << endl;
		system("pause");
		return 0;
	}
	</pre>

	<p>В строках 9, 10 создаём строковые массивы на 27 символов, словосочетание "Counter-Strike 1.6 forever" содержит 26 символов, последнее место в массиве займет нуль-символ.</p>
	<p>В строке 11 функция strcpy(s1,s2) копирует  значение строки  s2 в строку s1 и возвращает указатель на строку s1.</p>
	<p>Если строка s1 будет меньше строки s2, то скопируется то количество символов, которое вместится в  строку s2.</p>
	<p>Строка 10 всего лишь показывает, что в строке s1 содержится скопированное значение.</p>
	<p>В строке 14 функция strncpy(s3, s2, sizeof(s3)) выполняет копирование 7 символов строки s2 в строку s3В строках 9, 10 создаём строковые массивы на 27 символов, словосочетание "Counter-Strike 1.6 forever" содержит 26 символов, последнее место в массиве займет нуль-символ.</p>
	<p>В строке 11 функция strcpy(s1,s2) копирует  значение строки  s2 в строку s1 и возвращает указатель на строку s1.</p>
	<p>Если строка s1 будет меньше строки s2, то скопируется то количество символов, которое вместится в  строку s2.</p>
	<p>Строка 10 всего лишь показывает, что в строке s1 содержится скопированное значение.</p>
	<p>В строке 14 функция strncpy(s3, s2, sizeof(s3)) выполняет копирование 7 символов строки s2 в строку s3.</p>

	<pre class="brush: csharp;">
	strcpy(s1,s2) = Counter-Strike 1.6 forever
	s1= Counter-Strike 1.6 forever
	CounterCounter-Strike 1.6 forever

	Для продолжения нажмите любую клавишу . . .
	</pre>

	<h1 id="title">
		Сравнение строк
	</h1>

	<p>Рассмотрим работу функции strcmp(), остальные функции используются аналогично, так что каждую рассматривать не будем.</p>

	<pre class="brush: csharp;">
	// str_cmp.cpp: определяет точку входа для консольного приложения.
	#include "stdafx.h"
	#include &lt;iostream&gt;
	#include &lt;iomanip&gt;
	using namespace std;
	 
	int main(int argc, char* argv[])
	{
		char s1[] = "www.cppstudio.com";
		char s2[] = "http://www.cppstudio.com";
		// строка s1 = s1
		cout << " s1 == s1 -> " << setw(2) << strcmp(s1,s1) << endl;
		// строка s1 < s2
		cout << " s1 <  s2 -> " << setw(2) << strcmp(s1,s2) << endl;
		// строка s2 > s1
		cout << " s2 >  s1 -> " << setw(2) << strcmp(s2,s1) << endl;
		system("pause");
		return 0;
	}
	</pre>

	<p>В строках 12, 13, 14 функция strcmp() выполняет сравнение строк, в различном порядке, таким образом были рассмотрены все возможные варианты работы данной функции.</p>
	<p>В первом случае строку s1 сравнивали с самой собой соответственно и результат равен 0.</p>
	<p>Во втором случае строка s1 оказалась меньше строки s2 поэтому результат равен 1.</p>
	<p>В третьем случае строка s1 по-прежнему меньше строки s2, но мы поменяли эти строки местами, таким образом, порядок параметров функции изменился и результат стал равен -1.</p>

	<pre class="brush: csharp;">
	s1 == s1 -> 0
	s1 < s2 -> 1
	s2 > s1 -> -1

	Для продолжения нажмите любую клавишу . . .
	</pre>

        <script src="../../../../js/progressBarSetIni.js" type="text/javascript"></script>

        <div id="lessMenu" style="margin: 30px 0 0 0;">
            <hr />
            <a href="35.html"><div id="exitLess" ontouchstart="return true;"><img src="../../../../img/menu/pr.png" /></div></a>
            <a href="37.html"><div id="aaLess" ontouchstart="return true;"><img src="../../../../img/menu/ne.png" /></div></a>
        </div>

    </div>

    <script type="text/javascript" src="../../../../cordova.js"></script>
    <script type="text/javascript" src="../../../../js/global.js"></script>
    <script type="text/javascript">
        changeColor();
        if (localStorage.getItem("fSize") < 1) { fSize = 16; localStorage.setItem("fSize", 16); } else { fSize = localStorage.getItem("fSize"); }
        document.getElementById("pageBody").style.fontSize = fSize + "px";

        // goBackMenu
        document.addEventListener("backbutton", goBackMenu, false);
        function goBackMenu()
        {
            window.location.href = 'list.html';
        }

        function changeColor()
        {
            if (localStorage.getItem("colorSheme") <= 1)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#f0f0f0");
            }

            if (localStorage.getItem("colorSheme") == 2)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#212121");
                document.getElementById("pageBody").style.color = localStorage.getItem("#efefef");
            }

            if (localStorage.getItem("colorSheme") == 3)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#efe4d0");
            }
        }

        // bm
        if (localStorage.getItem("arrs") != null)
        {
            var arrs = JSON.parse(localStorage.getItem("arrs"));
        }
        else
        {
            var arrs = [];
        }

        var names = ["../acharter/ru/cpp/book/36.html", "Символы и строки в С++", "bm57"];

        function setzBm() { arrs.push(names); localStorage.setItem("arrs", JSON.stringify(arrs)); localStorage.setItem("bm57", 1); RefBms(); }

        window.onload = function() { RefBms(); }

        function RefBms()
        {
            if (localStorage.getItem("bm57") == 1) { document.getElementById("bma57").style.display = "block"; document.getElementById("bm57").style.display = "none"; } else { document.getElementById("bma57").style.display = "none"; document.getElementById("bm57").style.display = "block"; }
        }

        function dellBm() { for (var i = 0; i < arrs.length; i++) { if (arrs[i].indexOf("Символы и строки в С++") == 1) { arrs.splice(i, 1); localStorage.setItem("bm57", 0); RefBms(); localStorage.setItem("arrs", JSON.stringify(arrs)); } } }

        // sub menu
        var serTimeToClose = 1000;
        
        function OpenSettMenu()
        {
            document.getElementById("subMenuInLess").style.display = "block";
            timeToEvAct();
            serTimeToClose = 1;
        }
        
        function timeToEvAct()
        {
            setTimeout(function() { serTimeToClose = 0 }, 100);
        }
        
        window.addEventListener('click', function(e){
        
            if (serTimeToClose <= 0)
            {
                if (document.getElementById('subMenuInLess').contains(e.target))
                {
                    //
                }
                else
                {
                    document.getElementById("subMenuInLess").style.display = "none";
                }
            }
        });

    </script>

</body>
</html>
