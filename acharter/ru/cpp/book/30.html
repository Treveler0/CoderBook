<!DOCTYPE html>

<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <link rel="stylesheet" type="text/css" href="../../../../css/read.css" />
    <title>Coder Book menu</title>
    <script type="text/javascript" src="../../../../higtline/scripts/shCore.js"></script>
    <script type="text/javascript" src="../../../../higtline/scripts/shBrushCSharp.js"></script>
    <link type="text/css" rel="stylesheet" href="../../../../higtline/styles/shCoreDefault.css"/>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <script src="../../../../js/Hyphenator.js" type="text/javascript"></script>
</head>

<body id="pageBody" class="hyphenate">

<!-- progress bar -->
<script src="../../../../js/progressBar.js" type="text/javascript"></script>
<div class="Reading-progress" id="progressBarType1"><span id="Progress-bar-top" class="bar-top" style="display: block !important;"></span></div>
<div class="Reading-progress" id="progressBarType2"><span id="Progress-bar-bottom" class="bar-bottom"></span></div>
<div class="Reading-progress" id="progressBarType3"><span id="Progress-bar-left" class="bar-left"></span></div>
<div class="Reading-progress" id="progressBarType4"><span id="Progress-bar-right" class="bar-right"></span></div>
<!-- progress bar -->


    <div id="lesonPage">

        <div id="lessMenu">
           <a id="exitLess" href="list.html" ontouchstart="return true;"><img src="../../../../img/menu/ex.png" /></a>
           <div id="aaLess" ontouchstart="return true;" onclick="OpenSettMenu();"><img src="../../../../img/menu/aa.png" /></div>
           <div id="subMenuInLess" style="display: none;">
                <a href="../../../../menu/setfontsize-ru.html" ontouchstart="return true;" id="pastMenuInLess">Размер текста</a>
                <a href="../../../../menu/setcolor-ru.html" ontouchstart="return true;" id="pastMenuInLess">Цветовая темы</a>
                <a href="../../../../menu/setProgressBar-ru.html" ontouchstart="return true;" id="pastMenuInLess" style="border: none;">Прогресс бар</a>
           </div>
           <div id="aaLess" ontouchstart="return true;">
            <div class="bmEdit" onclick="dellBm();" id="bma51" ontouchstart="return true;" style="display: none;"><img src="../../../../img/menu/bmlessa.png" /></div>
            <div class="bmEdit" onclick="setzBm();" id="bm51" ontouchstart="return true;" style="display: block;"><img src="../../../../img/menu/bmless.png" /></div>
           </div>
        </div>

        <hr />

	<!-- ПОЧАТОК -->
	
	<h1 id="title">
		Указатели в С++
	</h1>

	<p>Указатель – переменная, значением которой является адрес ячейки памяти.</p>
	<p>То есть указатель ссылается на блок данных  из области памяти, причём на самое его начало.</p>
	<p>Указатель может ссылаться на переменную или функцию.</p>
	<p>Для этого нужно знать адрес переменной или функции.</p>
	<p>Так вот, чтобы узнать адрес конкретной переменной в С++ существует унарная операция взятия адреса &.</p>
	<p>Такая операция извлекает адрес объявленных переменных, для того, чтобы его присвоить указателю.</p>
	<p>Указатели используются для передачи по ссылке данных, что намного ускоряет процесс обработки этих данных (в том случае, если объём данных большой), так как их не надо копировать, как при передаче по значению, то есть, используя имя переменной.</p>
	<p>В основном указатели используются для организации динамического распределения памяти, например при объявлении массива, не надо будет его ограничивать в размере.</p>
	<p>Ведь программист заранее не может знать, какого размера нужен массив тому или иному пользователю, в таком случае используется динамическое выделение памяти под массив.</p>
	<p>Любой указатель необходимо объявить перед использованием, как и любую переменную.</p>
	
	<pre class="brush: csharp;">
	//объявление указателя
	/*тип данных*/  * /*имя указателя*/;
	</pre>

	<p>Принцип объявления указателей такой же, как и принцип объявления переменных.</p>
	<p>Отличие заключается только в том, что перед именем ставится символ звёздочки *.</p>
	<p>Визуально указатели отличаются от переменных только одним символом.</p>
	<p>При объявлении указателей компилятор выделяет несколько байт памяти, в зависимости от типа данных отводимых для хранения некоторой информации в памяти.</p>
	<p>Чтобы получить значение, записанное в некоторой области, на которое ссылается указатель нужно воспользоваться операцией разыменования указателя *.</p>
	<p>Необходимо поставить звёздочку перед именем и получим доступ к значению указателя.</p>
	<p>Разработаем программу, которая будет использовать указатели.</p>

	<pre class="brush: csharp;">
	// pointer1.cpp: определяет точку входа для консольного приложения.
	#include "stdafx.h"
	#include &lt;iostream&gt;
	using namespace std;
	 
	int main(int argc, char* argv[])
	{
		// инициализация переменной var числом 123
		int var = 123;
		// указатель на переменную var (присвоили адрес переменной указателю)
		int *ptrvar = &var;
		// адрес переменной var содержащийся в памяти, извлечённый операцией взятия адреса
		cout << "&var    = " << &var << endl;
		// адрес переменной var, является значением указателя ptrvar
		cout << "ptrvar  = " << ptrvar << endl;
		// значение в переменной var
		cout << "var     = " << var << endl;
		// вывод значения содержащегося в переменной var через указатель, операцией разименования указателя
		cout << "*ptrvar = " << *ptrvar << endl; 
		system("pause");
		return 0;
	}
	</pre>

	<p>В строке 11 объявлен и инициализирован адресом переменной var указатель ptrvar.</p>
	<p>Можно было сначала просто объявить указатель, а потом его инициализировать, тогда были бы две строки:</p>

	<pre class="brush: csharp;">
	// объявление указателя
	int *ptrvar;
	
	// инициализация указателя
	ptrvar = &var;
	</pre>

	<p>В программировании принято добавлять к имени указателя приставку ptr, таким образом, получится осмысленное имя указателя, и уже с обычной переменной такой указатель не спутаешь.</p>
	<p>Результат работы программы:</p>

	<pre class="brush: csharp;">
	&var = 0x22ff08
	ptrvar = 0x22ff08
	var = 123
	*ptrvar = 123

	Для продолжения нажмите любую клавишу . . .
	</pre>

	<p>Итак, программа показала, что строки 11 и 12 выводят идентичный адрес, то есть адрес переменной var, который содержится в указателе ptrvar.</p>
	<p>Тогда как операция разыменования указателя *ptrvar обеспечивает доступ к значению, на которое ссылается указатель.</p>
	<p>Указатели можно сравнивать не только на равенство или неравенство, ведь адреса могут быть меньше или больше относительно друг друга.</p>
	<p>Разработаем программу, которая будет сравнивать адреса указателей.</p>

	<pre class="brush: csharp;">
	// pointer.cpp: определяет точку входа для консольного приложения.
	#include "stdafx.h"
	#include &lt;iostream&gt;
	using namespace std;
	 
	int main(int argc, char* argv[])
	{
		// инициализация переменной var1 числом 123
		int var1 = 123;
		
		// инициализация переменной var2 числом 99
		int var2 = 99;
		
		// указатель на переменную var1
		int *ptrvar1 = &var1;
		
		// указатель на переменную var2
		int *ptrvar2 = &var2;
		cout << "var1 = " << var1 << endl;
		cout << "var2 = " << var2 << endl;
		cout << "ptrvar1 = " << ptrvar1 << endl;
		cout << "ptrvar2 = " << ptrvar2 << endl;
		
		// сравниваем значения указателей, то есть адреса переменных
		if (ptrvar1 > ptrvar2)
		cout << "ptrvar1 > ptrvar2" << endl;
		
		// сравниваем значения переменных, на которые ссылаются указатели
		if (*ptrvar1 > *ptrvar2)
		cout << "*ptrvar1 > *ptrvar2" << endl;
		system("pause");
		return 0;
	}
	</pre>

	<p>Результат работы программы показан ниже:</p>

	<pre class="brush: csharp;">
	var1 = 123
	var2 = 99
	ptrvar1 = 0x22ff04
	ptrvar2 = 0x22ff00
	ptrvar1 > ptrvar2
	*ptrvar1 > *ptrvar2

	Для продолжения нажмите любую клавишу . . .
	</pre>

	<p>В первом случае, мы сравнивали адреса  переменных, и, причём адрес второй переменной, всегда меньше адреса первой переменной.</p>
	<p>При каждом запуске программы адреса выделяются разные.</p>
	<p>Во втором случае мы сравнивали значения этих переменных используя операцию разыменования указателя.</p>
	<p>Из арифметических операций, чаще всего используются операции сложения, вычитания, инкремент и декремент, так как с помощью этих операций, например в массивах, вычисляется адрес следующего элемента.</p>

	<h1 id="title">
		Указатели на указатели
	</h1>

	<p>Указатели могут ссылаться на другие указатели.</p>
	<p>При этом в ячейках памяти, на которые будут ссылаться первые указатели, будут содержаться не значения, а адреса вторых указателей.</p>
	<p>Число символов * при объявлении указателя показывает порядок указателя.</p>
	<p>Чтобы получить доступ к значению, на которое ссылается указатель его необходимо разыменовывать соответствующее количество раз.</p>
	<p>Разработаем программу, которая будет выполнять некоторые операции с указателями порядка выше первого.</p>

	<pre class="brush: csharp;">
	// pointer.cpp: определяет точку входа для консольного приложения.
	#include "stdafx.h"
	#include &lt;iostream&gt;
	using namespace std;
	 
	int _tmain(int argc, _TCHAR* argv[])
	{
		// инициализация переменной var числом 123
		int var = 123;
		
		// указатель на переменную var
		int *ptrvar = &var;
		
		// указатель на указатель на переменную var
		int **ptr_ptrvar = &ptrvar;
		int ***ptr_ptr_ptrvar = &ptr_ptrvar;
		cout << " var\t\t= " << var << endl;
		cout << " *ptrvar\t= " << *ptrvar << endl;
		
		// два раза разименовываем указатель, так как он второго порядка
		cout << " **ptr_ptrvar   = " << **ptr_ptrvar << endl;
		
		// указатель третьего порядка
		cout << " ***ptr_ptrvar  = " << ***ptr_ptr_ptrvar << endl;
		cout << "\n ***ptr_ptr_ptrvar -> **ptr_ptrvar -> *ptrvar -> var -> "<< var << endl;
		cout << "\t  " << &ptr_ptr_ptrvar<< " -> " << "    " << &ptr_ptrvar << " ->" << &ptrvar << " -> " << &var << " -> " << var << endl;
		system("pause");
		return 0;
	}
	</pre>	

	<p>Результат работы программы:</p>

	<pre class="brush: csharp;">
	var = 123
	*ptrvar = 123
	**ptr_ptrvar = 123
	***ptr_ptrvar = 123
	***ptr_ptr_ptrvar -> **ptr_ptrvar -> *ptrvar ->      var -> 123
	0x22ff00 -> 0x22ff04 ->0x22ff08 -> 0x22ff0c -> 123

	Для продолжения нажмите любую клавишу . . .
	</pre>

	<p>Данная программа доказывает тот факт, что для получения значения количество разыменований указателя должно совпадать с его порядком.</p>
	<p>Логика n-кратного разыменования заключается в том, что программа последовательно перебирает адреса всех указателей вплоть до переменной, в которой содержится значение.</p>
	<p>В программе показана реализация указателя третьего порядка.</p>
	<p>И если, используя такой  указатель (третьего порядка) необходимо получить значение, на которое он ссылается, делается 4 шага:</p>
	<p>1. по значению указателя третьего порядка получить адрес указателя второго порядка;</p>
	<p>2. по значению указателя второго порядка получить адрес указателя первого порядка;</p>
	<p>3. по значению указателя первого порядка получить адрес переменной;</p>
	<p>4. по адресу переменной получить доступ к её значению.</p>
	<p>Данные четыре действия показаны в результате работы программы выше (две предпоследние строки).</p>
	<p>Верхняя строка показывает имена указателей, а нижняя строка их адреса.</p>


	<h1 id="title">
		Указатели на функции
	</h1>

	<p>Указатели могут ссылаться на функции.</p>
	<p>Имя функции, как и имя массива само по себе является указателем, то есть содержит адрес входа.	</p>

	<pre class="brush: csharp;">
	// объявление указателя на функцию
	/*тип данных*/ (* /*имя указателя*/)(/*список аргументов функции*/);
	</pre>

	<p>Тип данных определяем такой, который будет возвращать функция, на которую будет ссылаться указатель.</p>
	<p>Символ указателя и его имя берутся в круглые скобочки, чтобы показать, что это указатель, а не функция, возвращающая указатель на определённый тип данных.</p>
	<p>После имени указателя идут круглые скобки, в этих скобках перечисляются все аргументы через запятую как в объявлении прототипа функции.</p>
	<p>Аргументы наследуются от той функции, на которую будет ссылаться указатель.</p>
	<p>Разработаем программу, которая использует указатель на функцию.</p>
	<p>Программа должна находить НОД – наибольший общий делитель.</p>
	<p>НОД – это наибольшее целое число, на которое без остатка делятся два числа, введенных пользователем.</p>
	<p>Входные числа также должны быть целыми.</p>

	<pre class="brush: csharp;">
	// pointer_onfunc.cpp: определяет точку входа для консольного приложения.
	#include "stdafx.h"
	#include &lt;iostream&gt;
	using namespace std;

	// прототип указываемой функции
	int nod(int, int );
	int main(int argc, char* argv[])
	{
		// объявление указателя на функцию
		int (*ptrnod)(int, int);
		// присваиваем адрес функции указателю ptrnod
		ptrnod=nod;
		int a, b;
		cout << "Enter first number: ";
		cin >> a;
		cout << "Enter second number: ";
		cin >> b;
		// обращаемся к функции через указатель
		cout << "NOD = " << ptrnod(a, b) << endl;
		system("pause");
		return 0;
	}
	// рекурсивная функция нахождения наибольшего общего делителя НОД
	int nod(int number1, int number2)
	{
		//базовое решение
		if ( number2 == 0 )
		return number1;
		// рекурсивное решение НОД
		return nod(number2, number1 % number2);
	}
	</pre>

	<p>Данная задача решена рекурсивно, чтоб уменьшить объём кода программы, по сравнению с итеративным решением этой же задачи.</p>
	<p>В строке 11 объявляется указатель, которому в строке 13 присвоили адрес функции.</p>
	<p>Как мы уже говорили до этого, адресом функции является просто её имя.</p>
	<p>То есть данный указатель теперь указывает на функцию nod().</p>
	<p>При объявлении указателя на функцию ни в коем случае не забываем о скобочках, в которые заключаются символ указателя и его имя.</p>
	<p>При объявлении указателя в аргументах указываем то же самое, что и в прототипе указываемой функции.</p>
	<p>Результат работы программы:</p>

	<pre class="brush: csharp;">
	Enter first number: 16
	Enter second number: 20
	NOD = 4

	Для продолжения нажмите любую клавишу . . .
	</pre>

	<p>Вводим первое число, затем второе и программа выдает НОД.</p>
	<p>В результате видно, что НОД для чисел 16 и 20 равен четырём.</p>

        <script src="../../../../js/progressBarSetIni.js" type="text/javascript"></script>

        <div id="lessMenu" style="margin: 30px 0 0 0;">
            <hr />
            <a href="29.html"><div id="exitLess" ontouchstart="return true;"><img src="../../../../img/menu/pr.png" /></div></a>
            <a href="31.html"><div id="aaLess" ontouchstart="return true;"><img src="../../../../img/menu/ne.png" /></div></a>
        </div>

    </div>

    <script type="text/javascript" src="../../../../cordova.js"></script>
    <script type="text/javascript" src="../../../../js/global.js"></script>
    <script type="text/javascript">
        changeColor();
        if (localStorage.getItem("fSize") < 1) { fSize = 16; localStorage.setItem("fSize", 16); } else { fSize = localStorage.getItem("fSize"); }
        document.getElementById("pageBody").style.fontSize = fSize + "px";

        // goBackMenu
        document.addEventListener("backbutton", goBackMenu, false);
        function goBackMenu()
        {
            window.location.href = 'list.html';
        }

        function changeColor()
        {
            if (localStorage.getItem("colorSheme") <= 1)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#f0f0f0");
            }

            if (localStorage.getItem("colorSheme") == 2)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#212121");
                document.getElementById("pageBody").style.color = localStorage.getItem("#efefef");
            }

            if (localStorage.getItem("colorSheme") == 3)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#efe4d0");
            }
        }

        // bm
        if (localStorage.getItem("arrs") != null)
        {
            var arrs = JSON.parse(localStorage.getItem("arrs"));
        }
        else
        {
            var arrs = [];
        }

        var names = ["../acharter/ru/cpp/book/30.html", "Указатели в С++", "bm51"];

        function setzBm() { arrs.push(names); localStorage.setItem("arrs", JSON.stringify(arrs)); localStorage.setItem("bm51", 1); RefBms(); }

        window.onload = function() { RefBms(); }

        function RefBms()
        {
            if (localStorage.getItem("bm51") == 1) { document.getElementById("bma51").style.display = "block"; document.getElementById("bm51").style.display = "none"; } else { document.getElementById("bma51").style.display = "none"; document.getElementById("bm51").style.display = "block"; }
        }

        function dellBm() { for (var i = 0; i < arrs.length; i++) { if (arrs[i].indexOf("Указатели в С++") == 1) { arrs.splice(i, 1); localStorage.setItem("bm51", 0); RefBms(); localStorage.setItem("arrs", JSON.stringify(arrs)); } } }

        // sub menu
        var serTimeToClose = 1000;
        
        function OpenSettMenu()
        {
            document.getElementById("subMenuInLess").style.display = "block";
            timeToEvAct();
            serTimeToClose = 1;
        }
        
        function timeToEvAct()
        {
            setTimeout(function() { serTimeToClose = 0 }, 100);
        }
        
        window.addEventListener('click', function(e){
        
            if (serTimeToClose <= 0)
            {
                if (document.getElementById('subMenuInLess').contains(e.target))
                {
                    //
                }
                else
                {
                    document.getElementById("subMenuInLess").style.display = "none";
                }
            }
        });

    </script>

</body>
</html>
