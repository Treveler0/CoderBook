<!DOCTYPE html>

<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <link rel="stylesheet" type="text/css" href="../../../../css/read.css" />
    <title>Coder Book menu</title>
    <script type="text/javascript" src="../../../../higtline/scripts/shCore.js"></script>
    <script type="text/javascript" src="../../../../higtline/scripts/shBrushCSharp.js"></script>
    <link type="text/css" rel="stylesheet" href="../../../../higtline/styles/shCoreDefault.css"/>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <script src="../../../../js/Hyphenator.js" type="text/javascript"></script>
</head>

<body id="pageBody" class="hyphenate">

<!-- progress bar -->
<script src="../../../../js/progressBar.js" type="text/javascript"></script>
<div class="Reading-progress" id="progressBarType1"><span id="Progress-bar-top" class="bar-top" style="display: block !important;"></span></div>
<div class="Reading-progress" id="progressBarType2"><span id="Progress-bar-bottom" class="bar-bottom"></span></div>
<div class="Reading-progress" id="progressBarType3"><span id="Progress-bar-left" class="bar-left"></span></div>
<div class="Reading-progress" id="progressBarType4"><span id="Progress-bar-right" class="bar-right"></span></div>
<!-- progress bar -->


    <div id="lesonPage">

        <div id="lessMenu">
           <a id="exitLess" href="list.html" ontouchstart="return true;"><img src="../../../../img/menu/ex.png" /></a>
           <div id="aaLess" ontouchstart="return true;" onclick="OpenSettMenu();"><img src="../../../../img/menu/aa.png" /></div>
           <div id="subMenuInLess" style="display: none;">
                <a href="../../../../menu/setfontsize-ru.html" ontouchstart="return true;" id="pastMenuInLess">Размер текста</a>
                <a href="../../../../menu/setcolor-ru.html" ontouchstart="return true;" id="pastMenuInLess">Цветовая темы</a>
                <a href="../../../../menu/setProgressBar-ru.html" ontouchstart="return true;" id="pastMenuInLess" style="border: none;">Прогресс бар</a>
           </div>
           <div id="aaLess" ontouchstart="return true;">
            <div class="bmEdit" onclick="dellBm();" id="bma149" ontouchstart="return true;" style="display: none;"><img src="../../../../img/menu/bmlessa.png" /></div>
            <div class="bmEdit" onclick="setzBm();" id="bm149" ontouchstart="return true;" style="display: block;"><img src="../../../../img/menu/bmless.png" /></div>
           </div>
        </div>

        <hr />

	<!-- ПОЧАТОК -->
	<h1 id="title">
		Пример класса и его объектов
	</h1>

	<p>Приведем пример объявления класса и особенностей работы с его объектами, рассмотрев, следующую задачу.</p>
	<p>В технике широко распространеы разнообразные цифровые счетчики, построенные по "кольцевой" схеме.</p>
	<p>В каждом из них задано предельное значение, по достижению которого счетчик "сбрасывается" в начальное состояние.</p>
	<p>Так обычно устроены счетчики километража (пробега) в автомобилях, счетчики потребления воды, электроэнергии и т.п.</p>
	<p>Определить класс Counter, объект которого моделирует работу кольцевого счетчика.</p>
	<p>В классе декларировать статическое поле maxCount для представления предельного значения, допустимого для показаний счетчиков – объектов класса.</p>
	<p>Текущее показание конкретного счетчика будет представлять целочисленное поле объекта (нестатическое поле класса) с именем count.</p>
	<p>В классе определить: метод increment() для увеличения на 1 текущего показания счетчика, метод getCount() для считывания текущего показания и метод display() для вывода информации о состоянии и возможностях счетчика.</p>
	<p>Один из возможных вариантов определения такого класса (программа 11_04.cs):</p>

	<pre class="brush: csharp;">
	// 11_04.cs - класс "кольцевой счетчик"
	using System;
	// Класс "кольцевой счетчик"
	class Counter
	{
		// Закрытые поля:
		// продельное значение
		static int maxCount = 100000;
		// текущее показание
		int count;

		// Метод - приращение показания:
		public void increment()
		{
			count += 1;
			if (count >= maxCount) count = 0;
		}

		// Метод для получения текущего показания:
		public int getCount()
		{ return count; }
		
		// Метод для вывода сведений о счетчике (об объекте):
		public void display()
		{
			Console.WriteLine("Reading: {0,-8} maxCount: {1,-8}", count, maxCount);
		}
	}
	</pre>

	<p>В объявлении полей static int maxCount и int count; модификаторы доступа не использованы, и по умолчанию переменные maxCount и count закрыты для доступа извне (имеют статус доступа private).</p>
	<p>Статическое поле maxCount инициализируется значением 100000 при компиляции.</p>
	<p>При создании каждого объекта класса инициализируется поле count конкретного объекта.</p>
	<p>Если инициализатор переменной поля отсутствует, то, как мы знаем, выполняется ее инициализация умолчиваемым значением.</p>
	<p>В нашем примере переменная count при создании объекта инициализируется целочисленным значением 0.</p>
	<p>В классе явно определены два нестатических открытых (имеющих статус доступа public) метода.</p>
	<p>Метод с заголовком public void increment() при каждом обращении к нему увеличивает на 1 значение показания (поля count), представляемого объектом класса Counter.</p>
	<p>У метода пустой список параметров и метод ничего не возвращает в точку вызова.</p>
	<p>Обратите внимание, что в теле метода изменяется закрытый член класса (поле count).</p>
	<p>То есть метод непосредственно обращается к переменной закрытого поля, и это не требует уточнения его имени.</p>
	<p>Метод с заголовком public void display() осуществляет вывод сведений о текущем показании счетчика, представляемого объектом класса Counter и предельном значении maxCount, которое уже не может представлять объект класса.</p>
	<p>Метод открытый, ничего не возвращает в точку вызова и имеет пустой список параметров.</p>
	<p>В теле метода выполняются обращения к закрытым полям count и maxCount, значения которых выводятся на консоль.</p>
	<p>Чтобы привести пример создания и использования объектов класса Counter, напомним следующее.</p>
	<p>Класс является типом ссылок, то есть переменная с типом пользовательского класса представляет собой всего-навсего ссылку на объект класса.</p>
	<p>При создании переменной класса, ей соответствующий объект может еще не существовать, или эта переменная еще не связана ни с каким объектом.</p>
	<p>Для создания объекта класса используется выражение с операцией new, где в качестве операнда – обращание к конструктору объектов класса.</p>
	<p>Возникает вопрос, а как же быть, если в нашем классе Counter нет явного определения конструктора?</p>
	<p>В языке C# принято, что при отсутствии конструктора в декларации класса, в этот класс компилятор автоматически встраивает открытый конструктор умолчания, то есть конструктор, при обращении к которому не требуется задавать аргументы.</p>
	<p>В следующей программе определяются ссылки с1 и с2 типа Counter и создаются связанные с ними объекты.</p>
	<p>К объектам посредством ссылок применяются нестатические методы класса Counter.</p>

	<pre class="brush: csharp;">
	static void Main( )
	{
		// конструктор умолчания
		Counter c1 = new Counter( );
		Counter c2 = new Counter( );
		c1.display( );
		Console.WriteLine("c1.ToString( ): " + c1.ToString( ));
		Console.WriteLine("c1.GetType( ): " + c1.GetType( ));
		for(int i = 0; i < 150000; i++)
		{
			c1.increment( );
			if (i % 10 == 0) c2.increment( );
		}
		Console.WriteLine("c1.getCount() = " + c1.getCount( ));
		c2.display( );
	}
	</pre>

	<p>Для краткости здесь только текст функции Main( ).</p>
	<p>Предполагается, что и определение класса Counter и функция Main() принадлежат одному пространству имён.</p>
	<p>Результаты выполнения программы:</p>

	<pre class="brush: csharp;">
	Reading: 0 maxCount: 100000
	c1.ToString( ): Counter
	c1.GetType( ): Counter
	c1.getCount( ) = 50000
	Reading: 15000 maxCount: 100000
	</pre>

	<p>В теле функции Main( ) оператор <b>Counter c1 = new Counter();</b> объявляет переменную с1 – ссылку типа Counter.</p>
	<p>Выражение с операцией new представляет собой обращение к конструктору умолчания, неявно включенному компилятором в класс Counter.</p>
	<p>Тем самым создан объект класса Counter и с ним связана ссылка с1.</p>
	<p>Аналогично определяется второй объект и связанная с ним ссылка с2.</p>
	<p>Оператор <b>с1.display();</b> – это обращение к нестатическому методу display(), который вызывается для обработки объекта, связанного со ссылкой с1.</p>
	<p>В результате выполнения метода на консоль выводится строка, представляющая значения поля объекта и статического поля maxCount:</p>

	<pre class="brush: csharp;">
	Reading: 0
	maxCount: 100000
	</pre>

	<p>Вид представления определяет форматная строка метода Console.WriteLine( ), вызываемого в теле метода display( ).</p>
	<p>Так как при создании объекта использован конструктор умолчания Counter(), то переменные (поля) объекта получили значения за счет их инициализации (count=0 и maxCount=100000).</p>
	<p>Следующие два оператора метода Main( ) иллюстрируют применимость к объектам введенного программистом-пользователем класса Counter, методов, унаследованных этим классом от класса object.</p>
	<p>Как мы уже говорили, класс object является первичным базовым классом всех классов программ на C#.</p>
	<p>Применяемые к объектам пользовательского класса Counter методы ToString( ) и GetType( ) позволяют получить имя этого класса.</p>
	<p>В цикле с заголовком for (int i = 0; i &lt; 150000; i++) выполняются обращения к методу incrementM() для двух объектов класса, адресуемых ссылками с1 и с2.</p>
	<p>Для первого из них выполняется 150000 обращений, для второго – в 10 раз меньше.</p>
	<p>Метод при каждом обращении увеличивает текущее значение счетчика на 1, но «следит» за переполнением.</p>
	<p>Поле 99999 обращений счетчик, связанный со ссылкой с1 будет обнулен.</p>
	<p>Приведенные результаты иллюстрируют изменения объектов.</p>
	<p>Прежде чем завершить пояснения особенностей определенного нами класса и возможностей работы с его объектами, отметим, что в функции Main() используются только открытые методы класса Counter.</p>
	<p>В объявлениях методов increment(), getCount() и display() явно использован модификатор public.</p>
	<p>Конструктор умолчания Counter() создается компилятором автоматически как открытый.</p>
	<p>Именно названные четыре метода класса Counter формируют его внешний интерфейс.</p>
	<p>Обращения к закрытым полям класса невозможны. </p>
	<p>Если попытаться использовать вне класса, например, такой оператор:</p>

	<pre class="brush: csharp;">
	Console.Write ("count = {0 }", c1.count);
	</pre>

	<p>то компилятор сообщит об ошибке:</p>

	<pre class="brush: csharp;">
	Error 1 ' Counter.count' is inaccessible due to its protection level
	</pre>

	<script src="../../../../js/progressBarSetIni.js" type="text/javascript"></script>

        <div id="lessMenu" style="margin: 30px 0 0 0;">
            <hr />
            <a href="61.html"><div id="exitLess" ontouchstart="return true;"><img src="../../../../img/menu/pr.png" /></div></a>
            <a href="63.html"><div id="aaLess" ontouchstart="return true;"><img src="../../../../img/menu/ne.png" /></div></a>
        </div>

    </div>

    <script type="text/javascript" src="../../../../cordova.js"></script>
    <script type="text/javascript" src="../../../../js/global.js"></script>
    <script type="text/javascript">
        changeColor();
        if (localStorage.getItem("fSize") < 1) { fSize = 16; localStorage.setItem("fSize", 16); } else { fSize = localStorage.getItem("fSize"); }
        document.getElementById("pageBody").style.fontSize = fSize + "px";

        // goBackMenu
        document.addEventListener("backbutton", goBackMenu, false);
        function goBackMenu()
        {
            window.location.href = 'list.html';
        }

        function changeColor()
        {
            if (localStorage.getItem("colorSheme") <= 1)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#f0f0f0");
            }

            if (localStorage.getItem("colorSheme") == 2)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#212121");
                document.getElementById("pageBody").style.color = localStorage.getItem("#efefef");
            }

            if (localStorage.getItem("colorSheme") == 3)
            {
                document.getElementById("pageBody").style.backgroundColor = localStorage.getItem("#efe4d0");
            }
        }

        // bm
        if (localStorage.getItem("arrs") != null)
        {
            var arrs = JSON.parse(localStorage.getItem("arrs"));
        }
        else
        {
            var arrs = [];
        }

        var names = ["../acharter/ru/cshrp/book/62.html", "Пример класса", "bm149"];

        function setzBm() { arrs.push(names); localStorage.setItem("arrs", JSON.stringify(arrs)); localStorage.setItem("bm149", 1); RefBms(); }

        window.onload = function() { RefBms(); }

        function RefBms()
        {
            if (localStorage.getItem("bm149") == 1) { document.getElementById("bma149").style.display = "block"; document.getElementById("bm149").style.display = "none"; } else { document.getElementById("bma149").style.display = "none"; document.getElementById("bm149").style.display = "block"; }
        }

        function dellBm() { for (var i = 0; i < arrs.length; i++) { if (arrs[i].indexOf("Пример класса") == 1) { arrs.splice(i, 1); localStorage.setItem("bm149", 0); RefBms(); localStorage.setItem("arrs", JSON.stringify(arrs)); } } }

        // sub menu
        var serTimeToClose = 1000;
        
        function OpenSettMenu()
        {
            document.getElementById("subMenuInLess").style.display = "block";
            timeToEvAct();
            serTimeToClose = 1;
        }
        
        function timeToEvAct()
        {
            setTimeout(function() { serTimeToClose = 0 }, 100);
        }
        
        window.addEventListener('click', function(e){
        
            if (serTimeToClose <= 0)
            {
                if (document.getElementById('subMenuInLess').contains(e.target))
                {
                    //
                }
                else
                {
                    document.getElementById("subMenuInLess").style.display = "none";
                }
            }
        });

    </script>

</body>
</html>
